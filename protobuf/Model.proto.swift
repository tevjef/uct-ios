// Generated by the protocol buffer compiler.  DO NOT EDIT!
// Source file model.proto

import Foundation
import ProtocolBuffers


public func == (lhs: University, rhs: University) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasId == rhs.hasId) && (!lhs.hasId || lhs.id == rhs.id)
  fieldCheck = fieldCheck && (lhs.hasName == rhs.hasName) && (!lhs.hasName || lhs.name == rhs.name)
  fieldCheck = fieldCheck && (lhs.hasAbbr == rhs.hasAbbr) && (!lhs.hasAbbr || lhs.abbr == rhs.abbr)
  fieldCheck = fieldCheck && (lhs.hasHomePage == rhs.hasHomePage) && (!lhs.hasHomePage || lhs.homePage == rhs.homePage)
  fieldCheck = fieldCheck && (lhs.hasRegistrationPage == rhs.hasRegistrationPage) && (!lhs.hasRegistrationPage || lhs.registrationPage == rhs.registrationPage)
  fieldCheck = fieldCheck && (lhs.hasMainColor == rhs.hasMainColor) && (!lhs.hasMainColor || lhs.mainColor == rhs.mainColor)
  fieldCheck = fieldCheck && (lhs.hasAccentColor == rhs.hasAccentColor) && (!lhs.hasAccentColor || lhs.accentColor == rhs.accentColor)
  fieldCheck = fieldCheck && (lhs.hasTopicName == rhs.hasTopicName) && (!lhs.hasTopicName || lhs.topicName == rhs.topicName)
  fieldCheck = fieldCheck && (lhs.hasTopicId == rhs.hasTopicId) && (!lhs.hasTopicId || lhs.topicId == rhs.topicId)
  fieldCheck = fieldCheck && (lhs.hasResolvedSemesters == rhs.hasResolvedSemesters) && (!lhs.hasResolvedSemesters || lhs.resolvedSemesters == rhs.resolvedSemesters)
  fieldCheck = fieldCheck && (lhs.subjects == rhs.subjects)
  fieldCheck = fieldCheck && (lhs.availableSemesters == rhs.availableSemesters)
  fieldCheck = fieldCheck && (lhs.registrations == rhs.registrations)
  fieldCheck = fieldCheck && (lhs.metadata == rhs.metadata)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: Subject, rhs: Subject) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasId == rhs.hasId) && (!lhs.hasId || lhs.id == rhs.id)
  fieldCheck = fieldCheck && (lhs.hasUniversityId == rhs.hasUniversityId) && (!lhs.hasUniversityId || lhs.universityId == rhs.universityId)
  fieldCheck = fieldCheck && (lhs.hasName == rhs.hasName) && (!lhs.hasName || lhs.name == rhs.name)
  fieldCheck = fieldCheck && (lhs.hasNumber == rhs.hasNumber) && (!lhs.hasNumber || lhs.number == rhs.number)
  fieldCheck = fieldCheck && (lhs.hasSeason == rhs.hasSeason) && (!lhs.hasSeason || lhs.season == rhs.season)
  fieldCheck = fieldCheck && (lhs.hasYear == rhs.hasYear) && (!lhs.hasYear || lhs.year == rhs.year)
  fieldCheck = fieldCheck && (lhs.hasTopicName == rhs.hasTopicName) && (!lhs.hasTopicName || lhs.topicName == rhs.topicName)
  fieldCheck = fieldCheck && (lhs.hasTopicId == rhs.hasTopicId) && (!lhs.hasTopicId || lhs.topicId == rhs.topicId)
  fieldCheck = fieldCheck && (lhs.courses == rhs.courses)
  fieldCheck = fieldCheck && (lhs.metadata == rhs.metadata)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: Course, rhs: Course) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasId == rhs.hasId) && (!lhs.hasId || lhs.id == rhs.id)
  fieldCheck = fieldCheck && (lhs.hasSubjectId == rhs.hasSubjectId) && (!lhs.hasSubjectId || lhs.subjectId == rhs.subjectId)
  fieldCheck = fieldCheck && (lhs.hasName == rhs.hasName) && (!lhs.hasName || lhs.name == rhs.name)
  fieldCheck = fieldCheck && (lhs.hasNumber == rhs.hasNumber) && (!lhs.hasNumber || lhs.number == rhs.number)
  fieldCheck = fieldCheck && (lhs.hasSynopsis == rhs.hasSynopsis) && (!lhs.hasSynopsis || lhs.synopsis == rhs.synopsis)
  fieldCheck = fieldCheck && (lhs.hasTopicName == rhs.hasTopicName) && (!lhs.hasTopicName || lhs.topicName == rhs.topicName)
  fieldCheck = fieldCheck && (lhs.hasTopicId == rhs.hasTopicId) && (!lhs.hasTopicId || lhs.topicId == rhs.topicId)
  fieldCheck = fieldCheck && (lhs.sections == rhs.sections)
  fieldCheck = fieldCheck && (lhs.metadata == rhs.metadata)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: Section, rhs: Section) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasId == rhs.hasId) && (!lhs.hasId || lhs.id == rhs.id)
  fieldCheck = fieldCheck && (lhs.hasCourseId == rhs.hasCourseId) && (!lhs.hasCourseId || lhs.courseId == rhs.courseId)
  fieldCheck = fieldCheck && (lhs.hasNumber == rhs.hasNumber) && (!lhs.hasNumber || lhs.number == rhs.number)
  fieldCheck = fieldCheck && (lhs.hasCallNumber == rhs.hasCallNumber) && (!lhs.hasCallNumber || lhs.callNumber == rhs.callNumber)
  fieldCheck = fieldCheck && (lhs.hasMax == rhs.hasMax) && (!lhs.hasMax || lhs.max == rhs.max)
  fieldCheck = fieldCheck && (lhs.hasNow == rhs.hasNow) && (!lhs.hasNow || lhs.now == rhs.now)
  fieldCheck = fieldCheck && (lhs.hasStatus == rhs.hasStatus) && (!lhs.hasStatus || lhs.status == rhs.status)
  fieldCheck = fieldCheck && (lhs.hasCredits == rhs.hasCredits) && (!lhs.hasCredits || lhs.credits == rhs.credits)
  fieldCheck = fieldCheck && (lhs.hasTopicName == rhs.hasTopicName) && (!lhs.hasTopicName || lhs.topicName == rhs.topicName)
  fieldCheck = fieldCheck && (lhs.hasTopicId == rhs.hasTopicId) && (!lhs.hasTopicId || lhs.topicId == rhs.topicId)
  fieldCheck = fieldCheck && (lhs.meetings == rhs.meetings)
  fieldCheck = fieldCheck && (lhs.instructors == rhs.instructors)
  fieldCheck = fieldCheck && (lhs.books == rhs.books)
  fieldCheck = fieldCheck && (lhs.metadata == rhs.metadata)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: Meeting, rhs: Meeting) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasId == rhs.hasId) && (!lhs.hasId || lhs.id == rhs.id)
  fieldCheck = fieldCheck && (lhs.hasSectionId == rhs.hasSectionId) && (!lhs.hasSectionId || lhs.sectionId == rhs.sectionId)
  fieldCheck = fieldCheck && (lhs.hasRoom == rhs.hasRoom) && (!lhs.hasRoom || lhs.room == rhs.room)
  fieldCheck = fieldCheck && (lhs.hasDay == rhs.hasDay) && (!lhs.hasDay || lhs.day == rhs.day)
  fieldCheck = fieldCheck && (lhs.hasStartTime == rhs.hasStartTime) && (!lhs.hasStartTime || lhs.startTime == rhs.startTime)
  fieldCheck = fieldCheck && (lhs.hasEndTime == rhs.hasEndTime) && (!lhs.hasEndTime || lhs.endTime == rhs.endTime)
  fieldCheck = fieldCheck && (lhs.hasClassType == rhs.hasClassType) && (!lhs.hasClassType || lhs.classType == rhs.classType)
  fieldCheck = fieldCheck && (lhs.hasIndex == rhs.hasIndex) && (!lhs.hasIndex || lhs.index == rhs.index)
  fieldCheck = fieldCheck && (lhs.metadata == rhs.metadata)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: Instructor, rhs: Instructor) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasId == rhs.hasId) && (!lhs.hasId || lhs.id == rhs.id)
  fieldCheck = fieldCheck && (lhs.hasSectionId == rhs.hasSectionId) && (!lhs.hasSectionId || lhs.sectionId == rhs.sectionId)
  fieldCheck = fieldCheck && (lhs.hasName == rhs.hasName) && (!lhs.hasName || lhs.name == rhs.name)
  fieldCheck = fieldCheck && (lhs.hasIndex == rhs.hasIndex) && (!lhs.hasIndex || lhs.index == rhs.index)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: Book, rhs: Book) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasId == rhs.hasId) && (!lhs.hasId || lhs.id == rhs.id)
  fieldCheck = fieldCheck && (lhs.hasSectionId == rhs.hasSectionId) && (!lhs.hasSectionId || lhs.sectionId == rhs.sectionId)
  fieldCheck = fieldCheck && (lhs.hasTitle == rhs.hasTitle) && (!lhs.hasTitle || lhs.title == rhs.title)
  fieldCheck = fieldCheck && (lhs.hasUrl == rhs.hasUrl) && (!lhs.hasUrl || lhs.url == rhs.url)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: Metadata, rhs: Metadata) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasId == rhs.hasId) && (!lhs.hasId || lhs.id == rhs.id)
  fieldCheck = fieldCheck && (lhs.hasUniversityId == rhs.hasUniversityId) && (!lhs.hasUniversityId || lhs.universityId == rhs.universityId)
  fieldCheck = fieldCheck && (lhs.hasSubjectId == rhs.hasSubjectId) && (!lhs.hasSubjectId || lhs.subjectId == rhs.subjectId)
  fieldCheck = fieldCheck && (lhs.hasCourseId == rhs.hasCourseId) && (!lhs.hasCourseId || lhs.courseId == rhs.courseId)
  fieldCheck = fieldCheck && (lhs.hasSectionId == rhs.hasSectionId) && (!lhs.hasSectionId || lhs.sectionId == rhs.sectionId)
  fieldCheck = fieldCheck && (lhs.hasMeetingId == rhs.hasMeetingId) && (!lhs.hasMeetingId || lhs.meetingId == rhs.meetingId)
  fieldCheck = fieldCheck && (lhs.hasTitle == rhs.hasTitle) && (!lhs.hasTitle || lhs.title == rhs.title)
  fieldCheck = fieldCheck && (lhs.hasContent == rhs.hasContent) && (!lhs.hasContent || lhs.content == rhs.content)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: Registration, rhs: Registration) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasId == rhs.hasId) && (!lhs.hasId || lhs.id == rhs.id)
  fieldCheck = fieldCheck && (lhs.hasUniversityId == rhs.hasUniversityId) && (!lhs.hasUniversityId || lhs.universityId == rhs.universityId)
  fieldCheck = fieldCheck && (lhs.hasPeriod == rhs.hasPeriod) && (!lhs.hasPeriod || lhs.period == rhs.period)
  fieldCheck = fieldCheck && (lhs.hasPeriodDate == rhs.hasPeriodDate) && (!lhs.hasPeriodDate || lhs.periodDate == rhs.periodDate)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: ResolvedSemester, rhs: ResolvedSemester) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasCurrent == rhs.hasCurrent) && (!lhs.hasCurrent || lhs.current == rhs.current)
  fieldCheck = fieldCheck && (lhs.hasLast == rhs.hasLast) && (!lhs.hasLast || lhs.last == rhs.last)
  fieldCheck = fieldCheck && (lhs.hasNext == rhs.hasNext) && (!lhs.hasNext || lhs.next == rhs.next)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: Semester, rhs: Semester) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasYear == rhs.hasYear) && (!lhs.hasYear || lhs.year == rhs.year)
  fieldCheck = fieldCheck && (lhs.hasSeason == rhs.hasSeason) && (!lhs.hasSeason || lhs.season == rhs.season)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: Uctnotification, rhs: Uctnotification) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasNotificationId == rhs.hasNotificationId) && (!lhs.hasNotificationId || lhs.notificationId == rhs.notificationId)
  fieldCheck = fieldCheck && (lhs.hasTopicName == rhs.hasTopicName) && (!lhs.hasTopicName || lhs.topicName == rhs.topicName)
  fieldCheck = fieldCheck && (lhs.hasStatus == rhs.hasStatus) && (!lhs.hasStatus || lhs.status == rhs.status)
  fieldCheck = fieldCheck && (lhs.hasUniversity == rhs.hasUniversity) && (!lhs.hasUniversity || lhs.university == rhs.university)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: Response, rhs: Response) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasMeta == rhs.hasMeta) && (!lhs.hasMeta || lhs.meta == rhs.meta)
  fieldCheck = fieldCheck && (lhs.hasData == rhs.hasData) && (!lhs.hasData || lhs.data == rhs.data)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: Meta, rhs: Meta) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasCode == rhs.hasCode) && (!lhs.hasCode || lhs.code == rhs.code)
  fieldCheck = fieldCheck && (lhs.hasMessage_ == rhs.hasMessage_) && (!lhs.hasMessage_ || lhs.message_ == rhs.message_)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: Data, rhs: Data) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.universities == rhs.universities)
  fieldCheck = fieldCheck && (lhs.subjects == rhs.subjects)
  fieldCheck = fieldCheck && (lhs.courses == rhs.courses)
  fieldCheck = fieldCheck && (lhs.sections == rhs.sections)
  fieldCheck = fieldCheck && (lhs.hasUniversity == rhs.hasUniversity) && (!lhs.hasUniversity || lhs.university == rhs.university)
  fieldCheck = fieldCheck && (lhs.hasSubject == rhs.hasSubject) && (!lhs.hasSubject || lhs.subject == rhs.subject)
  fieldCheck = fieldCheck && (lhs.hasCourse == rhs.hasCourse) && (!lhs.hasCourse || lhs.course == rhs.course)
  fieldCheck = fieldCheck && (lhs.hasSection == rhs.hasSection) && (!lhs.hasSection || lhs.section == rhs.section)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public struct ModelRoot {
  public static var sharedInstance : ModelRoot {
   struct Static {
       static let instance : ModelRoot = ModelRoot()
   }
   return Static.instance
  }
  public var extensionRegistry:ExtensionRegistry

  init() {
    extensionRegistry = ExtensionRegistry()
    registerAllExtensions(extensionRegistry)
    Gogoproto.GogoRoot.sharedInstance.registerAllExtensions(extensionRegistry)
  }
  public func registerAllExtensions(registry:ExtensionRegistry) {
  }
}

final public class University : GeneratedMessage, GeneratedMessageProtocol {
  public private(set) var id:Int64 = Int64(0)

  public private(set) var hasId:Bool = false
  public private(set) var name:String = ""

  public private(set) var hasName:Bool = false
  public private(set) var abbr:String = ""

  public private(set) var hasAbbr:Bool = false
  public private(set) var homePage:String = ""

  public private(set) var hasHomePage:Bool = false
  public private(set) var registrationPage:String = ""

  public private(set) var hasRegistrationPage:Bool = false
  public private(set) var mainColor:String = ""

  public private(set) var hasMainColor:Bool = false
  public private(set) var accentColor:String = ""

  public private(set) var hasAccentColor:Bool = false
  public private(set) var topicName:String = ""

  public private(set) var hasTopicName:Bool = false
  public private(set) var topicId:String = ""

  public private(set) var hasTopicId:Bool = false
  public private(set) var resolvedSemesters:ResolvedSemester!
  public private(set) var hasResolvedSemesters:Bool = false
  public private(set) var subjects:Array<Subject>  = Array<Subject>()
  public private(set) var availableSemesters:Array<Semester>  = Array<Semester>()
  public private(set) var registrations:Array<Registration>  = Array<Registration>()
  public private(set) var metadata:Array<Metadata>  = Array<Metadata>()
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
   return true
  }
  override public func writeToCodedOutputStream(output:CodedOutputStream) throws {
    if hasId {
      try output.writeInt64(1, value:id)
    }
    if hasName {
      try output.writeString(2, value:name)
    }
    if hasAbbr {
      try output.writeString(3, value:abbr)
    }
    if hasHomePage {
      try output.writeString(4, value:homePage)
    }
    if hasRegistrationPage {
      try output.writeString(5, value:registrationPage)
    }
    if hasMainColor {
      try output.writeString(6, value:mainColor)
    }
    if hasAccentColor {
      try output.writeString(7, value:accentColor)
    }
    if hasTopicName {
      try output.writeString(8, value:topicName)
    }
    if hasTopicId {
      try output.writeString(9, value:topicId)
    }
    if hasResolvedSemesters {
      try output.writeMessage(10, value:resolvedSemesters)
    }
    for oneElementsubjects in subjects {
        try output.writeMessage(11, value:oneElementsubjects)
    }
    for oneElementavailableSemesters in availableSemesters {
        try output.writeMessage(12, value:oneElementavailableSemesters)
    }
    for oneElementregistrations in registrations {
        try output.writeMessage(13, value:oneElementregistrations)
    }
    for oneElementmetadata in metadata {
        try output.writeMessage(14, value:oneElementmetadata)
    }
    try unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var serialize_size:Int32 = memoizedSerializedSize
    if serialize_size != -1 {
     return serialize_size
    }

    serialize_size = 0
    if hasId {
      serialize_size += id.computeInt64Size(1)
    }
    if hasName {
      serialize_size += name.computeStringSize(2)
    }
    if hasAbbr {
      serialize_size += abbr.computeStringSize(3)
    }
    if hasHomePage {
      serialize_size += homePage.computeStringSize(4)
    }
    if hasRegistrationPage {
      serialize_size += registrationPage.computeStringSize(5)
    }
    if hasMainColor {
      serialize_size += mainColor.computeStringSize(6)
    }
    if hasAccentColor {
      serialize_size += accentColor.computeStringSize(7)
    }
    if hasTopicName {
      serialize_size += topicName.computeStringSize(8)
    }
    if hasTopicId {
      serialize_size += topicId.computeStringSize(9)
    }
    if hasResolvedSemesters {
        if let varSizeresolvedSemesters = resolvedSemesters?.computeMessageSize(10) {
            serialize_size += varSizeresolvedSemesters
        }
    }
    for oneElementsubjects in subjects {
        serialize_size += oneElementsubjects.computeMessageSize(11)
    }
    for oneElementavailableSemesters in availableSemesters {
        serialize_size += oneElementavailableSemesters.computeMessageSize(12)
    }
    for oneElementregistrations in registrations {
        serialize_size += oneElementregistrations.computeMessageSize(13)
    }
    for oneElementmetadata in metadata {
        serialize_size += oneElementmetadata.computeMessageSize(14)
    }
    serialize_size += unknownFields.serializedSize()
    memoizedSerializedSize = serialize_size
    return serialize_size
  }
  public class func parseArrayDelimitedFromInputStream(input:NSInputStream) throws -> Array<University> {
    var mergedArray = Array<University>()
    while let value = try parseFromDelimitedFromInputStream(input) {
      mergedArray += [value]
    }
    return mergedArray
  }
  public class func parseFromDelimitedFromInputStream(input:NSInputStream) throws -> University? {
    return try University.Builder().mergeDelimitedFromInputStream(input)?.build()
  }
  public class func parseFromData(data:NSData) throws -> University {
    return try University.Builder().mergeFromData(data, extensionRegistry:ModelRoot.sharedInstance.extensionRegistry).build()
  }
  public class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) throws -> University {
    return try University.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromInputStream(input:NSInputStream) throws -> University {
    return try University.Builder().mergeFromInputStream(input).build()
  }
  public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> University {
    return try University.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromCodedInputStream(input:CodedInputStream) throws -> University {
    return try University.Builder().mergeFromCodedInputStream(input).build()
  }
  public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> University {
    return try University.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func getBuilder() -> University.Builder {
    return University.classBuilder() as! University.Builder
  }
  public func getBuilder() -> University.Builder {
    return classBuilder() as! University.Builder
  }
  public override class func classBuilder() -> MessageBuilder {
    return University.Builder()
  }
  public override func classBuilder() -> MessageBuilder {
    return University.Builder()
  }
  public func toBuilder() throws -> University.Builder {
    return try University.builderWithPrototype(self)
  }
  public class func builderWithPrototype(prototype:University) throws -> University.Builder {
    return try University.Builder().mergeFrom(prototype)
  }
  override public func getDescription(indent:String) throws -> String {
    var output:String = ""
    if hasId {
      output += "\(indent) id: \(id) \n"
    }
    if hasName {
      output += "\(indent) name: \(name) \n"
    }
    if hasAbbr {
      output += "\(indent) abbr: \(abbr) \n"
    }
    if hasHomePage {
      output += "\(indent) homePage: \(homePage) \n"
    }
    if hasRegistrationPage {
      output += "\(indent) registrationPage: \(registrationPage) \n"
    }
    if hasMainColor {
      output += "\(indent) mainColor: \(mainColor) \n"
    }
    if hasAccentColor {
      output += "\(indent) accentColor: \(accentColor) \n"
    }
    if hasTopicName {
      output += "\(indent) topicName: \(topicName) \n"
    }
    if hasTopicId {
      output += "\(indent) topicId: \(topicId) \n"
    }
    if hasResolvedSemesters {
      output += "\(indent) resolvedSemesters {\n"
      if let outDescResolvedSemesters = resolvedSemesters {
        output += try outDescResolvedSemesters.getDescription("\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    var subjectsElementIndex:Int = 0
    for oneElementsubjects in subjects {
        output += "\(indent) subjects[\(subjectsElementIndex)] {\n"
        output += try oneElementsubjects.getDescription("\(indent)  ")
        output += "\(indent)}\n"
        subjectsElementIndex += 1
    }
    var availableSemestersElementIndex:Int = 0
    for oneElementavailableSemesters in availableSemesters {
        output += "\(indent) availableSemesters[\(availableSemestersElementIndex)] {\n"
        output += try oneElementavailableSemesters.getDescription("\(indent)  ")
        output += "\(indent)}\n"
        availableSemestersElementIndex += 1
    }
    var registrationsElementIndex:Int = 0
    for oneElementregistrations in registrations {
        output += "\(indent) registrations[\(registrationsElementIndex)] {\n"
        output += try oneElementregistrations.getDescription("\(indent)  ")
        output += "\(indent)}\n"
        registrationsElementIndex += 1
    }
    var metadataElementIndex:Int = 0
    for oneElementmetadata in metadata {
        output += "\(indent) metadata[\(metadataElementIndex)] {\n"
        output += try oneElementmetadata.getDescription("\(indent)  ")
        output += "\(indent)}\n"
        metadataElementIndex += 1
    }
    output += unknownFields.getDescription(indent)
    return output
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasId {
             hashCode = (hashCode &* 31) &+ id.hashValue
          }
          if hasName {
             hashCode = (hashCode &* 31) &+ name.hashValue
          }
          if hasAbbr {
             hashCode = (hashCode &* 31) &+ abbr.hashValue
          }
          if hasHomePage {
             hashCode = (hashCode &* 31) &+ homePage.hashValue
          }
          if hasRegistrationPage {
             hashCode = (hashCode &* 31) &+ registrationPage.hashValue
          }
          if hasMainColor {
             hashCode = (hashCode &* 31) &+ mainColor.hashValue
          }
          if hasAccentColor {
             hashCode = (hashCode &* 31) &+ accentColor.hashValue
          }
          if hasTopicName {
             hashCode = (hashCode &* 31) &+ topicName.hashValue
          }
          if hasTopicId {
             hashCode = (hashCode &* 31) &+ topicId.hashValue
          }
          if hasResolvedSemesters {
              if let hashValueresolvedSemesters = resolvedSemesters?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValueresolvedSemesters
              }
          }
          for oneElementsubjects in subjects {
              hashCode = (hashCode &* 31) &+ oneElementsubjects.hashValue
          }
          for oneElementavailableSemesters in availableSemesters {
              hashCode = (hashCode &* 31) &+ oneElementavailableSemesters.hashValue
          }
          for oneElementregistrations in registrations {
              hashCode = (hashCode &* 31) &+ oneElementregistrations.hashValue
          }
          for oneElementmetadata in metadata {
              hashCode = (hashCode &* 31) &+ oneElementmetadata.hashValue
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "University"
  }
  override public func className() -> String {
      return "University"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return University.self
  }
  //Meta information declaration end

  final public class Builder : GeneratedMessageBuilder {
    private var builderResult:University = University()
    public func getMessage() -> University {
        return builderResult
    }

    required override public init () {
       super.init()
    }
    public var hasId:Bool {
         get {
              return builderResult.hasId
         }
    }
    public var id:Int64 {
         get {
              return builderResult.id
         }
         set (value) {
             builderResult.hasId = true
             builderResult.id = value
         }
    }
    public func setId(value:Int64) -> University.Builder {
      self.id = value
      return self
    }
    public func clearId() -> University.Builder{
         builderResult.hasId = false
         builderResult.id = Int64(0)
         return self
    }
    public var hasName:Bool {
         get {
              return builderResult.hasName
         }
    }
    public var name:String {
         get {
              return builderResult.name
         }
         set (value) {
             builderResult.hasName = true
             builderResult.name = value
         }
    }
    public func setName(value:String) -> University.Builder {
      self.name = value
      return self
    }
    public func clearName() -> University.Builder{
         builderResult.hasName = false
         builderResult.name = ""
         return self
    }
    public var hasAbbr:Bool {
         get {
              return builderResult.hasAbbr
         }
    }
    public var abbr:String {
         get {
              return builderResult.abbr
         }
         set (value) {
             builderResult.hasAbbr = true
             builderResult.abbr = value
         }
    }
    public func setAbbr(value:String) -> University.Builder {
      self.abbr = value
      return self
    }
    public func clearAbbr() -> University.Builder{
         builderResult.hasAbbr = false
         builderResult.abbr = ""
         return self
    }
    public var hasHomePage:Bool {
         get {
              return builderResult.hasHomePage
         }
    }
    public var homePage:String {
         get {
              return builderResult.homePage
         }
         set (value) {
             builderResult.hasHomePage = true
             builderResult.homePage = value
         }
    }
    public func setHomePage(value:String) -> University.Builder {
      self.homePage = value
      return self
    }
    public func clearHomePage() -> University.Builder{
         builderResult.hasHomePage = false
         builderResult.homePage = ""
         return self
    }
    public var hasRegistrationPage:Bool {
         get {
              return builderResult.hasRegistrationPage
         }
    }
    public var registrationPage:String {
         get {
              return builderResult.registrationPage
         }
         set (value) {
             builderResult.hasRegistrationPage = true
             builderResult.registrationPage = value
         }
    }
    public func setRegistrationPage(value:String) -> University.Builder {
      self.registrationPage = value
      return self
    }
    public func clearRegistrationPage() -> University.Builder{
         builderResult.hasRegistrationPage = false
         builderResult.registrationPage = ""
         return self
    }
    public var hasMainColor:Bool {
         get {
              return builderResult.hasMainColor
         }
    }
    public var mainColor:String {
         get {
              return builderResult.mainColor
         }
         set (value) {
             builderResult.hasMainColor = true
             builderResult.mainColor = value
         }
    }
    public func setMainColor(value:String) -> University.Builder {
      self.mainColor = value
      return self
    }
    public func clearMainColor() -> University.Builder{
         builderResult.hasMainColor = false
         builderResult.mainColor = ""
         return self
    }
    public var hasAccentColor:Bool {
         get {
              return builderResult.hasAccentColor
         }
    }
    public var accentColor:String {
         get {
              return builderResult.accentColor
         }
         set (value) {
             builderResult.hasAccentColor = true
             builderResult.accentColor = value
         }
    }
    public func setAccentColor(value:String) -> University.Builder {
      self.accentColor = value
      return self
    }
    public func clearAccentColor() -> University.Builder{
         builderResult.hasAccentColor = false
         builderResult.accentColor = ""
         return self
    }
    public var hasTopicName:Bool {
         get {
              return builderResult.hasTopicName
         }
    }
    public var topicName:String {
         get {
              return builderResult.topicName
         }
         set (value) {
             builderResult.hasTopicName = true
             builderResult.topicName = value
         }
    }
    public func setTopicName(value:String) -> University.Builder {
      self.topicName = value
      return self
    }
    public func clearTopicName() -> University.Builder{
         builderResult.hasTopicName = false
         builderResult.topicName = ""
         return self
    }
    public var hasTopicId:Bool {
         get {
              return builderResult.hasTopicId
         }
    }
    public var topicId:String {
         get {
              return builderResult.topicId
         }
         set (value) {
             builderResult.hasTopicId = true
             builderResult.topicId = value
         }
    }
    public func setTopicId(value:String) -> University.Builder {
      self.topicId = value
      return self
    }
    public func clearTopicId() -> University.Builder{
         builderResult.hasTopicId = false
         builderResult.topicId = ""
         return self
    }
    public var hasResolvedSemesters:Bool {
         get {
             return builderResult.hasResolvedSemesters
         }
    }
    public var resolvedSemesters:ResolvedSemester! {
         get {
             if resolvedSemestersBuilder_ != nil {
                builderResult.resolvedSemesters = resolvedSemestersBuilder_.getMessage()
             }
             return builderResult.resolvedSemesters
         }
         set (value) {
             builderResult.hasResolvedSemesters = true
             builderResult.resolvedSemesters = value
         }
    }
    private var resolvedSemestersBuilder_:ResolvedSemester.Builder! {
         didSet {
            builderResult.hasResolvedSemesters = true
         }
    }
    public func getResolvedSemestersBuilder() -> ResolvedSemester.Builder {
      if resolvedSemestersBuilder_ == nil {
         resolvedSemestersBuilder_ = ResolvedSemester.Builder()
         builderResult.resolvedSemesters = resolvedSemestersBuilder_.getMessage()
         if resolvedSemesters != nil {
            try! resolvedSemestersBuilder_.mergeFrom(resolvedSemesters)
         }
      }
      return resolvedSemestersBuilder_
    }
    public func setResolvedSemesters(value:ResolvedSemester!) -> University.Builder {
      self.resolvedSemesters = value
      return self
    }
    public func mergeResolvedSemesters(value:ResolvedSemester) throws -> University.Builder {
      if builderResult.hasResolvedSemesters {
        builderResult.resolvedSemesters = try ResolvedSemester.builderWithPrototype(builderResult.resolvedSemesters).mergeFrom(value).buildPartial()
      } else {
        builderResult.resolvedSemesters = value
      }
      builderResult.hasResolvedSemesters = true
      return self
    }
    public func clearResolvedSemesters() -> University.Builder {
      resolvedSemestersBuilder_ = nil
      builderResult.hasResolvedSemesters = false
      builderResult.resolvedSemesters = nil
      return self
    }
    public var subjects:Array<Subject> {
         get {
             return builderResult.subjects
         }
         set (value) {
             builderResult.subjects = value
         }
    }
    public func setSubjects(value:Array<Subject>) -> University.Builder {
      self.subjects = value
      return self
    }
    public func clearSubjects() -> University.Builder {
      builderResult.subjects.removeAll(keepCapacity: false)
      return self
    }
    public var availableSemesters:Array<Semester> {
         get {
             return builderResult.availableSemesters
         }
         set (value) {
             builderResult.availableSemesters = value
         }
    }
    public func setAvailableSemesters(value:Array<Semester>) -> University.Builder {
      self.availableSemesters = value
      return self
    }
    public func clearAvailableSemesters() -> University.Builder {
      builderResult.availableSemesters.removeAll(keepCapacity: false)
      return self
    }
    public var registrations:Array<Registration> {
         get {
             return builderResult.registrations
         }
         set (value) {
             builderResult.registrations = value
         }
    }
    public func setRegistrations(value:Array<Registration>) -> University.Builder {
      self.registrations = value
      return self
    }
    public func clearRegistrations() -> University.Builder {
      builderResult.registrations.removeAll(keepCapacity: false)
      return self
    }
    public var metadata:Array<Metadata> {
         get {
             return builderResult.metadata
         }
         set (value) {
             builderResult.metadata = value
         }
    }
    public func setMetadata(value:Array<Metadata>) -> University.Builder {
      self.metadata = value
      return self
    }
    public func clearMetadata() -> University.Builder {
      builderResult.metadata.removeAll(keepCapacity: false)
      return self
    }
    override public var internalGetResult:GeneratedMessage {
         get {
            return builderResult
         }
    }
    public override func clear() -> University.Builder {
      builderResult = University()
      return self
    }
    public override func clone() throws -> University.Builder {
      return try University.builderWithPrototype(builderResult)
    }
    public override func build() throws -> University {
         try checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> University {
      let returnMe:University = builderResult
      return returnMe
    }
    public func mergeFrom(other:University) throws -> University.Builder {
      if other == University() {
       return self
      }
      if other.hasId {
           id = other.id
      }
      if other.hasName {
           name = other.name
      }
      if other.hasAbbr {
           abbr = other.abbr
      }
      if other.hasHomePage {
           homePage = other.homePage
      }
      if other.hasRegistrationPage {
           registrationPage = other.registrationPage
      }
      if other.hasMainColor {
           mainColor = other.mainColor
      }
      if other.hasAccentColor {
           accentColor = other.accentColor
      }
      if other.hasTopicName {
           topicName = other.topicName
      }
      if other.hasTopicId {
           topicId = other.topicId
      }
      if (other.hasResolvedSemesters) {
          try mergeResolvedSemesters(other.resolvedSemesters)
      }
      if !other.subjects.isEmpty  {
         builderResult.subjects += other.subjects
      }
      if !other.availableSemesters.isEmpty  {
         builderResult.availableSemesters += other.availableSemesters
      }
      if !other.registrations.isEmpty  {
         builderResult.registrations += other.registrations
      }
      if !other.metadata.isEmpty  {
         builderResult.metadata += other.metadata
      }
      try mergeUnknownFields(other.unknownFields)
      return self
    }
    public override func mergeFromCodedInputStream(input:CodedInputStream) throws -> University.Builder {
         return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
    }
    public override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> University.Builder {
      let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
      while (true) {
        let protobufTag = try input.readTag()
        switch protobufTag {
        case 0: 
          self.unknownFields = try unknownFieldsBuilder.build()
          return self

        case 8 :
          id = try input.readInt64()

        case 18 :
          name = try input.readString()

        case 26 :
          abbr = try input.readString()

        case 34 :
          homePage = try input.readString()

        case 42 :
          registrationPage = try input.readString()

        case 50 :
          mainColor = try input.readString()

        case 58 :
          accentColor = try input.readString()

        case 66 :
          topicName = try input.readString()

        case 74 :
          topicId = try input.readString()

        case 82 :
          let subBuilder:ResolvedSemester.Builder = ResolvedSemester.Builder()
          if hasResolvedSemesters {
            try subBuilder.mergeFrom(resolvedSemesters)
          }
          try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
          resolvedSemesters = subBuilder.buildPartial()

        case 90 :
          let subBuilder = Subject.Builder()
          try input.readMessage(subBuilder,extensionRegistry:extensionRegistry)
          subjects += [subBuilder.buildPartial()]

        case 98 :
          let subBuilder = Semester.Builder()
          try input.readMessage(subBuilder,extensionRegistry:extensionRegistry)
          availableSemesters += [subBuilder.buildPartial()]

        case 106 :
          let subBuilder = Registration.Builder()
          try input.readMessage(subBuilder,extensionRegistry:extensionRegistry)
          registrations += [subBuilder.buildPartial()]

        case 114 :
          let subBuilder = Metadata.Builder()
          try input.readMessage(subBuilder,extensionRegistry:extensionRegistry)
          metadata += [subBuilder.buildPartial()]

        default:
          if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
             unknownFields = try unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
  }

}

final public class Subject : GeneratedMessage, GeneratedMessageProtocol {
  public private(set) var id:Int64 = Int64(0)

  public private(set) var hasId:Bool = false
  public private(set) var universityId:Int64 = Int64(0)

  public private(set) var hasUniversityId:Bool = false
  public private(set) var name:String = ""

  public private(set) var hasName:Bool = false
  public private(set) var number:String = ""

  public private(set) var hasNumber:Bool = false
  public private(set) var season:String = ""

  public private(set) var hasSeason:Bool = false
  public private(set) var year:String = ""

  public private(set) var hasYear:Bool = false
  public private(set) var topicName:String = ""

  public private(set) var hasTopicName:Bool = false
  public private(set) var topicId:String = ""

  public private(set) var hasTopicId:Bool = false
  public private(set) var courses:Array<Course>  = Array<Course>()
  public private(set) var metadata:Array<Metadata>  = Array<Metadata>()
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
   return true
  }
  override public func writeToCodedOutputStream(output:CodedOutputStream) throws {
    if hasId {
      try output.writeInt64(1, value:id)
    }
    if hasUniversityId {
      try output.writeInt64(2, value:universityId)
    }
    if hasName {
      try output.writeString(3, value:name)
    }
    if hasNumber {
      try output.writeString(4, value:number)
    }
    if hasSeason {
      try output.writeString(5, value:season)
    }
    if hasYear {
      try output.writeString(6, value:year)
    }
    if hasTopicName {
      try output.writeString(7, value:topicName)
    }
    if hasTopicId {
      try output.writeString(8, value:topicId)
    }
    for oneElementcourses in courses {
        try output.writeMessage(9, value:oneElementcourses)
    }
    for oneElementmetadata in metadata {
        try output.writeMessage(10, value:oneElementmetadata)
    }
    try unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var serialize_size:Int32 = memoizedSerializedSize
    if serialize_size != -1 {
     return serialize_size
    }

    serialize_size = 0
    if hasId {
      serialize_size += id.computeInt64Size(1)
    }
    if hasUniversityId {
      serialize_size += universityId.computeInt64Size(2)
    }
    if hasName {
      serialize_size += name.computeStringSize(3)
    }
    if hasNumber {
      serialize_size += number.computeStringSize(4)
    }
    if hasSeason {
      serialize_size += season.computeStringSize(5)
    }
    if hasYear {
      serialize_size += year.computeStringSize(6)
    }
    if hasTopicName {
      serialize_size += topicName.computeStringSize(7)
    }
    if hasTopicId {
      serialize_size += topicId.computeStringSize(8)
    }
    for oneElementcourses in courses {
        serialize_size += oneElementcourses.computeMessageSize(9)
    }
    for oneElementmetadata in metadata {
        serialize_size += oneElementmetadata.computeMessageSize(10)
    }
    serialize_size += unknownFields.serializedSize()
    memoizedSerializedSize = serialize_size
    return serialize_size
  }
  public class func parseArrayDelimitedFromInputStream(input:NSInputStream) throws -> Array<Subject> {
    var mergedArray = Array<Subject>()
    while let value = try parseFromDelimitedFromInputStream(input) {
      mergedArray += [value]
    }
    return mergedArray
  }
  public class func parseFromDelimitedFromInputStream(input:NSInputStream) throws -> Subject? {
    return try Subject.Builder().mergeDelimitedFromInputStream(input)?.build()
  }
  public class func parseFromData(data:NSData) throws -> Subject {
    return try Subject.Builder().mergeFromData(data, extensionRegistry:ModelRoot.sharedInstance.extensionRegistry).build()
  }
  public class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) throws -> Subject {
    return try Subject.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromInputStream(input:NSInputStream) throws -> Subject {
    return try Subject.Builder().mergeFromInputStream(input).build()
  }
  public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> Subject {
    return try Subject.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromCodedInputStream(input:CodedInputStream) throws -> Subject {
    return try Subject.Builder().mergeFromCodedInputStream(input).build()
  }
  public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Subject {
    return try Subject.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func getBuilder() -> Subject.Builder {
    return Subject.classBuilder() as! Subject.Builder
  }
  public func getBuilder() -> Subject.Builder {
    return classBuilder() as! Subject.Builder
  }
  public override class func classBuilder() -> MessageBuilder {
    return Subject.Builder()
  }
  public override func classBuilder() -> MessageBuilder {
    return Subject.Builder()
  }
  public func toBuilder() throws -> Subject.Builder {
    return try Subject.builderWithPrototype(self)
  }
  public class func builderWithPrototype(prototype:Subject) throws -> Subject.Builder {
    return try Subject.Builder().mergeFrom(prototype)
  }
  override public func getDescription(indent:String) throws -> String {
    var output:String = ""
    if hasId {
      output += "\(indent) id: \(id) \n"
    }
    if hasUniversityId {
      output += "\(indent) universityId: \(universityId) \n"
    }
    if hasName {
      output += "\(indent) name: \(name) \n"
    }
    if hasNumber {
      output += "\(indent) number: \(number) \n"
    }
    if hasSeason {
      output += "\(indent) season: \(season) \n"
    }
    if hasYear {
      output += "\(indent) year: \(year) \n"
    }
    if hasTopicName {
      output += "\(indent) topicName: \(topicName) \n"
    }
    if hasTopicId {
      output += "\(indent) topicId: \(topicId) \n"
    }
    var coursesElementIndex:Int = 0
    for oneElementcourses in courses {
        output += "\(indent) courses[\(coursesElementIndex)] {\n"
        output += try oneElementcourses.getDescription("\(indent)  ")
        output += "\(indent)}\n"
        coursesElementIndex += 1
    }
    var metadataElementIndex:Int = 0
    for oneElementmetadata in metadata {
        output += "\(indent) metadata[\(metadataElementIndex)] {\n"
        output += try oneElementmetadata.getDescription("\(indent)  ")
        output += "\(indent)}\n"
        metadataElementIndex += 1
    }
    output += unknownFields.getDescription(indent)
    return output
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasId {
             hashCode = (hashCode &* 31) &+ id.hashValue
          }
          if hasUniversityId {
             hashCode = (hashCode &* 31) &+ universityId.hashValue
          }
          if hasName {
             hashCode = (hashCode &* 31) &+ name.hashValue
          }
          if hasNumber {
             hashCode = (hashCode &* 31) &+ number.hashValue
          }
          if hasSeason {
             hashCode = (hashCode &* 31) &+ season.hashValue
          }
          if hasYear {
             hashCode = (hashCode &* 31) &+ year.hashValue
          }
          if hasTopicName {
             hashCode = (hashCode &* 31) &+ topicName.hashValue
          }
          if hasTopicId {
             hashCode = (hashCode &* 31) &+ topicId.hashValue
          }
          for oneElementcourses in courses {
              hashCode = (hashCode &* 31) &+ oneElementcourses.hashValue
          }
          for oneElementmetadata in metadata {
              hashCode = (hashCode &* 31) &+ oneElementmetadata.hashValue
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "Subject"
  }
  override public func className() -> String {
      return "Subject"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return Subject.self
  }
  //Meta information declaration end

  final public class Builder : GeneratedMessageBuilder {
    private var builderResult:Subject = Subject()
    public func getMessage() -> Subject {
        return builderResult
    }

    required override public init () {
       super.init()
    }
    public var hasId:Bool {
         get {
              return builderResult.hasId
         }
    }
    public var id:Int64 {
         get {
              return builderResult.id
         }
         set (value) {
             builderResult.hasId = true
             builderResult.id = value
         }
    }
    public func setId(value:Int64) -> Subject.Builder {
      self.id = value
      return self
    }
    public func clearId() -> Subject.Builder{
         builderResult.hasId = false
         builderResult.id = Int64(0)
         return self
    }
    public var hasUniversityId:Bool {
         get {
              return builderResult.hasUniversityId
         }
    }
    public var universityId:Int64 {
         get {
              return builderResult.universityId
         }
         set (value) {
             builderResult.hasUniversityId = true
             builderResult.universityId = value
         }
    }
    public func setUniversityId(value:Int64) -> Subject.Builder {
      self.universityId = value
      return self
    }
    public func clearUniversityId() -> Subject.Builder{
         builderResult.hasUniversityId = false
         builderResult.universityId = Int64(0)
         return self
    }
    public var hasName:Bool {
         get {
              return builderResult.hasName
         }
    }
    public var name:String {
         get {
              return builderResult.name
         }
         set (value) {
             builderResult.hasName = true
             builderResult.name = value
         }
    }
    public func setName(value:String) -> Subject.Builder {
      self.name = value
      return self
    }
    public func clearName() -> Subject.Builder{
         builderResult.hasName = false
         builderResult.name = ""
         return self
    }
    public var hasNumber:Bool {
         get {
              return builderResult.hasNumber
         }
    }
    public var number:String {
         get {
              return builderResult.number
         }
         set (value) {
             builderResult.hasNumber = true
             builderResult.number = value
         }
    }
    public func setNumber(value:String) -> Subject.Builder {
      self.number = value
      return self
    }
    public func clearNumber() -> Subject.Builder{
         builderResult.hasNumber = false
         builderResult.number = ""
         return self
    }
    public var hasSeason:Bool {
         get {
              return builderResult.hasSeason
         }
    }
    public var season:String {
         get {
              return builderResult.season
         }
         set (value) {
             builderResult.hasSeason = true
             builderResult.season = value
         }
    }
    public func setSeason(value:String) -> Subject.Builder {
      self.season = value
      return self
    }
    public func clearSeason() -> Subject.Builder{
         builderResult.hasSeason = false
         builderResult.season = ""
         return self
    }
    public var hasYear:Bool {
         get {
              return builderResult.hasYear
         }
    }
    public var year:String {
         get {
              return builderResult.year
         }
         set (value) {
             builderResult.hasYear = true
             builderResult.year = value
         }
    }
    public func setYear(value:String) -> Subject.Builder {
      self.year = value
      return self
    }
    public func clearYear() -> Subject.Builder{
         builderResult.hasYear = false
         builderResult.year = ""
         return self
    }
    public var hasTopicName:Bool {
         get {
              return builderResult.hasTopicName
         }
    }
    public var topicName:String {
         get {
              return builderResult.topicName
         }
         set (value) {
             builderResult.hasTopicName = true
             builderResult.topicName = value
         }
    }
    public func setTopicName(value:String) -> Subject.Builder {
      self.topicName = value
      return self
    }
    public func clearTopicName() -> Subject.Builder{
         builderResult.hasTopicName = false
         builderResult.topicName = ""
         return self
    }
    public var hasTopicId:Bool {
         get {
              return builderResult.hasTopicId
         }
    }
    public var topicId:String {
         get {
              return builderResult.topicId
         }
         set (value) {
             builderResult.hasTopicId = true
             builderResult.topicId = value
         }
    }
    public func setTopicId(value:String) -> Subject.Builder {
      self.topicId = value
      return self
    }
    public func clearTopicId() -> Subject.Builder{
         builderResult.hasTopicId = false
         builderResult.topicId = ""
         return self
    }
    public var courses:Array<Course> {
         get {
             return builderResult.courses
         }
         set (value) {
             builderResult.courses = value
         }
    }
    public func setCourses(value:Array<Course>) -> Subject.Builder {
      self.courses = value
      return self
    }
    public func clearCourses() -> Subject.Builder {
      builderResult.courses.removeAll(keepCapacity: false)
      return self
    }
    public var metadata:Array<Metadata> {
         get {
             return builderResult.metadata
         }
         set (value) {
             builderResult.metadata = value
         }
    }
    public func setMetadata(value:Array<Metadata>) -> Subject.Builder {
      self.metadata = value
      return self
    }
    public func clearMetadata() -> Subject.Builder {
      builderResult.metadata.removeAll(keepCapacity: false)
      return self
    }
    override public var internalGetResult:GeneratedMessage {
         get {
            return builderResult
         }
    }
    public override func clear() -> Subject.Builder {
      builderResult = Subject()
      return self
    }
    public override func clone() throws -> Subject.Builder {
      return try Subject.builderWithPrototype(builderResult)
    }
    public override func build() throws -> Subject {
         try checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> Subject {
      let returnMe:Subject = builderResult
      return returnMe
    }
    public func mergeFrom(other:Subject) throws -> Subject.Builder {
      if other == Subject() {
       return self
      }
      if other.hasId {
           id = other.id
      }
      if other.hasUniversityId {
           universityId = other.universityId
      }
      if other.hasName {
           name = other.name
      }
      if other.hasNumber {
           number = other.number
      }
      if other.hasSeason {
           season = other.season
      }
      if other.hasYear {
           year = other.year
      }
      if other.hasTopicName {
           topicName = other.topicName
      }
      if other.hasTopicId {
           topicId = other.topicId
      }
      if !other.courses.isEmpty  {
         builderResult.courses += other.courses
      }
      if !other.metadata.isEmpty  {
         builderResult.metadata += other.metadata
      }
      try mergeUnknownFields(other.unknownFields)
      return self
    }
    public override func mergeFromCodedInputStream(input:CodedInputStream) throws -> Subject.Builder {
         return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
    }
    public override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Subject.Builder {
      let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
      while (true) {
        let protobufTag = try input.readTag()
        switch protobufTag {
        case 0: 
          self.unknownFields = try unknownFieldsBuilder.build()
          return self

        case 8 :
          id = try input.readInt64()

        case 16 :
          universityId = try input.readInt64()

        case 26 :
          name = try input.readString()

        case 34 :
          number = try input.readString()

        case 42 :
          season = try input.readString()

        case 50 :
          year = try input.readString()

        case 58 :
          topicName = try input.readString()

        case 66 :
          topicId = try input.readString()

        case 74 :
          let subBuilder = Course.Builder()
          try input.readMessage(subBuilder,extensionRegistry:extensionRegistry)
          courses += [subBuilder.buildPartial()]

        case 82 :
          let subBuilder = Metadata.Builder()
          try input.readMessage(subBuilder,extensionRegistry:extensionRegistry)
          metadata += [subBuilder.buildPartial()]

        default:
          if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
             unknownFields = try unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
  }

}

final public class Course : GeneratedMessage, GeneratedMessageProtocol {
  public private(set) var id:Int64 = Int64(0)

  public private(set) var hasId:Bool = false
  public private(set) var subjectId:Int64 = Int64(0)

  public private(set) var hasSubjectId:Bool = false
  public private(set) var name:String = ""

  public private(set) var hasName:Bool = false
  public private(set) var number:String = ""

  public private(set) var hasNumber:Bool = false
  public private(set) var synopsis:String = ""

  public private(set) var hasSynopsis:Bool = false
  public private(set) var topicName:String = ""

  public private(set) var hasTopicName:Bool = false
  public private(set) var topicId:String = ""

  public private(set) var hasTopicId:Bool = false
  public private(set) var sections:Array<Section>  = Array<Section>()
  public private(set) var metadata:Array<Metadata>  = Array<Metadata>()
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
   return true
  }
  override public func writeToCodedOutputStream(output:CodedOutputStream) throws {
    if hasId {
      try output.writeInt64(1, value:id)
    }
    if hasSubjectId {
      try output.writeInt64(2, value:subjectId)
    }
    if hasName {
      try output.writeString(3, value:name)
    }
    if hasNumber {
      try output.writeString(4, value:number)
    }
    if hasSynopsis {
      try output.writeString(5, value:synopsis)
    }
    if hasTopicName {
      try output.writeString(6, value:topicName)
    }
    if hasTopicId {
      try output.writeString(7, value:topicId)
    }
    for oneElementsections in sections {
        try output.writeMessage(8, value:oneElementsections)
    }
    for oneElementmetadata in metadata {
        try output.writeMessage(9, value:oneElementmetadata)
    }
    try unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var serialize_size:Int32 = memoizedSerializedSize
    if serialize_size != -1 {
     return serialize_size
    }

    serialize_size = 0
    if hasId {
      serialize_size += id.computeInt64Size(1)
    }
    if hasSubjectId {
      serialize_size += subjectId.computeInt64Size(2)
    }
    if hasName {
      serialize_size += name.computeStringSize(3)
    }
    if hasNumber {
      serialize_size += number.computeStringSize(4)
    }
    if hasSynopsis {
      serialize_size += synopsis.computeStringSize(5)
    }
    if hasTopicName {
      serialize_size += topicName.computeStringSize(6)
    }
    if hasTopicId {
      serialize_size += topicId.computeStringSize(7)
    }
    for oneElementsections in sections {
        serialize_size += oneElementsections.computeMessageSize(8)
    }
    for oneElementmetadata in metadata {
        serialize_size += oneElementmetadata.computeMessageSize(9)
    }
    serialize_size += unknownFields.serializedSize()
    memoizedSerializedSize = serialize_size
    return serialize_size
  }
  public class func parseArrayDelimitedFromInputStream(input:NSInputStream) throws -> Array<Course> {
    var mergedArray = Array<Course>()
    while let value = try parseFromDelimitedFromInputStream(input) {
      mergedArray += [value]
    }
    return mergedArray
  }
  public class func parseFromDelimitedFromInputStream(input:NSInputStream) throws -> Course? {
    return try Course.Builder().mergeDelimitedFromInputStream(input)?.build()
  }
  public class func parseFromData(data:NSData) throws -> Course {
    return try Course.Builder().mergeFromData(data, extensionRegistry:ModelRoot.sharedInstance.extensionRegistry).build()
  }
  public class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) throws -> Course {
    return try Course.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromInputStream(input:NSInputStream) throws -> Course {
    return try Course.Builder().mergeFromInputStream(input).build()
  }
  public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> Course {
    return try Course.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromCodedInputStream(input:CodedInputStream) throws -> Course {
    return try Course.Builder().mergeFromCodedInputStream(input).build()
  }
  public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Course {
    return try Course.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func getBuilder() -> Course.Builder {
    return Course.classBuilder() as! Course.Builder
  }
  public func getBuilder() -> Course.Builder {
    return classBuilder() as! Course.Builder
  }
  public override class func classBuilder() -> MessageBuilder {
    return Course.Builder()
  }
  public override func classBuilder() -> MessageBuilder {
    return Course.Builder()
  }
  public func toBuilder() throws -> Course.Builder {
    return try Course.builderWithPrototype(self)
  }
  public class func builderWithPrototype(prototype:Course) throws -> Course.Builder {
    return try Course.Builder().mergeFrom(prototype)
  }
  override public func getDescription(indent:String) throws -> String {
    var output:String = ""
    if hasId {
      output += "\(indent) id: \(id) \n"
    }
    if hasSubjectId {
      output += "\(indent) subjectId: \(subjectId) \n"
    }
    if hasName {
      output += "\(indent) name: \(name) \n"
    }
    if hasNumber {
      output += "\(indent) number: \(number) \n"
    }
    if hasSynopsis {
      output += "\(indent) synopsis: \(synopsis) \n"
    }
    if hasTopicName {
      output += "\(indent) topicName: \(topicName) \n"
    }
    if hasTopicId {
      output += "\(indent) topicId: \(topicId) \n"
    }
    var sectionsElementIndex:Int = 0
    for oneElementsections in sections {
        output += "\(indent) sections[\(sectionsElementIndex)] {\n"
        output += try oneElementsections.getDescription("\(indent)  ")
        output += "\(indent)}\n"
        sectionsElementIndex += 1
    }
    var metadataElementIndex:Int = 0
    for oneElementmetadata in metadata {
        output += "\(indent) metadata[\(metadataElementIndex)] {\n"
        output += try oneElementmetadata.getDescription("\(indent)  ")
        output += "\(indent)}\n"
        metadataElementIndex += 1
    }
    output += unknownFields.getDescription(indent)
    return output
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasId {
             hashCode = (hashCode &* 31) &+ id.hashValue
          }
          if hasSubjectId {
             hashCode = (hashCode &* 31) &+ subjectId.hashValue
          }
          if hasName {
             hashCode = (hashCode &* 31) &+ name.hashValue
          }
          if hasNumber {
             hashCode = (hashCode &* 31) &+ number.hashValue
          }
          if hasSynopsis {
             hashCode = (hashCode &* 31) &+ synopsis.hashValue
          }
          if hasTopicName {
             hashCode = (hashCode &* 31) &+ topicName.hashValue
          }
          if hasTopicId {
             hashCode = (hashCode &* 31) &+ topicId.hashValue
          }
          for oneElementsections in sections {
              hashCode = (hashCode &* 31) &+ oneElementsections.hashValue
          }
          for oneElementmetadata in metadata {
              hashCode = (hashCode &* 31) &+ oneElementmetadata.hashValue
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "Course"
  }
  override public func className() -> String {
      return "Course"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return Course.self
  }
  //Meta information declaration end

  final public class Builder : GeneratedMessageBuilder {
    private var builderResult:Course = Course()
    public func getMessage() -> Course {
        return builderResult
    }

    required override public init () {
       super.init()
    }
    public var hasId:Bool {
         get {
              return builderResult.hasId
         }
    }
    public var id:Int64 {
         get {
              return builderResult.id
         }
         set (value) {
             builderResult.hasId = true
             builderResult.id = value
         }
    }
    public func setId(value:Int64) -> Course.Builder {
      self.id = value
      return self
    }
    public func clearId() -> Course.Builder{
         builderResult.hasId = false
         builderResult.id = Int64(0)
         return self
    }
    public var hasSubjectId:Bool {
         get {
              return builderResult.hasSubjectId
         }
    }
    public var subjectId:Int64 {
         get {
              return builderResult.subjectId
         }
         set (value) {
             builderResult.hasSubjectId = true
             builderResult.subjectId = value
         }
    }
    public func setSubjectId(value:Int64) -> Course.Builder {
      self.subjectId = value
      return self
    }
    public func clearSubjectId() -> Course.Builder{
         builderResult.hasSubjectId = false
         builderResult.subjectId = Int64(0)
         return self
    }
    public var hasName:Bool {
         get {
              return builderResult.hasName
         }
    }
    public var name:String {
         get {
              return builderResult.name
         }
         set (value) {
             builderResult.hasName = true
             builderResult.name = value
         }
    }
    public func setName(value:String) -> Course.Builder {
      self.name = value
      return self
    }
    public func clearName() -> Course.Builder{
         builderResult.hasName = false
         builderResult.name = ""
         return self
    }
    public var hasNumber:Bool {
         get {
              return builderResult.hasNumber
         }
    }
    public var number:String {
         get {
              return builderResult.number
         }
         set (value) {
             builderResult.hasNumber = true
             builderResult.number = value
         }
    }
    public func setNumber(value:String) -> Course.Builder {
      self.number = value
      return self
    }
    public func clearNumber() -> Course.Builder{
         builderResult.hasNumber = false
         builderResult.number = ""
         return self
    }
    public var hasSynopsis:Bool {
         get {
              return builderResult.hasSynopsis
         }
    }
    public var synopsis:String {
         get {
              return builderResult.synopsis
         }
         set (value) {
             builderResult.hasSynopsis = true
             builderResult.synopsis = value
         }
    }
    public func setSynopsis(value:String) -> Course.Builder {
      self.synopsis = value
      return self
    }
    public func clearSynopsis() -> Course.Builder{
         builderResult.hasSynopsis = false
         builderResult.synopsis = ""
         return self
    }
    public var hasTopicName:Bool {
         get {
              return builderResult.hasTopicName
         }
    }
    public var topicName:String {
         get {
              return builderResult.topicName
         }
         set (value) {
             builderResult.hasTopicName = true
             builderResult.topicName = value
         }
    }
    public func setTopicName(value:String) -> Course.Builder {
      self.topicName = value
      return self
    }
    public func clearTopicName() -> Course.Builder{
         builderResult.hasTopicName = false
         builderResult.topicName = ""
         return self
    }
    public var hasTopicId:Bool {
         get {
              return builderResult.hasTopicId
         }
    }
    public var topicId:String {
         get {
              return builderResult.topicId
         }
         set (value) {
             builderResult.hasTopicId = true
             builderResult.topicId = value
         }
    }
    public func setTopicId(value:String) -> Course.Builder {
      self.topicId = value
      return self
    }
    public func clearTopicId() -> Course.Builder{
         builderResult.hasTopicId = false
         builderResult.topicId = ""
         return self
    }
    public var sections:Array<Section> {
         get {
             return builderResult.sections
         }
         set (value) {
             builderResult.sections = value
         }
    }
    public func setSections(value:Array<Section>) -> Course.Builder {
      self.sections = value
      return self
    }
    public func clearSections() -> Course.Builder {
      builderResult.sections.removeAll(keepCapacity: false)
      return self
    }
    public var metadata:Array<Metadata> {
         get {
             return builderResult.metadata
         }
         set (value) {
             builderResult.metadata = value
         }
    }
    public func setMetadata(value:Array<Metadata>) -> Course.Builder {
      self.metadata = value
      return self
    }
    public func clearMetadata() -> Course.Builder {
      builderResult.metadata.removeAll(keepCapacity: false)
      return self
    }
    override public var internalGetResult:GeneratedMessage {
         get {
            return builderResult
         }
    }
    public override func clear() -> Course.Builder {
      builderResult = Course()
      return self
    }
    public override func clone() throws -> Course.Builder {
      return try Course.builderWithPrototype(builderResult)
    }
    public override func build() throws -> Course {
         try checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> Course {
      let returnMe:Course = builderResult
      return returnMe
    }
    public func mergeFrom(other:Course) throws -> Course.Builder {
      if other == Course() {
       return self
      }
      if other.hasId {
           id = other.id
      }
      if other.hasSubjectId {
           subjectId = other.subjectId
      }
      if other.hasName {
           name = other.name
      }
      if other.hasNumber {
           number = other.number
      }
      if other.hasSynopsis {
           synopsis = other.synopsis
      }
      if other.hasTopicName {
           topicName = other.topicName
      }
      if other.hasTopicId {
           topicId = other.topicId
      }
      if !other.sections.isEmpty  {
         builderResult.sections += other.sections
      }
      if !other.metadata.isEmpty  {
         builderResult.metadata += other.metadata
      }
      try mergeUnknownFields(other.unknownFields)
      return self
    }
    public override func mergeFromCodedInputStream(input:CodedInputStream) throws -> Course.Builder {
         return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
    }
    public override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Course.Builder {
      let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
      while (true) {
        let protobufTag = try input.readTag()
        switch protobufTag {
        case 0: 
          self.unknownFields = try unknownFieldsBuilder.build()
          return self

        case 8 :
          id = try input.readInt64()

        case 16 :
          subjectId = try input.readInt64()

        case 26 :
          name = try input.readString()

        case 34 :
          number = try input.readString()

        case 42 :
          synopsis = try input.readString()

        case 50 :
          topicName = try input.readString()

        case 58 :
          topicId = try input.readString()

        case 66 :
          let subBuilder = Section.Builder()
          try input.readMessage(subBuilder,extensionRegistry:extensionRegistry)
          sections += [subBuilder.buildPartial()]

        case 74 :
          let subBuilder = Metadata.Builder()
          try input.readMessage(subBuilder,extensionRegistry:extensionRegistry)
          metadata += [subBuilder.buildPartial()]

        default:
          if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
             unknownFields = try unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
  }

}

final public class Section : GeneratedMessage, GeneratedMessageProtocol {
  public private(set) var id:Int64 = Int64(0)

  public private(set) var hasId:Bool = false
  public private(set) var courseId:Int64 = Int64(0)

  public private(set) var hasCourseId:Bool = false
  public private(set) var number:String = ""

  public private(set) var hasNumber:Bool = false
  public private(set) var callNumber:String = ""

  public private(set) var hasCallNumber:Bool = false
  public private(set) var max:Int64 = Int64(0)

  public private(set) var hasMax:Bool = false
  public private(set) var now:Int64 = Int64(0)

  public private(set) var hasNow:Bool = false
  public private(set) var status:String = ""

  public private(set) var hasStatus:Bool = false
  public private(set) var credits:String = ""

  public private(set) var hasCredits:Bool = false
  public private(set) var topicName:String = ""

  public private(set) var hasTopicName:Bool = false
  public private(set) var topicId:String = ""

  public private(set) var hasTopicId:Bool = false
  public private(set) var meetings:Array<Meeting>  = Array<Meeting>()
  public private(set) var instructors:Array<Instructor>  = Array<Instructor>()
  public private(set) var books:Array<Book>  = Array<Book>()
  public private(set) var metadata:Array<Metadata>  = Array<Metadata>()
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
   return true
  }
  override public func writeToCodedOutputStream(output:CodedOutputStream) throws {
    if hasId {
      try output.writeInt64(1, value:id)
    }
    if hasCourseId {
      try output.writeInt64(2, value:courseId)
    }
    if hasNumber {
      try output.writeString(3, value:number)
    }
    if hasCallNumber {
      try output.writeString(4, value:callNumber)
    }
    if hasMax {
      try output.writeInt64(5, value:max)
    }
    if hasNow {
      try output.writeInt64(6, value:now)
    }
    if hasStatus {
      try output.writeString(7, value:status)
    }
    if hasCredits {
      try output.writeString(8, value:credits)
    }
    if hasTopicName {
      try output.writeString(9, value:topicName)
    }
    if hasTopicId {
      try output.writeString(10, value:topicId)
    }
    for oneElementmeetings in meetings {
        try output.writeMessage(11, value:oneElementmeetings)
    }
    for oneElementinstructors in instructors {
        try output.writeMessage(12, value:oneElementinstructors)
    }
    for oneElementbooks in books {
        try output.writeMessage(13, value:oneElementbooks)
    }
    for oneElementmetadata in metadata {
        try output.writeMessage(14, value:oneElementmetadata)
    }
    try unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var serialize_size:Int32 = memoizedSerializedSize
    if serialize_size != -1 {
     return serialize_size
    }

    serialize_size = 0
    if hasId {
      serialize_size += id.computeInt64Size(1)
    }
    if hasCourseId {
      serialize_size += courseId.computeInt64Size(2)
    }
    if hasNumber {
      serialize_size += number.computeStringSize(3)
    }
    if hasCallNumber {
      serialize_size += callNumber.computeStringSize(4)
    }
    if hasMax {
      serialize_size += max.computeInt64Size(5)
    }
    if hasNow {
      serialize_size += now.computeInt64Size(6)
    }
    if hasStatus {
      serialize_size += status.computeStringSize(7)
    }
    if hasCredits {
      serialize_size += credits.computeStringSize(8)
    }
    if hasTopicName {
      serialize_size += topicName.computeStringSize(9)
    }
    if hasTopicId {
      serialize_size += topicId.computeStringSize(10)
    }
    for oneElementmeetings in meetings {
        serialize_size += oneElementmeetings.computeMessageSize(11)
    }
    for oneElementinstructors in instructors {
        serialize_size += oneElementinstructors.computeMessageSize(12)
    }
    for oneElementbooks in books {
        serialize_size += oneElementbooks.computeMessageSize(13)
    }
    for oneElementmetadata in metadata {
        serialize_size += oneElementmetadata.computeMessageSize(14)
    }
    serialize_size += unknownFields.serializedSize()
    memoizedSerializedSize = serialize_size
    return serialize_size
  }
  public class func parseArrayDelimitedFromInputStream(input:NSInputStream) throws -> Array<Section> {
    var mergedArray = Array<Section>()
    while let value = try parseFromDelimitedFromInputStream(input) {
      mergedArray += [value]
    }
    return mergedArray
  }
  public class func parseFromDelimitedFromInputStream(input:NSInputStream) throws -> Section? {
    return try Section.Builder().mergeDelimitedFromInputStream(input)?.build()
  }
  public class func parseFromData(data:NSData) throws -> Section {
    return try Section.Builder().mergeFromData(data, extensionRegistry:ModelRoot.sharedInstance.extensionRegistry).build()
  }
  public class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) throws -> Section {
    return try Section.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromInputStream(input:NSInputStream) throws -> Section {
    return try Section.Builder().mergeFromInputStream(input).build()
  }
  public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> Section {
    return try Section.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromCodedInputStream(input:CodedInputStream) throws -> Section {
    return try Section.Builder().mergeFromCodedInputStream(input).build()
  }
  public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Section {
    return try Section.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func getBuilder() -> Section.Builder {
    return Section.classBuilder() as! Section.Builder
  }
  public func getBuilder() -> Section.Builder {
    return classBuilder() as! Section.Builder
  }
  public override class func classBuilder() -> MessageBuilder {
    return Section.Builder()
  }
  public override func classBuilder() -> MessageBuilder {
    return Section.Builder()
  }
  public func toBuilder() throws -> Section.Builder {
    return try Section.builderWithPrototype(self)
  }
  public class func builderWithPrototype(prototype:Section) throws -> Section.Builder {
    return try Section.Builder().mergeFrom(prototype)
  }
  override public func getDescription(indent:String) throws -> String {
    var output:String = ""
    if hasId {
      output += "\(indent) id: \(id) \n"
    }
    if hasCourseId {
      output += "\(indent) courseId: \(courseId) \n"
    }
    if hasNumber {
      output += "\(indent) number: \(number) \n"
    }
    if hasCallNumber {
      output += "\(indent) callNumber: \(callNumber) \n"
    }
    if hasMax {
      output += "\(indent) max: \(max) \n"
    }
    if hasNow {
      output += "\(indent) now: \(now) \n"
    }
    if hasStatus {
      output += "\(indent) status: \(status) \n"
    }
    if hasCredits {
      output += "\(indent) credits: \(credits) \n"
    }
    if hasTopicName {
      output += "\(indent) topicName: \(topicName) \n"
    }
    if hasTopicId {
      output += "\(indent) topicId: \(topicId) \n"
    }
    var meetingsElementIndex:Int = 0
    for oneElementmeetings in meetings {
        output += "\(indent) meetings[\(meetingsElementIndex)] {\n"
        output += try oneElementmeetings.getDescription("\(indent)  ")
        output += "\(indent)}\n"
        meetingsElementIndex += 1
    }
    var instructorsElementIndex:Int = 0
    for oneElementinstructors in instructors {
        output += "\(indent) instructors[\(instructorsElementIndex)] {\n"
        output += try oneElementinstructors.getDescription("\(indent)  ")
        output += "\(indent)}\n"
        instructorsElementIndex += 1
    }
    var booksElementIndex:Int = 0
    for oneElementbooks in books {
        output += "\(indent) books[\(booksElementIndex)] {\n"
        output += try oneElementbooks.getDescription("\(indent)  ")
        output += "\(indent)}\n"
        booksElementIndex += 1
    }
    var metadataElementIndex:Int = 0
    for oneElementmetadata in metadata {
        output += "\(indent) metadata[\(metadataElementIndex)] {\n"
        output += try oneElementmetadata.getDescription("\(indent)  ")
        output += "\(indent)}\n"
        metadataElementIndex += 1
    }
    output += unknownFields.getDescription(indent)
    return output
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasId {
             hashCode = (hashCode &* 31) &+ id.hashValue
          }
          if hasCourseId {
             hashCode = (hashCode &* 31) &+ courseId.hashValue
          }
          if hasNumber {
             hashCode = (hashCode &* 31) &+ number.hashValue
          }
          if hasCallNumber {
             hashCode = (hashCode &* 31) &+ callNumber.hashValue
          }
          if hasMax {
             hashCode = (hashCode &* 31) &+ max.hashValue
          }
          if hasNow {
             hashCode = (hashCode &* 31) &+ now.hashValue
          }
          if hasStatus {
             hashCode = (hashCode &* 31) &+ status.hashValue
          }
          if hasCredits {
             hashCode = (hashCode &* 31) &+ credits.hashValue
          }
          if hasTopicName {
             hashCode = (hashCode &* 31) &+ topicName.hashValue
          }
          if hasTopicId {
             hashCode = (hashCode &* 31) &+ topicId.hashValue
          }
          for oneElementmeetings in meetings {
              hashCode = (hashCode &* 31) &+ oneElementmeetings.hashValue
          }
          for oneElementinstructors in instructors {
              hashCode = (hashCode &* 31) &+ oneElementinstructors.hashValue
          }
          for oneElementbooks in books {
              hashCode = (hashCode &* 31) &+ oneElementbooks.hashValue
          }
          for oneElementmetadata in metadata {
              hashCode = (hashCode &* 31) &+ oneElementmetadata.hashValue
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "Section"
  }
  override public func className() -> String {
      return "Section"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return Section.self
  }
  //Meta information declaration end

  final public class Builder : GeneratedMessageBuilder {
    private var builderResult:Section = Section()
    public func getMessage() -> Section {
        return builderResult
    }

    required override public init () {
       super.init()
    }
    public var hasId:Bool {
         get {
              return builderResult.hasId
         }
    }
    public var id:Int64 {
         get {
              return builderResult.id
         }
         set (value) {
             builderResult.hasId = true
             builderResult.id = value
         }
    }
    public func setId(value:Int64) -> Section.Builder {
      self.id = value
      return self
    }
    public func clearId() -> Section.Builder{
         builderResult.hasId = false
         builderResult.id = Int64(0)
         return self
    }
    public var hasCourseId:Bool {
         get {
              return builderResult.hasCourseId
         }
    }
    public var courseId:Int64 {
         get {
              return builderResult.courseId
         }
         set (value) {
             builderResult.hasCourseId = true
             builderResult.courseId = value
         }
    }
    public func setCourseId(value:Int64) -> Section.Builder {
      self.courseId = value
      return self
    }
    public func clearCourseId() -> Section.Builder{
         builderResult.hasCourseId = false
         builderResult.courseId = Int64(0)
         return self
    }
    public var hasNumber:Bool {
         get {
              return builderResult.hasNumber
         }
    }
    public var number:String {
         get {
              return builderResult.number
         }
         set (value) {
             builderResult.hasNumber = true
             builderResult.number = value
         }
    }
    public func setNumber(value:String) -> Section.Builder {
      self.number = value
      return self
    }
    public func clearNumber() -> Section.Builder{
         builderResult.hasNumber = false
         builderResult.number = ""
         return self
    }
    public var hasCallNumber:Bool {
         get {
              return builderResult.hasCallNumber
         }
    }
    public var callNumber:String {
         get {
              return builderResult.callNumber
         }
         set (value) {
             builderResult.hasCallNumber = true
             builderResult.callNumber = value
         }
    }
    public func setCallNumber(value:String) -> Section.Builder {
      self.callNumber = value
      return self
    }
    public func clearCallNumber() -> Section.Builder{
         builderResult.hasCallNumber = false
         builderResult.callNumber = ""
         return self
    }
    public var hasMax:Bool {
         get {
              return builderResult.hasMax
         }
    }
    public var max:Int64 {
         get {
              return builderResult.max
         }
         set (value) {
             builderResult.hasMax = true
             builderResult.max = value
         }
    }
    public func setMax(value:Int64) -> Section.Builder {
      self.max = value
      return self
    }
    public func clearMax() -> Section.Builder{
         builderResult.hasMax = false
         builderResult.max = Int64(0)
         return self
    }
    public var hasNow:Bool {
         get {
              return builderResult.hasNow
         }
    }
    public var now:Int64 {
         get {
              return builderResult.now
         }
         set (value) {
             builderResult.hasNow = true
             builderResult.now = value
         }
    }
    public func setNow(value:Int64) -> Section.Builder {
      self.now = value
      return self
    }
    public func clearNow() -> Section.Builder{
         builderResult.hasNow = false
         builderResult.now = Int64(0)
         return self
    }
    public var hasStatus:Bool {
         get {
              return builderResult.hasStatus
         }
    }
    public var status:String {
         get {
              return builderResult.status
         }
         set (value) {
             builderResult.hasStatus = true
             builderResult.status = value
         }
    }
    public func setStatus(value:String) -> Section.Builder {
      self.status = value
      return self
    }
    public func clearStatus() -> Section.Builder{
         builderResult.hasStatus = false
         builderResult.status = ""
         return self
    }
    public var hasCredits:Bool {
         get {
              return builderResult.hasCredits
         }
    }
    public var credits:String {
         get {
              return builderResult.credits
         }
         set (value) {
             builderResult.hasCredits = true
             builderResult.credits = value
         }
    }
    public func setCredits(value:String) -> Section.Builder {
      self.credits = value
      return self
    }
    public func clearCredits() -> Section.Builder{
         builderResult.hasCredits = false
         builderResult.credits = ""
         return self
    }
    public var hasTopicName:Bool {
         get {
              return builderResult.hasTopicName
         }
    }
    public var topicName:String {
         get {
              return builderResult.topicName
         }
         set (value) {
             builderResult.hasTopicName = true
             builderResult.topicName = value
         }
    }
    public func setTopicName(value:String) -> Section.Builder {
      self.topicName = value
      return self
    }
    public func clearTopicName() -> Section.Builder{
         builderResult.hasTopicName = false
         builderResult.topicName = ""
         return self
    }
    public var hasTopicId:Bool {
         get {
              return builderResult.hasTopicId
         }
    }
    public var topicId:String {
         get {
              return builderResult.topicId
         }
         set (value) {
             builderResult.hasTopicId = true
             builderResult.topicId = value
         }
    }
    public func setTopicId(value:String) -> Section.Builder {
      self.topicId = value
      return self
    }
    public func clearTopicId() -> Section.Builder{
         builderResult.hasTopicId = false
         builderResult.topicId = ""
         return self
    }
    public var meetings:Array<Meeting> {
         get {
             return builderResult.meetings
         }
         set (value) {
             builderResult.meetings = value
         }
    }
    public func setMeetings(value:Array<Meeting>) -> Section.Builder {
      self.meetings = value
      return self
    }
    public func clearMeetings() -> Section.Builder {
      builderResult.meetings.removeAll(keepCapacity: false)
      return self
    }
    public var instructors:Array<Instructor> {
         get {
             return builderResult.instructors
         }
         set (value) {
             builderResult.instructors = value
         }
    }
    public func setInstructors(value:Array<Instructor>) -> Section.Builder {
      self.instructors = value
      return self
    }
    public func clearInstructors() -> Section.Builder {
      builderResult.instructors.removeAll(keepCapacity: false)
      return self
    }
    public var books:Array<Book> {
         get {
             return builderResult.books
         }
         set (value) {
             builderResult.books = value
         }
    }
    public func setBooks(value:Array<Book>) -> Section.Builder {
      self.books = value
      return self
    }
    public func clearBooks() -> Section.Builder {
      builderResult.books.removeAll(keepCapacity: false)
      return self
    }
    public var metadata:Array<Metadata> {
         get {
             return builderResult.metadata
         }
         set (value) {
             builderResult.metadata = value
         }
    }
    public func setMetadata(value:Array<Metadata>) -> Section.Builder {
      self.metadata = value
      return self
    }
    public func clearMetadata() -> Section.Builder {
      builderResult.metadata.removeAll(keepCapacity: false)
      return self
    }
    override public var internalGetResult:GeneratedMessage {
         get {
            return builderResult
         }
    }
    public override func clear() -> Section.Builder {
      builderResult = Section()
      return self
    }
    public override func clone() throws -> Section.Builder {
      return try Section.builderWithPrototype(builderResult)
    }
    public override func build() throws -> Section {
         try checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> Section {
      let returnMe:Section = builderResult
      return returnMe
    }
    public func mergeFrom(other:Section) throws -> Section.Builder {
      if other == Section() {
       return self
      }
      if other.hasId {
           id = other.id
      }
      if other.hasCourseId {
           courseId = other.courseId
      }
      if other.hasNumber {
           number = other.number
      }
      if other.hasCallNumber {
           callNumber = other.callNumber
      }
      if other.hasMax {
           max = other.max
      }
      if other.hasNow {
           now = other.now
      }
      if other.hasStatus {
           status = other.status
      }
      if other.hasCredits {
           credits = other.credits
      }
      if other.hasTopicName {
           topicName = other.topicName
      }
      if other.hasTopicId {
           topicId = other.topicId
      }
      if !other.meetings.isEmpty  {
         builderResult.meetings += other.meetings
      }
      if !other.instructors.isEmpty  {
         builderResult.instructors += other.instructors
      }
      if !other.books.isEmpty  {
         builderResult.books += other.books
      }
      if !other.metadata.isEmpty  {
         builderResult.metadata += other.metadata
      }
      try mergeUnknownFields(other.unknownFields)
      return self
    }
    public override func mergeFromCodedInputStream(input:CodedInputStream) throws -> Section.Builder {
         return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
    }
    public override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Section.Builder {
      let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
      while (true) {
        let protobufTag = try input.readTag()
        switch protobufTag {
        case 0: 
          self.unknownFields = try unknownFieldsBuilder.build()
          return self

        case 8 :
          id = try input.readInt64()

        case 16 :
          courseId = try input.readInt64()

        case 26 :
          number = try input.readString()

        case 34 :
          callNumber = try input.readString()

        case 40 :
          max = try input.readInt64()

        case 48 :
          now = try input.readInt64()

        case 58 :
          status = try input.readString()

        case 66 :
          credits = try input.readString()

        case 74 :
          topicName = try input.readString()

        case 82 :
          topicId = try input.readString()

        case 90 :
          let subBuilder = Meeting.Builder()
          try input.readMessage(subBuilder,extensionRegistry:extensionRegistry)
          meetings += [subBuilder.buildPartial()]

        case 98 :
          let subBuilder = Instructor.Builder()
          try input.readMessage(subBuilder,extensionRegistry:extensionRegistry)
          instructors += [subBuilder.buildPartial()]

        case 106 :
          let subBuilder = Book.Builder()
          try input.readMessage(subBuilder,extensionRegistry:extensionRegistry)
          books += [subBuilder.buildPartial()]

        case 114 :
          let subBuilder = Metadata.Builder()
          try input.readMessage(subBuilder,extensionRegistry:extensionRegistry)
          metadata += [subBuilder.buildPartial()]

        default:
          if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
             unknownFields = try unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
  }

}

final public class Meeting : GeneratedMessage, GeneratedMessageProtocol {
  public private(set) var id:Int64 = Int64(0)

  public private(set) var hasId:Bool = false
  public private(set) var sectionId:Int64 = Int64(0)

  public private(set) var hasSectionId:Bool = false
  public private(set) var room:String = ""

  public private(set) var hasRoom:Bool = false
  public private(set) var day:String = ""

  public private(set) var hasDay:Bool = false
  public private(set) var startTime:String = ""

  public private(set) var hasStartTime:Bool = false
  public private(set) var endTime:String = ""

  public private(set) var hasEndTime:Bool = false
  public private(set) var classType:String = ""

  public private(set) var hasClassType:Bool = false
  public private(set) var index:Int32 = Int32(0)

  public private(set) var hasIndex:Bool = false
  public private(set) var metadata:Array<Metadata>  = Array<Metadata>()
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
   return true
  }
  override public func writeToCodedOutputStream(output:CodedOutputStream) throws {
    if hasId {
      try output.writeInt64(1, value:id)
    }
    if hasSectionId {
      try output.writeInt64(2, value:sectionId)
    }
    if hasRoom {
      try output.writeString(3, value:room)
    }
    if hasDay {
      try output.writeString(4, value:day)
    }
    if hasStartTime {
      try output.writeString(5, value:startTime)
    }
    if hasEndTime {
      try output.writeString(6, value:endTime)
    }
    if hasClassType {
      try output.writeString(7, value:classType)
    }
    if hasIndex {
      try output.writeInt32(8, value:index)
    }
    for oneElementmetadata in metadata {
        try output.writeMessage(9, value:oneElementmetadata)
    }
    try unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var serialize_size:Int32 = memoizedSerializedSize
    if serialize_size != -1 {
     return serialize_size
    }

    serialize_size = 0
    if hasId {
      serialize_size += id.computeInt64Size(1)
    }
    if hasSectionId {
      serialize_size += sectionId.computeInt64Size(2)
    }
    if hasRoom {
      serialize_size += room.computeStringSize(3)
    }
    if hasDay {
      serialize_size += day.computeStringSize(4)
    }
    if hasStartTime {
      serialize_size += startTime.computeStringSize(5)
    }
    if hasEndTime {
      serialize_size += endTime.computeStringSize(6)
    }
    if hasClassType {
      serialize_size += classType.computeStringSize(7)
    }
    if hasIndex {
      serialize_size += index.computeInt32Size(8)
    }
    for oneElementmetadata in metadata {
        serialize_size += oneElementmetadata.computeMessageSize(9)
    }
    serialize_size += unknownFields.serializedSize()
    memoizedSerializedSize = serialize_size
    return serialize_size
  }
  public class func parseArrayDelimitedFromInputStream(input:NSInputStream) throws -> Array<Meeting> {
    var mergedArray = Array<Meeting>()
    while let value = try parseFromDelimitedFromInputStream(input) {
      mergedArray += [value]
    }
    return mergedArray
  }
  public class func parseFromDelimitedFromInputStream(input:NSInputStream) throws -> Meeting? {
    return try Meeting.Builder().mergeDelimitedFromInputStream(input)?.build()
  }
  public class func parseFromData(data:NSData) throws -> Meeting {
    return try Meeting.Builder().mergeFromData(data, extensionRegistry:ModelRoot.sharedInstance.extensionRegistry).build()
  }
  public class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) throws -> Meeting {
    return try Meeting.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromInputStream(input:NSInputStream) throws -> Meeting {
    return try Meeting.Builder().mergeFromInputStream(input).build()
  }
  public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> Meeting {
    return try Meeting.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromCodedInputStream(input:CodedInputStream) throws -> Meeting {
    return try Meeting.Builder().mergeFromCodedInputStream(input).build()
  }
  public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Meeting {
    return try Meeting.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func getBuilder() -> Meeting.Builder {
    return Meeting.classBuilder() as! Meeting.Builder
  }
  public func getBuilder() -> Meeting.Builder {
    return classBuilder() as! Meeting.Builder
  }
  public override class func classBuilder() -> MessageBuilder {
    return Meeting.Builder()
  }
  public override func classBuilder() -> MessageBuilder {
    return Meeting.Builder()
  }
  public func toBuilder() throws -> Meeting.Builder {
    return try Meeting.builderWithPrototype(self)
  }
  public class func builderWithPrototype(prototype:Meeting) throws -> Meeting.Builder {
    return try Meeting.Builder().mergeFrom(prototype)
  }
  override public func getDescription(indent:String) throws -> String {
    var output:String = ""
    if hasId {
      output += "\(indent) id: \(id) \n"
    }
    if hasSectionId {
      output += "\(indent) sectionId: \(sectionId) \n"
    }
    if hasRoom {
      output += "\(indent) room: \(room) \n"
    }
    if hasDay {
      output += "\(indent) day: \(day) \n"
    }
    if hasStartTime {
      output += "\(indent) startTime: \(startTime) \n"
    }
    if hasEndTime {
      output += "\(indent) endTime: \(endTime) \n"
    }
    if hasClassType {
      output += "\(indent) classType: \(classType) \n"
    }
    if hasIndex {
      output += "\(indent) index: \(index) \n"
    }
    var metadataElementIndex:Int = 0
    for oneElementmetadata in metadata {
        output += "\(indent) metadata[\(metadataElementIndex)] {\n"
        output += try oneElementmetadata.getDescription("\(indent)  ")
        output += "\(indent)}\n"
        metadataElementIndex += 1
    }
    output += unknownFields.getDescription(indent)
    return output
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasId {
             hashCode = (hashCode &* 31) &+ id.hashValue
          }
          if hasSectionId {
             hashCode = (hashCode &* 31) &+ sectionId.hashValue
          }
          if hasRoom {
             hashCode = (hashCode &* 31) &+ room.hashValue
          }
          if hasDay {
             hashCode = (hashCode &* 31) &+ day.hashValue
          }
          if hasStartTime {
             hashCode = (hashCode &* 31) &+ startTime.hashValue
          }
          if hasEndTime {
             hashCode = (hashCode &* 31) &+ endTime.hashValue
          }
          if hasClassType {
             hashCode = (hashCode &* 31) &+ classType.hashValue
          }
          if hasIndex {
             hashCode = (hashCode &* 31) &+ index.hashValue
          }
          for oneElementmetadata in metadata {
              hashCode = (hashCode &* 31) &+ oneElementmetadata.hashValue
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "Meeting"
  }
  override public func className() -> String {
      return "Meeting"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return Meeting.self
  }
  //Meta information declaration end

  final public class Builder : GeneratedMessageBuilder {
    private var builderResult:Meeting = Meeting()
    public func getMessage() -> Meeting {
        return builderResult
    }

    required override public init () {
       super.init()
    }
    public var hasId:Bool {
         get {
              return builderResult.hasId
         }
    }
    public var id:Int64 {
         get {
              return builderResult.id
         }
         set (value) {
             builderResult.hasId = true
             builderResult.id = value
         }
    }
    public func setId(value:Int64) -> Meeting.Builder {
      self.id = value
      return self
    }
    public func clearId() -> Meeting.Builder{
         builderResult.hasId = false
         builderResult.id = Int64(0)
         return self
    }
    public var hasSectionId:Bool {
         get {
              return builderResult.hasSectionId
         }
    }
    public var sectionId:Int64 {
         get {
              return builderResult.sectionId
         }
         set (value) {
             builderResult.hasSectionId = true
             builderResult.sectionId = value
         }
    }
    public func setSectionId(value:Int64) -> Meeting.Builder {
      self.sectionId = value
      return self
    }
    public func clearSectionId() -> Meeting.Builder{
         builderResult.hasSectionId = false
         builderResult.sectionId = Int64(0)
         return self
    }
    public var hasRoom:Bool {
         get {
              return builderResult.hasRoom
         }
    }
    public var room:String {
         get {
              return builderResult.room
         }
         set (value) {
             builderResult.hasRoom = true
             builderResult.room = value
         }
    }
    public func setRoom(value:String) -> Meeting.Builder {
      self.room = value
      return self
    }
    public func clearRoom() -> Meeting.Builder{
         builderResult.hasRoom = false
         builderResult.room = ""
         return self
    }
    public var hasDay:Bool {
         get {
              return builderResult.hasDay
         }
    }
    public var day:String {
         get {
              return builderResult.day
         }
         set (value) {
             builderResult.hasDay = true
             builderResult.day = value
         }
    }
    public func setDay(value:String) -> Meeting.Builder {
      self.day = value
      return self
    }
    public func clearDay() -> Meeting.Builder{
         builderResult.hasDay = false
         builderResult.day = ""
         return self
    }
    public var hasStartTime:Bool {
         get {
              return builderResult.hasStartTime
         }
    }
    public var startTime:String {
         get {
              return builderResult.startTime
         }
         set (value) {
             builderResult.hasStartTime = true
             builderResult.startTime = value
         }
    }
    public func setStartTime(value:String) -> Meeting.Builder {
      self.startTime = value
      return self
    }
    public func clearStartTime() -> Meeting.Builder{
         builderResult.hasStartTime = false
         builderResult.startTime = ""
         return self
    }
    public var hasEndTime:Bool {
         get {
              return builderResult.hasEndTime
         }
    }
    public var endTime:String {
         get {
              return builderResult.endTime
         }
         set (value) {
             builderResult.hasEndTime = true
             builderResult.endTime = value
         }
    }
    public func setEndTime(value:String) -> Meeting.Builder {
      self.endTime = value
      return self
    }
    public func clearEndTime() -> Meeting.Builder{
         builderResult.hasEndTime = false
         builderResult.endTime = ""
         return self
    }
    public var hasClassType:Bool {
         get {
              return builderResult.hasClassType
         }
    }
    public var classType:String {
         get {
              return builderResult.classType
         }
         set (value) {
             builderResult.hasClassType = true
             builderResult.classType = value
         }
    }
    public func setClassType(value:String) -> Meeting.Builder {
      self.classType = value
      return self
    }
    public func clearClassType() -> Meeting.Builder{
         builderResult.hasClassType = false
         builderResult.classType = ""
         return self
    }
    public var hasIndex:Bool {
         get {
              return builderResult.hasIndex
         }
    }
    public var index:Int32 {
         get {
              return builderResult.index
         }
         set (value) {
             builderResult.hasIndex = true
             builderResult.index = value
         }
    }
    public func setIndex(value:Int32) -> Meeting.Builder {
      self.index = value
      return self
    }
    public func clearIndex() -> Meeting.Builder{
         builderResult.hasIndex = false
         builderResult.index = Int32(0)
         return self
    }
    public var metadata:Array<Metadata> {
         get {
             return builderResult.metadata
         }
         set (value) {
             builderResult.metadata = value
         }
    }
    public func setMetadata(value:Array<Metadata>) -> Meeting.Builder {
      self.metadata = value
      return self
    }
    public func clearMetadata() -> Meeting.Builder {
      builderResult.metadata.removeAll(keepCapacity: false)
      return self
    }
    override public var internalGetResult:GeneratedMessage {
         get {
            return builderResult
         }
    }
    public override func clear() -> Meeting.Builder {
      builderResult = Meeting()
      return self
    }
    public override func clone() throws -> Meeting.Builder {
      return try Meeting.builderWithPrototype(builderResult)
    }
    public override func build() throws -> Meeting {
         try checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> Meeting {
      let returnMe:Meeting = builderResult
      return returnMe
    }
    public func mergeFrom(other:Meeting) throws -> Meeting.Builder {
      if other == Meeting() {
       return self
      }
      if other.hasId {
           id = other.id
      }
      if other.hasSectionId {
           sectionId = other.sectionId
      }
      if other.hasRoom {
           room = other.room
      }
      if other.hasDay {
           day = other.day
      }
      if other.hasStartTime {
           startTime = other.startTime
      }
      if other.hasEndTime {
           endTime = other.endTime
      }
      if other.hasClassType {
           classType = other.classType
      }
      if other.hasIndex {
           index = other.index
      }
      if !other.metadata.isEmpty  {
         builderResult.metadata += other.metadata
      }
      try mergeUnknownFields(other.unknownFields)
      return self
    }
    public override func mergeFromCodedInputStream(input:CodedInputStream) throws -> Meeting.Builder {
         return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
    }
    public override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Meeting.Builder {
      let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
      while (true) {
        let protobufTag = try input.readTag()
        switch protobufTag {
        case 0: 
          self.unknownFields = try unknownFieldsBuilder.build()
          return self

        case 8 :
          id = try input.readInt64()

        case 16 :
          sectionId = try input.readInt64()

        case 26 :
          room = try input.readString()

        case 34 :
          day = try input.readString()

        case 42 :
          startTime = try input.readString()

        case 50 :
          endTime = try input.readString()

        case 58 :
          classType = try input.readString()

        case 64 :
          index = try input.readInt32()

        case 74 :
          let subBuilder = Metadata.Builder()
          try input.readMessage(subBuilder,extensionRegistry:extensionRegistry)
          metadata += [subBuilder.buildPartial()]

        default:
          if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
             unknownFields = try unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
  }

}

final public class Instructor : GeneratedMessage, GeneratedMessageProtocol {
  public private(set) var id:Int64 = Int64(0)

  public private(set) var hasId:Bool = false
  public private(set) var sectionId:Int64 = Int64(0)

  public private(set) var hasSectionId:Bool = false
  public private(set) var name:String = ""

  public private(set) var hasName:Bool = false
  public private(set) var index:Int32 = Int32(0)

  public private(set) var hasIndex:Bool = false
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
   return true
  }
  override public func writeToCodedOutputStream(output:CodedOutputStream) throws {
    if hasId {
      try output.writeInt64(1, value:id)
    }
    if hasSectionId {
      try output.writeInt64(2, value:sectionId)
    }
    if hasName {
      try output.writeString(3, value:name)
    }
    if hasIndex {
      try output.writeInt32(4, value:index)
    }
    try unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var serialize_size:Int32 = memoizedSerializedSize
    if serialize_size != -1 {
     return serialize_size
    }

    serialize_size = 0
    if hasId {
      serialize_size += id.computeInt64Size(1)
    }
    if hasSectionId {
      serialize_size += sectionId.computeInt64Size(2)
    }
    if hasName {
      serialize_size += name.computeStringSize(3)
    }
    if hasIndex {
      serialize_size += index.computeInt32Size(4)
    }
    serialize_size += unknownFields.serializedSize()
    memoizedSerializedSize = serialize_size
    return serialize_size
  }
  public class func parseArrayDelimitedFromInputStream(input:NSInputStream) throws -> Array<Instructor> {
    var mergedArray = Array<Instructor>()
    while let value = try parseFromDelimitedFromInputStream(input) {
      mergedArray += [value]
    }
    return mergedArray
  }
  public class func parseFromDelimitedFromInputStream(input:NSInputStream) throws -> Instructor? {
    return try Instructor.Builder().mergeDelimitedFromInputStream(input)?.build()
  }
  public class func parseFromData(data:NSData) throws -> Instructor {
    return try Instructor.Builder().mergeFromData(data, extensionRegistry:ModelRoot.sharedInstance.extensionRegistry).build()
  }
  public class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) throws -> Instructor {
    return try Instructor.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromInputStream(input:NSInputStream) throws -> Instructor {
    return try Instructor.Builder().mergeFromInputStream(input).build()
  }
  public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> Instructor {
    return try Instructor.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromCodedInputStream(input:CodedInputStream) throws -> Instructor {
    return try Instructor.Builder().mergeFromCodedInputStream(input).build()
  }
  public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Instructor {
    return try Instructor.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func getBuilder() -> Instructor.Builder {
    return Instructor.classBuilder() as! Instructor.Builder
  }
  public func getBuilder() -> Instructor.Builder {
    return classBuilder() as! Instructor.Builder
  }
  public override class func classBuilder() -> MessageBuilder {
    return Instructor.Builder()
  }
  public override func classBuilder() -> MessageBuilder {
    return Instructor.Builder()
  }
  public func toBuilder() throws -> Instructor.Builder {
    return try Instructor.builderWithPrototype(self)
  }
  public class func builderWithPrototype(prototype:Instructor) throws -> Instructor.Builder {
    return try Instructor.Builder().mergeFrom(prototype)
  }
  override public func getDescription(indent:String) throws -> String {
    var output:String = ""
    if hasId {
      output += "\(indent) id: \(id) \n"
    }
    if hasSectionId {
      output += "\(indent) sectionId: \(sectionId) \n"
    }
    if hasName {
      output += "\(indent) name: \(name) \n"
    }
    if hasIndex {
      output += "\(indent) index: \(index) \n"
    }
    output += unknownFields.getDescription(indent)
    return output
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasId {
             hashCode = (hashCode &* 31) &+ id.hashValue
          }
          if hasSectionId {
             hashCode = (hashCode &* 31) &+ sectionId.hashValue
          }
          if hasName {
             hashCode = (hashCode &* 31) &+ name.hashValue
          }
          if hasIndex {
             hashCode = (hashCode &* 31) &+ index.hashValue
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "Instructor"
  }
  override public func className() -> String {
      return "Instructor"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return Instructor.self
  }
  //Meta information declaration end

  final public class Builder : GeneratedMessageBuilder {
    private var builderResult:Instructor = Instructor()
    public func getMessage() -> Instructor {
        return builderResult
    }

    required override public init () {
       super.init()
    }
    public var hasId:Bool {
         get {
              return builderResult.hasId
         }
    }
    public var id:Int64 {
         get {
              return builderResult.id
         }
         set (value) {
             builderResult.hasId = true
             builderResult.id = value
         }
    }
    public func setId(value:Int64) -> Instructor.Builder {
      self.id = value
      return self
    }
    public func clearId() -> Instructor.Builder{
         builderResult.hasId = false
         builderResult.id = Int64(0)
         return self
    }
    public var hasSectionId:Bool {
         get {
              return builderResult.hasSectionId
         }
    }
    public var sectionId:Int64 {
         get {
              return builderResult.sectionId
         }
         set (value) {
             builderResult.hasSectionId = true
             builderResult.sectionId = value
         }
    }
    public func setSectionId(value:Int64) -> Instructor.Builder {
      self.sectionId = value
      return self
    }
    public func clearSectionId() -> Instructor.Builder{
         builderResult.hasSectionId = false
         builderResult.sectionId = Int64(0)
         return self
    }
    public var hasName:Bool {
         get {
              return builderResult.hasName
         }
    }
    public var name:String {
         get {
              return builderResult.name
         }
         set (value) {
             builderResult.hasName = true
             builderResult.name = value
         }
    }
    public func setName(value:String) -> Instructor.Builder {
      self.name = value
      return self
    }
    public func clearName() -> Instructor.Builder{
         builderResult.hasName = false
         builderResult.name = ""
         return self
    }
    public var hasIndex:Bool {
         get {
              return builderResult.hasIndex
         }
    }
    public var index:Int32 {
         get {
              return builderResult.index
         }
         set (value) {
             builderResult.hasIndex = true
             builderResult.index = value
         }
    }
    public func setIndex(value:Int32) -> Instructor.Builder {
      self.index = value
      return self
    }
    public func clearIndex() -> Instructor.Builder{
         builderResult.hasIndex = false
         builderResult.index = Int32(0)
         return self
    }
    override public var internalGetResult:GeneratedMessage {
         get {
            return builderResult
         }
    }
    public override func clear() -> Instructor.Builder {
      builderResult = Instructor()
      return self
    }
    public override func clone() throws -> Instructor.Builder {
      return try Instructor.builderWithPrototype(builderResult)
    }
    public override func build() throws -> Instructor {
         try checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> Instructor {
      let returnMe:Instructor = builderResult
      return returnMe
    }
    public func mergeFrom(other:Instructor) throws -> Instructor.Builder {
      if other == Instructor() {
       return self
      }
      if other.hasId {
           id = other.id
      }
      if other.hasSectionId {
           sectionId = other.sectionId
      }
      if other.hasName {
           name = other.name
      }
      if other.hasIndex {
           index = other.index
      }
      try mergeUnknownFields(other.unknownFields)
      return self
    }
    public override func mergeFromCodedInputStream(input:CodedInputStream) throws -> Instructor.Builder {
         return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
    }
    public override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Instructor.Builder {
      let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
      while (true) {
        let protobufTag = try input.readTag()
        switch protobufTag {
        case 0: 
          self.unknownFields = try unknownFieldsBuilder.build()
          return self

        case 8 :
          id = try input.readInt64()

        case 16 :
          sectionId = try input.readInt64()

        case 26 :
          name = try input.readString()

        case 32 :
          index = try input.readInt32()

        default:
          if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
             unknownFields = try unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
  }

}

final public class Book : GeneratedMessage, GeneratedMessageProtocol {
  public private(set) var id:Int64 = Int64(0)

  public private(set) var hasId:Bool = false
  public private(set) var sectionId:Int64 = Int64(0)

  public private(set) var hasSectionId:Bool = false
  public private(set) var title:String = ""

  public private(set) var hasTitle:Bool = false
  public private(set) var url:String = ""

  public private(set) var hasUrl:Bool = false
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
   return true
  }
  override public func writeToCodedOutputStream(output:CodedOutputStream) throws {
    if hasId {
      try output.writeInt64(1, value:id)
    }
    if hasSectionId {
      try output.writeInt64(2, value:sectionId)
    }
    if hasTitle {
      try output.writeString(3, value:title)
    }
    if hasUrl {
      try output.writeString(4, value:url)
    }
    try unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var serialize_size:Int32 = memoizedSerializedSize
    if serialize_size != -1 {
     return serialize_size
    }

    serialize_size = 0
    if hasId {
      serialize_size += id.computeInt64Size(1)
    }
    if hasSectionId {
      serialize_size += sectionId.computeInt64Size(2)
    }
    if hasTitle {
      serialize_size += title.computeStringSize(3)
    }
    if hasUrl {
      serialize_size += url.computeStringSize(4)
    }
    serialize_size += unknownFields.serializedSize()
    memoizedSerializedSize = serialize_size
    return serialize_size
  }
  public class func parseArrayDelimitedFromInputStream(input:NSInputStream) throws -> Array<Book> {
    var mergedArray = Array<Book>()
    while let value = try parseFromDelimitedFromInputStream(input) {
      mergedArray += [value]
    }
    return mergedArray
  }
  public class func parseFromDelimitedFromInputStream(input:NSInputStream) throws -> Book? {
    return try Book.Builder().mergeDelimitedFromInputStream(input)?.build()
  }
  public class func parseFromData(data:NSData) throws -> Book {
    return try Book.Builder().mergeFromData(data, extensionRegistry:ModelRoot.sharedInstance.extensionRegistry).build()
  }
  public class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) throws -> Book {
    return try Book.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromInputStream(input:NSInputStream) throws -> Book {
    return try Book.Builder().mergeFromInputStream(input).build()
  }
  public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> Book {
    return try Book.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromCodedInputStream(input:CodedInputStream) throws -> Book {
    return try Book.Builder().mergeFromCodedInputStream(input).build()
  }
  public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Book {
    return try Book.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func getBuilder() -> Book.Builder {
    return Book.classBuilder() as! Book.Builder
  }
  public func getBuilder() -> Book.Builder {
    return classBuilder() as! Book.Builder
  }
  public override class func classBuilder() -> MessageBuilder {
    return Book.Builder()
  }
  public override func classBuilder() -> MessageBuilder {
    return Book.Builder()
  }
  public func toBuilder() throws -> Book.Builder {
    return try Book.builderWithPrototype(self)
  }
  public class func builderWithPrototype(prototype:Book) throws -> Book.Builder {
    return try Book.Builder().mergeFrom(prototype)
  }
  override public func getDescription(indent:String) throws -> String {
    var output:String = ""
    if hasId {
      output += "\(indent) id: \(id) \n"
    }
    if hasSectionId {
      output += "\(indent) sectionId: \(sectionId) \n"
    }
    if hasTitle {
      output += "\(indent) title: \(title) \n"
    }
    if hasUrl {
      output += "\(indent) url: \(url) \n"
    }
    output += unknownFields.getDescription(indent)
    return output
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasId {
             hashCode = (hashCode &* 31) &+ id.hashValue
          }
          if hasSectionId {
             hashCode = (hashCode &* 31) &+ sectionId.hashValue
          }
          if hasTitle {
             hashCode = (hashCode &* 31) &+ title.hashValue
          }
          if hasUrl {
             hashCode = (hashCode &* 31) &+ url.hashValue
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "Book"
  }
  override public func className() -> String {
      return "Book"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return Book.self
  }
  //Meta information declaration end

  final public class Builder : GeneratedMessageBuilder {
    private var builderResult:Book = Book()
    public func getMessage() -> Book {
        return builderResult
    }

    required override public init () {
       super.init()
    }
    public var hasId:Bool {
         get {
              return builderResult.hasId
         }
    }
    public var id:Int64 {
         get {
              return builderResult.id
         }
         set (value) {
             builderResult.hasId = true
             builderResult.id = value
         }
    }
    public func setId(value:Int64) -> Book.Builder {
      self.id = value
      return self
    }
    public func clearId() -> Book.Builder{
         builderResult.hasId = false
         builderResult.id = Int64(0)
         return self
    }
    public var hasSectionId:Bool {
         get {
              return builderResult.hasSectionId
         }
    }
    public var sectionId:Int64 {
         get {
              return builderResult.sectionId
         }
         set (value) {
             builderResult.hasSectionId = true
             builderResult.sectionId = value
         }
    }
    public func setSectionId(value:Int64) -> Book.Builder {
      self.sectionId = value
      return self
    }
    public func clearSectionId() -> Book.Builder{
         builderResult.hasSectionId = false
         builderResult.sectionId = Int64(0)
         return self
    }
    public var hasTitle:Bool {
         get {
              return builderResult.hasTitle
         }
    }
    public var title:String {
         get {
              return builderResult.title
         }
         set (value) {
             builderResult.hasTitle = true
             builderResult.title = value
         }
    }
    public func setTitle(value:String) -> Book.Builder {
      self.title = value
      return self
    }
    public func clearTitle() -> Book.Builder{
         builderResult.hasTitle = false
         builderResult.title = ""
         return self
    }
    public var hasUrl:Bool {
         get {
              return builderResult.hasUrl
         }
    }
    public var url:String {
         get {
              return builderResult.url
         }
         set (value) {
             builderResult.hasUrl = true
             builderResult.url = value
         }
    }
    public func setUrl(value:String) -> Book.Builder {
      self.url = value
      return self
    }
    public func clearUrl() -> Book.Builder{
         builderResult.hasUrl = false
         builderResult.url = ""
         return self
    }
    override public var internalGetResult:GeneratedMessage {
         get {
            return builderResult
         }
    }
    public override func clear() -> Book.Builder {
      builderResult = Book()
      return self
    }
    public override func clone() throws -> Book.Builder {
      return try Book.builderWithPrototype(builderResult)
    }
    public override func build() throws -> Book {
         try checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> Book {
      let returnMe:Book = builderResult
      return returnMe
    }
    public func mergeFrom(other:Book) throws -> Book.Builder {
      if other == Book() {
       return self
      }
      if other.hasId {
           id = other.id
      }
      if other.hasSectionId {
           sectionId = other.sectionId
      }
      if other.hasTitle {
           title = other.title
      }
      if other.hasUrl {
           url = other.url
      }
      try mergeUnknownFields(other.unknownFields)
      return self
    }
    public override func mergeFromCodedInputStream(input:CodedInputStream) throws -> Book.Builder {
         return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
    }
    public override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Book.Builder {
      let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
      while (true) {
        let protobufTag = try input.readTag()
        switch protobufTag {
        case 0: 
          self.unknownFields = try unknownFieldsBuilder.build()
          return self

        case 8 :
          id = try input.readInt64()

        case 16 :
          sectionId = try input.readInt64()

        case 26 :
          title = try input.readString()

        case 34 :
          url = try input.readString()

        default:
          if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
             unknownFields = try unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
  }

}

final public class Metadata : GeneratedMessage, GeneratedMessageProtocol {
  public private(set) var id:Int64 = Int64(0)

  public private(set) var hasId:Bool = false
  public private(set) var universityId:Int64 = Int64(0)

  public private(set) var hasUniversityId:Bool = false
  public private(set) var subjectId:Int64 = Int64(0)

  public private(set) var hasSubjectId:Bool = false
  public private(set) var courseId:Int64 = Int64(0)

  public private(set) var hasCourseId:Bool = false
  public private(set) var sectionId:Int64 = Int64(0)

  public private(set) var hasSectionId:Bool = false
  public private(set) var meetingId:Int64 = Int64(0)

  public private(set) var hasMeetingId:Bool = false
  public private(set) var title:String = ""

  public private(set) var hasTitle:Bool = false
  public private(set) var content:String = ""

  public private(set) var hasContent:Bool = false
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
   return true
  }
  override public func writeToCodedOutputStream(output:CodedOutputStream) throws {
    if hasId {
      try output.writeInt64(1, value:id)
    }
    if hasUniversityId {
      try output.writeInt64(2, value:universityId)
    }
    if hasSubjectId {
      try output.writeInt64(3, value:subjectId)
    }
    if hasCourseId {
      try output.writeInt64(4, value:courseId)
    }
    if hasSectionId {
      try output.writeInt64(5, value:sectionId)
    }
    if hasMeetingId {
      try output.writeInt64(6, value:meetingId)
    }
    if hasTitle {
      try output.writeString(7, value:title)
    }
    if hasContent {
      try output.writeString(8, value:content)
    }
    try unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var serialize_size:Int32 = memoizedSerializedSize
    if serialize_size != -1 {
     return serialize_size
    }

    serialize_size = 0
    if hasId {
      serialize_size += id.computeInt64Size(1)
    }
    if hasUniversityId {
      serialize_size += universityId.computeInt64Size(2)
    }
    if hasSubjectId {
      serialize_size += subjectId.computeInt64Size(3)
    }
    if hasCourseId {
      serialize_size += courseId.computeInt64Size(4)
    }
    if hasSectionId {
      serialize_size += sectionId.computeInt64Size(5)
    }
    if hasMeetingId {
      serialize_size += meetingId.computeInt64Size(6)
    }
    if hasTitle {
      serialize_size += title.computeStringSize(7)
    }
    if hasContent {
      serialize_size += content.computeStringSize(8)
    }
    serialize_size += unknownFields.serializedSize()
    memoizedSerializedSize = serialize_size
    return serialize_size
  }
  public class func parseArrayDelimitedFromInputStream(input:NSInputStream) throws -> Array<Metadata> {
    var mergedArray = Array<Metadata>()
    while let value = try parseFromDelimitedFromInputStream(input) {
      mergedArray += [value]
    }
    return mergedArray
  }
  public class func parseFromDelimitedFromInputStream(input:NSInputStream) throws -> Metadata? {
    return try Metadata.Builder().mergeDelimitedFromInputStream(input)?.build()
  }
  public class func parseFromData(data:NSData) throws -> Metadata {
    return try Metadata.Builder().mergeFromData(data, extensionRegistry:ModelRoot.sharedInstance.extensionRegistry).build()
  }
  public class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) throws -> Metadata {
    return try Metadata.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromInputStream(input:NSInputStream) throws -> Metadata {
    return try Metadata.Builder().mergeFromInputStream(input).build()
  }
  public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> Metadata {
    return try Metadata.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromCodedInputStream(input:CodedInputStream) throws -> Metadata {
    return try Metadata.Builder().mergeFromCodedInputStream(input).build()
  }
  public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Metadata {
    return try Metadata.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func getBuilder() -> Metadata.Builder {
    return Metadata.classBuilder() as! Metadata.Builder
  }
  public func getBuilder() -> Metadata.Builder {
    return classBuilder() as! Metadata.Builder
  }
  public override class func classBuilder() -> MessageBuilder {
    return Metadata.Builder()
  }
  public override func classBuilder() -> MessageBuilder {
    return Metadata.Builder()
  }
  public func toBuilder() throws -> Metadata.Builder {
    return try Metadata.builderWithPrototype(self)
  }
  public class func builderWithPrototype(prototype:Metadata) throws -> Metadata.Builder {
    return try Metadata.Builder().mergeFrom(prototype)
  }
  override public func getDescription(indent:String) throws -> String {
    var output:String = ""
    if hasId {
      output += "\(indent) id: \(id) \n"
    }
    if hasUniversityId {
      output += "\(indent) universityId: \(universityId) \n"
    }
    if hasSubjectId {
      output += "\(indent) subjectId: \(subjectId) \n"
    }
    if hasCourseId {
      output += "\(indent) courseId: \(courseId) \n"
    }
    if hasSectionId {
      output += "\(indent) sectionId: \(sectionId) \n"
    }
    if hasMeetingId {
      output += "\(indent) meetingId: \(meetingId) \n"
    }
    if hasTitle {
      output += "\(indent) title: \(title) \n"
    }
    if hasContent {
      output += "\(indent) content: \(content) \n"
    }
    output += unknownFields.getDescription(indent)
    return output
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasId {
             hashCode = (hashCode &* 31) &+ id.hashValue
          }
          if hasUniversityId {
             hashCode = (hashCode &* 31) &+ universityId.hashValue
          }
          if hasSubjectId {
             hashCode = (hashCode &* 31) &+ subjectId.hashValue
          }
          if hasCourseId {
             hashCode = (hashCode &* 31) &+ courseId.hashValue
          }
          if hasSectionId {
             hashCode = (hashCode &* 31) &+ sectionId.hashValue
          }
          if hasMeetingId {
             hashCode = (hashCode &* 31) &+ meetingId.hashValue
          }
          if hasTitle {
             hashCode = (hashCode &* 31) &+ title.hashValue
          }
          if hasContent {
             hashCode = (hashCode &* 31) &+ content.hashValue
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "Metadata"
  }
  override public func className() -> String {
      return "Metadata"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return Metadata.self
  }
  //Meta information declaration end

  final public class Builder : GeneratedMessageBuilder {
    private var builderResult:Metadata = Metadata()
    public func getMessage() -> Metadata {
        return builderResult
    }

    required override public init () {
       super.init()
    }
    public var hasId:Bool {
         get {
              return builderResult.hasId
         }
    }
    public var id:Int64 {
         get {
              return builderResult.id
         }
         set (value) {
             builderResult.hasId = true
             builderResult.id = value
         }
    }
    public func setId(value:Int64) -> Metadata.Builder {
      self.id = value
      return self
    }
    public func clearId() -> Metadata.Builder{
         builderResult.hasId = false
         builderResult.id = Int64(0)
         return self
    }
    public var hasUniversityId:Bool {
         get {
              return builderResult.hasUniversityId
         }
    }
    public var universityId:Int64 {
         get {
              return builderResult.universityId
         }
         set (value) {
             builderResult.hasUniversityId = true
             builderResult.universityId = value
         }
    }
    public func setUniversityId(value:Int64) -> Metadata.Builder {
      self.universityId = value
      return self
    }
    public func clearUniversityId() -> Metadata.Builder{
         builderResult.hasUniversityId = false
         builderResult.universityId = Int64(0)
         return self
    }
    public var hasSubjectId:Bool {
         get {
              return builderResult.hasSubjectId
         }
    }
    public var subjectId:Int64 {
         get {
              return builderResult.subjectId
         }
         set (value) {
             builderResult.hasSubjectId = true
             builderResult.subjectId = value
         }
    }
    public func setSubjectId(value:Int64) -> Metadata.Builder {
      self.subjectId = value
      return self
    }
    public func clearSubjectId() -> Metadata.Builder{
         builderResult.hasSubjectId = false
         builderResult.subjectId = Int64(0)
         return self
    }
    public var hasCourseId:Bool {
         get {
              return builderResult.hasCourseId
         }
    }
    public var courseId:Int64 {
         get {
              return builderResult.courseId
         }
         set (value) {
             builderResult.hasCourseId = true
             builderResult.courseId = value
         }
    }
    public func setCourseId(value:Int64) -> Metadata.Builder {
      self.courseId = value
      return self
    }
    public func clearCourseId() -> Metadata.Builder{
         builderResult.hasCourseId = false
         builderResult.courseId = Int64(0)
         return self
    }
    public var hasSectionId:Bool {
         get {
              return builderResult.hasSectionId
         }
    }
    public var sectionId:Int64 {
         get {
              return builderResult.sectionId
         }
         set (value) {
             builderResult.hasSectionId = true
             builderResult.sectionId = value
         }
    }
    public func setSectionId(value:Int64) -> Metadata.Builder {
      self.sectionId = value
      return self
    }
    public func clearSectionId() -> Metadata.Builder{
         builderResult.hasSectionId = false
         builderResult.sectionId = Int64(0)
         return self
    }
    public var hasMeetingId:Bool {
         get {
              return builderResult.hasMeetingId
         }
    }
    public var meetingId:Int64 {
         get {
              return builderResult.meetingId
         }
         set (value) {
             builderResult.hasMeetingId = true
             builderResult.meetingId = value
         }
    }
    public func setMeetingId(value:Int64) -> Metadata.Builder {
      self.meetingId = value
      return self
    }
    public func clearMeetingId() -> Metadata.Builder{
         builderResult.hasMeetingId = false
         builderResult.meetingId = Int64(0)
         return self
    }
    public var hasTitle:Bool {
         get {
              return builderResult.hasTitle
         }
    }
    public var title:String {
         get {
              return builderResult.title
         }
         set (value) {
             builderResult.hasTitle = true
             builderResult.title = value
         }
    }
    public func setTitle(value:String) -> Metadata.Builder {
      self.title = value
      return self
    }
    public func clearTitle() -> Metadata.Builder{
         builderResult.hasTitle = false
         builderResult.title = ""
         return self
    }
    public var hasContent:Bool {
         get {
              return builderResult.hasContent
         }
    }
    public var content:String {
         get {
              return builderResult.content
         }
         set (value) {
             builderResult.hasContent = true
             builderResult.content = value
         }
    }
    public func setContent(value:String) -> Metadata.Builder {
      self.content = value
      return self
    }
    public func clearContent() -> Metadata.Builder{
         builderResult.hasContent = false
         builderResult.content = ""
         return self
    }
    override public var internalGetResult:GeneratedMessage {
         get {
            return builderResult
         }
    }
    public override func clear() -> Metadata.Builder {
      builderResult = Metadata()
      return self
    }
    public override func clone() throws -> Metadata.Builder {
      return try Metadata.builderWithPrototype(builderResult)
    }
    public override func build() throws -> Metadata {
         try checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> Metadata {
      let returnMe:Metadata = builderResult
      return returnMe
    }
    public func mergeFrom(other:Metadata) throws -> Metadata.Builder {
      if other == Metadata() {
       return self
      }
      if other.hasId {
           id = other.id
      }
      if other.hasUniversityId {
           universityId = other.universityId
      }
      if other.hasSubjectId {
           subjectId = other.subjectId
      }
      if other.hasCourseId {
           courseId = other.courseId
      }
      if other.hasSectionId {
           sectionId = other.sectionId
      }
      if other.hasMeetingId {
           meetingId = other.meetingId
      }
      if other.hasTitle {
           title = other.title
      }
      if other.hasContent {
           content = other.content
      }
      try mergeUnknownFields(other.unknownFields)
      return self
    }
    public override func mergeFromCodedInputStream(input:CodedInputStream) throws -> Metadata.Builder {
         return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
    }
    public override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Metadata.Builder {
      let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
      while (true) {
        let protobufTag = try input.readTag()
        switch protobufTag {
        case 0: 
          self.unknownFields = try unknownFieldsBuilder.build()
          return self

        case 8 :
          id = try input.readInt64()

        case 16 :
          universityId = try input.readInt64()

        case 24 :
          subjectId = try input.readInt64()

        case 32 :
          courseId = try input.readInt64()

        case 40 :
          sectionId = try input.readInt64()

        case 48 :
          meetingId = try input.readInt64()

        case 58 :
          title = try input.readString()

        case 66 :
          content = try input.readString()

        default:
          if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
             unknownFields = try unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
  }

}

final public class Registration : GeneratedMessage, GeneratedMessageProtocol {
  public private(set) var id:Int64 = Int64(0)

  public private(set) var hasId:Bool = false
  public private(set) var universityId:Int64 = Int64(0)

  public private(set) var hasUniversityId:Bool = false
  public private(set) var period:String = ""

  public private(set) var hasPeriod:Bool = false
  public private(set) var periodDate:Int64 = Int64(0)

  public private(set) var hasPeriodDate:Bool = false
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
   return true
  }
  override public func writeToCodedOutputStream(output:CodedOutputStream) throws {
    if hasId {
      try output.writeInt64(1, value:id)
    }
    if hasUniversityId {
      try output.writeInt64(2, value:universityId)
    }
    if hasPeriod {
      try output.writeString(3, value:period)
    }
    if hasPeriodDate {
      try output.writeInt64(4, value:periodDate)
    }
    try unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var serialize_size:Int32 = memoizedSerializedSize
    if serialize_size != -1 {
     return serialize_size
    }

    serialize_size = 0
    if hasId {
      serialize_size += id.computeInt64Size(1)
    }
    if hasUniversityId {
      serialize_size += universityId.computeInt64Size(2)
    }
    if hasPeriod {
      serialize_size += period.computeStringSize(3)
    }
    if hasPeriodDate {
      serialize_size += periodDate.computeInt64Size(4)
    }
    serialize_size += unknownFields.serializedSize()
    memoizedSerializedSize = serialize_size
    return serialize_size
  }
  public class func parseArrayDelimitedFromInputStream(input:NSInputStream) throws -> Array<Registration> {
    var mergedArray = Array<Registration>()
    while let value = try parseFromDelimitedFromInputStream(input) {
      mergedArray += [value]
    }
    return mergedArray
  }
  public class func parseFromDelimitedFromInputStream(input:NSInputStream) throws -> Registration? {
    return try Registration.Builder().mergeDelimitedFromInputStream(input)?.build()
  }
  public class func parseFromData(data:NSData) throws -> Registration {
    return try Registration.Builder().mergeFromData(data, extensionRegistry:ModelRoot.sharedInstance.extensionRegistry).build()
  }
  public class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) throws -> Registration {
    return try Registration.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromInputStream(input:NSInputStream) throws -> Registration {
    return try Registration.Builder().mergeFromInputStream(input).build()
  }
  public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> Registration {
    return try Registration.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromCodedInputStream(input:CodedInputStream) throws -> Registration {
    return try Registration.Builder().mergeFromCodedInputStream(input).build()
  }
  public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Registration {
    return try Registration.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func getBuilder() -> Registration.Builder {
    return Registration.classBuilder() as! Registration.Builder
  }
  public func getBuilder() -> Registration.Builder {
    return classBuilder() as! Registration.Builder
  }
  public override class func classBuilder() -> MessageBuilder {
    return Registration.Builder()
  }
  public override func classBuilder() -> MessageBuilder {
    return Registration.Builder()
  }
  public func toBuilder() throws -> Registration.Builder {
    return try Registration.builderWithPrototype(self)
  }
  public class func builderWithPrototype(prototype:Registration) throws -> Registration.Builder {
    return try Registration.Builder().mergeFrom(prototype)
  }
  override public func getDescription(indent:String) throws -> String {
    var output:String = ""
    if hasId {
      output += "\(indent) id: \(id) \n"
    }
    if hasUniversityId {
      output += "\(indent) universityId: \(universityId) \n"
    }
    if hasPeriod {
      output += "\(indent) period: \(period) \n"
    }
    if hasPeriodDate {
      output += "\(indent) periodDate: \(periodDate) \n"
    }
    output += unknownFields.getDescription(indent)
    return output
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasId {
             hashCode = (hashCode &* 31) &+ id.hashValue
          }
          if hasUniversityId {
             hashCode = (hashCode &* 31) &+ universityId.hashValue
          }
          if hasPeriod {
             hashCode = (hashCode &* 31) &+ period.hashValue
          }
          if hasPeriodDate {
             hashCode = (hashCode &* 31) &+ periodDate.hashValue
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "Registration"
  }
  override public func className() -> String {
      return "Registration"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return Registration.self
  }
  //Meta information declaration end

  final public class Builder : GeneratedMessageBuilder {
    private var builderResult:Registration = Registration()
    public func getMessage() -> Registration {
        return builderResult
    }

    required override public init () {
       super.init()
    }
    public var hasId:Bool {
         get {
              return builderResult.hasId
         }
    }
    public var id:Int64 {
         get {
              return builderResult.id
         }
         set (value) {
             builderResult.hasId = true
             builderResult.id = value
         }
    }
    public func setId(value:Int64) -> Registration.Builder {
      self.id = value
      return self
    }
    public func clearId() -> Registration.Builder{
         builderResult.hasId = false
         builderResult.id = Int64(0)
         return self
    }
    public var hasUniversityId:Bool {
         get {
              return builderResult.hasUniversityId
         }
    }
    public var universityId:Int64 {
         get {
              return builderResult.universityId
         }
         set (value) {
             builderResult.hasUniversityId = true
             builderResult.universityId = value
         }
    }
    public func setUniversityId(value:Int64) -> Registration.Builder {
      self.universityId = value
      return self
    }
    public func clearUniversityId() -> Registration.Builder{
         builderResult.hasUniversityId = false
         builderResult.universityId = Int64(0)
         return self
    }
    public var hasPeriod:Bool {
         get {
              return builderResult.hasPeriod
         }
    }
    public var period:String {
         get {
              return builderResult.period
         }
         set (value) {
             builderResult.hasPeriod = true
             builderResult.period = value
         }
    }
    public func setPeriod(value:String) -> Registration.Builder {
      self.period = value
      return self
    }
    public func clearPeriod() -> Registration.Builder{
         builderResult.hasPeriod = false
         builderResult.period = ""
         return self
    }
    public var hasPeriodDate:Bool {
         get {
              return builderResult.hasPeriodDate
         }
    }
    public var periodDate:Int64 {
         get {
              return builderResult.periodDate
         }
         set (value) {
             builderResult.hasPeriodDate = true
             builderResult.periodDate = value
         }
    }
    public func setPeriodDate(value:Int64) -> Registration.Builder {
      self.periodDate = value
      return self
    }
    public func clearPeriodDate() -> Registration.Builder{
         builderResult.hasPeriodDate = false
         builderResult.periodDate = Int64(0)
         return self
    }
    override public var internalGetResult:GeneratedMessage {
         get {
            return builderResult
         }
    }
    public override func clear() -> Registration.Builder {
      builderResult = Registration()
      return self
    }
    public override func clone() throws -> Registration.Builder {
      return try Registration.builderWithPrototype(builderResult)
    }
    public override func build() throws -> Registration {
         try checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> Registration {
      let returnMe:Registration = builderResult
      return returnMe
    }
    public func mergeFrom(other:Registration) throws -> Registration.Builder {
      if other == Registration() {
       return self
      }
      if other.hasId {
           id = other.id
      }
      if other.hasUniversityId {
           universityId = other.universityId
      }
      if other.hasPeriod {
           period = other.period
      }
      if other.hasPeriodDate {
           periodDate = other.periodDate
      }
      try mergeUnknownFields(other.unknownFields)
      return self
    }
    public override func mergeFromCodedInputStream(input:CodedInputStream) throws -> Registration.Builder {
         return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
    }
    public override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Registration.Builder {
      let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
      while (true) {
        let protobufTag = try input.readTag()
        switch protobufTag {
        case 0: 
          self.unknownFields = try unknownFieldsBuilder.build()
          return self

        case 8 :
          id = try input.readInt64()

        case 16 :
          universityId = try input.readInt64()

        case 26 :
          period = try input.readString()

        case 32 :
          periodDate = try input.readInt64()

        default:
          if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
             unknownFields = try unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
  }

}

final public class ResolvedSemester : GeneratedMessage, GeneratedMessageProtocol {
  public private(set) var current:Semester!
  public private(set) var hasCurrent:Bool = false
  public private(set) var last:Semester!
  public private(set) var hasLast:Bool = false
  public private(set) var next:Semester!
  public private(set) var hasNext:Bool = false
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
   return true
  }
  override public func writeToCodedOutputStream(output:CodedOutputStream) throws {
    if hasCurrent {
      try output.writeMessage(1, value:current)
    }
    if hasLast {
      try output.writeMessage(2, value:last)
    }
    if hasNext {
      try output.writeMessage(3, value:next)
    }
    try unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var serialize_size:Int32 = memoizedSerializedSize
    if serialize_size != -1 {
     return serialize_size
    }

    serialize_size = 0
    if hasCurrent {
        if let varSizecurrent = current?.computeMessageSize(1) {
            serialize_size += varSizecurrent
        }
    }
    if hasLast {
        if let varSizelast = last?.computeMessageSize(2) {
            serialize_size += varSizelast
        }
    }
    if hasNext {
        if let varSizenext = next?.computeMessageSize(3) {
            serialize_size += varSizenext
        }
    }
    serialize_size += unknownFields.serializedSize()
    memoizedSerializedSize = serialize_size
    return serialize_size
  }
  public class func parseArrayDelimitedFromInputStream(input:NSInputStream) throws -> Array<ResolvedSemester> {
    var mergedArray = Array<ResolvedSemester>()
    while let value = try parseFromDelimitedFromInputStream(input) {
      mergedArray += [value]
    }
    return mergedArray
  }
  public class func parseFromDelimitedFromInputStream(input:NSInputStream) throws -> ResolvedSemester? {
    return try ResolvedSemester.Builder().mergeDelimitedFromInputStream(input)?.build()
  }
  public class func parseFromData(data:NSData) throws -> ResolvedSemester {
    return try ResolvedSemester.Builder().mergeFromData(data, extensionRegistry:ModelRoot.sharedInstance.extensionRegistry).build()
  }
  public class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) throws -> ResolvedSemester {
    return try ResolvedSemester.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromInputStream(input:NSInputStream) throws -> ResolvedSemester {
    return try ResolvedSemester.Builder().mergeFromInputStream(input).build()
  }
  public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> ResolvedSemester {
    return try ResolvedSemester.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromCodedInputStream(input:CodedInputStream) throws -> ResolvedSemester {
    return try ResolvedSemester.Builder().mergeFromCodedInputStream(input).build()
  }
  public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> ResolvedSemester {
    return try ResolvedSemester.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func getBuilder() -> ResolvedSemester.Builder {
    return ResolvedSemester.classBuilder() as! ResolvedSemester.Builder
  }
  public func getBuilder() -> ResolvedSemester.Builder {
    return classBuilder() as! ResolvedSemester.Builder
  }
  public override class func classBuilder() -> MessageBuilder {
    return ResolvedSemester.Builder()
  }
  public override func classBuilder() -> MessageBuilder {
    return ResolvedSemester.Builder()
  }
  public func toBuilder() throws -> ResolvedSemester.Builder {
    return try ResolvedSemester.builderWithPrototype(self)
  }
  public class func builderWithPrototype(prototype:ResolvedSemester) throws -> ResolvedSemester.Builder {
    return try ResolvedSemester.Builder().mergeFrom(prototype)
  }
  override public func getDescription(indent:String) throws -> String {
    var output:String = ""
    if hasCurrent {
      output += "\(indent) current {\n"
      if let outDescCurrent = current {
        output += try outDescCurrent.getDescription("\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    if hasLast {
      output += "\(indent) last {\n"
      if let outDescLast = last {
        output += try outDescLast.getDescription("\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    if hasNext {
      output += "\(indent) next {\n"
      if let outDescNext = next {
        output += try outDescNext.getDescription("\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    output += unknownFields.getDescription(indent)
    return output
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasCurrent {
              if let hashValuecurrent = current?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValuecurrent
              }
          }
          if hasLast {
              if let hashValuelast = last?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValuelast
              }
          }
          if hasNext {
              if let hashValuenext = next?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValuenext
              }
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "ResolvedSemester"
  }
  override public func className() -> String {
      return "ResolvedSemester"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return ResolvedSemester.self
  }
  //Meta information declaration end

  final public class Builder : GeneratedMessageBuilder {
    private var builderResult:ResolvedSemester = ResolvedSemester()
    public func getMessage() -> ResolvedSemester {
        return builderResult
    }

    required override public init () {
       super.init()
    }
    public var hasCurrent:Bool {
         get {
             return builderResult.hasCurrent
         }
    }
    public var current:Semester! {
         get {
             if currentBuilder_ != nil {
                builderResult.current = currentBuilder_.getMessage()
             }
             return builderResult.current
         }
         set (value) {
             builderResult.hasCurrent = true
             builderResult.current = value
         }
    }
    private var currentBuilder_:Semester.Builder! {
         didSet {
            builderResult.hasCurrent = true
         }
    }
    public func getCurrentBuilder() -> Semester.Builder {
      if currentBuilder_ == nil {
         currentBuilder_ = Semester.Builder()
         builderResult.current = currentBuilder_.getMessage()
         if current != nil {
            try! currentBuilder_.mergeFrom(current)
         }
      }
      return currentBuilder_
    }
    public func setCurrent(value:Semester!) -> ResolvedSemester.Builder {
      self.current = value
      return self
    }
    public func mergeCurrent(value:Semester) throws -> ResolvedSemester.Builder {
      if builderResult.hasCurrent {
        builderResult.current = try Semester.builderWithPrototype(builderResult.current).mergeFrom(value).buildPartial()
      } else {
        builderResult.current = value
      }
      builderResult.hasCurrent = true
      return self
    }
    public func clearCurrent() -> ResolvedSemester.Builder {
      currentBuilder_ = nil
      builderResult.hasCurrent = false
      builderResult.current = nil
      return self
    }
    public var hasLast:Bool {
         get {
             return builderResult.hasLast
         }
    }
    public var last:Semester! {
         get {
             if lastBuilder_ != nil {
                builderResult.last = lastBuilder_.getMessage()
             }
             return builderResult.last
         }
         set (value) {
             builderResult.hasLast = true
             builderResult.last = value
         }
    }
    private var lastBuilder_:Semester.Builder! {
         didSet {
            builderResult.hasLast = true
         }
    }
    public func getLastBuilder() -> Semester.Builder {
      if lastBuilder_ == nil {
         lastBuilder_ = Semester.Builder()
         builderResult.last = lastBuilder_.getMessage()
         if last != nil {
            try! lastBuilder_.mergeFrom(last)
         }
      }
      return lastBuilder_
    }
    public func setLast(value:Semester!) -> ResolvedSemester.Builder {
      self.last = value
      return self
    }
    public func mergeLast(value:Semester) throws -> ResolvedSemester.Builder {
      if builderResult.hasLast {
        builderResult.last = try Semester.builderWithPrototype(builderResult.last).mergeFrom(value).buildPartial()
      } else {
        builderResult.last = value
      }
      builderResult.hasLast = true
      return self
    }
    public func clearLast() -> ResolvedSemester.Builder {
      lastBuilder_ = nil
      builderResult.hasLast = false
      builderResult.last = nil
      return self
    }
    public var hasNext:Bool {
         get {
             return builderResult.hasNext
         }
    }
    public var next:Semester! {
         get {
             if nextBuilder_ != nil {
                builderResult.next = nextBuilder_.getMessage()
             }
             return builderResult.next
         }
         set (value) {
             builderResult.hasNext = true
             builderResult.next = value
         }
    }
    private var nextBuilder_:Semester.Builder! {
         didSet {
            builderResult.hasNext = true
         }
    }
    public func getNextBuilder() -> Semester.Builder {
      if nextBuilder_ == nil {
         nextBuilder_ = Semester.Builder()
         builderResult.next = nextBuilder_.getMessage()
         if next != nil {
            try! nextBuilder_.mergeFrom(next)
         }
      }
      return nextBuilder_
    }
    public func setNext(value:Semester!) -> ResolvedSemester.Builder {
      self.next = value
      return self
    }
    public func mergeNext(value:Semester) throws -> ResolvedSemester.Builder {
      if builderResult.hasNext {
        builderResult.next = try Semester.builderWithPrototype(builderResult.next).mergeFrom(value).buildPartial()
      } else {
        builderResult.next = value
      }
      builderResult.hasNext = true
      return self
    }
    public func clearNext() -> ResolvedSemester.Builder {
      nextBuilder_ = nil
      builderResult.hasNext = false
      builderResult.next = nil
      return self
    }
    override public var internalGetResult:GeneratedMessage {
         get {
            return builderResult
         }
    }
    public override func clear() -> ResolvedSemester.Builder {
      builderResult = ResolvedSemester()
      return self
    }
    public override func clone() throws -> ResolvedSemester.Builder {
      return try ResolvedSemester.builderWithPrototype(builderResult)
    }
    public override func build() throws -> ResolvedSemester {
         try checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> ResolvedSemester {
      let returnMe:ResolvedSemester = builderResult
      return returnMe
    }
    public func mergeFrom(other:ResolvedSemester) throws -> ResolvedSemester.Builder {
      if other == ResolvedSemester() {
       return self
      }
      if (other.hasCurrent) {
          try mergeCurrent(other.current)
      }
      if (other.hasLast) {
          try mergeLast(other.last)
      }
      if (other.hasNext) {
          try mergeNext(other.next)
      }
      try mergeUnknownFields(other.unknownFields)
      return self
    }
    public override func mergeFromCodedInputStream(input:CodedInputStream) throws -> ResolvedSemester.Builder {
         return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
    }
    public override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> ResolvedSemester.Builder {
      let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
      while (true) {
        let protobufTag = try input.readTag()
        switch protobufTag {
        case 0: 
          self.unknownFields = try unknownFieldsBuilder.build()
          return self

        case 10 :
          let subBuilder:Semester.Builder = Semester.Builder()
          if hasCurrent {
            try subBuilder.mergeFrom(current)
          }
          try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
          current = subBuilder.buildPartial()

        case 18 :
          let subBuilder:Semester.Builder = Semester.Builder()
          if hasLast {
            try subBuilder.mergeFrom(last)
          }
          try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
          last = subBuilder.buildPartial()

        case 26 :
          let subBuilder:Semester.Builder = Semester.Builder()
          if hasNext {
            try subBuilder.mergeFrom(next)
          }
          try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
          next = subBuilder.buildPartial()

        default:
          if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
             unknownFields = try unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
  }

}

final public class Semester : GeneratedMessage, GeneratedMessageProtocol {
  public private(set) var year:Int32 = Int32(0)

  public private(set) var hasYear:Bool = false
  public private(set) var season:String = ""

  public private(set) var hasSeason:Bool = false
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
   return true
  }
  override public func writeToCodedOutputStream(output:CodedOutputStream) throws {
    if hasYear {
      try output.writeInt32(1, value:year)
    }
    if hasSeason {
      try output.writeString(2, value:season)
    }
    try unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var serialize_size:Int32 = memoizedSerializedSize
    if serialize_size != -1 {
     return serialize_size
    }

    serialize_size = 0
    if hasYear {
      serialize_size += year.computeInt32Size(1)
    }
    if hasSeason {
      serialize_size += season.computeStringSize(2)
    }
    serialize_size += unknownFields.serializedSize()
    memoizedSerializedSize = serialize_size
    return serialize_size
  }
  public class func parseArrayDelimitedFromInputStream(input:NSInputStream) throws -> Array<Semester> {
    var mergedArray = Array<Semester>()
    while let value = try parseFromDelimitedFromInputStream(input) {
      mergedArray += [value]
    }
    return mergedArray
  }
  public class func parseFromDelimitedFromInputStream(input:NSInputStream) throws -> Semester? {
    return try Semester.Builder().mergeDelimitedFromInputStream(input)?.build()
  }
  public class func parseFromData(data:NSData) throws -> Semester {
    return try Semester.Builder().mergeFromData(data, extensionRegistry:ModelRoot.sharedInstance.extensionRegistry).build()
  }
  public class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) throws -> Semester {
    return try Semester.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromInputStream(input:NSInputStream) throws -> Semester {
    return try Semester.Builder().mergeFromInputStream(input).build()
  }
  public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> Semester {
    return try Semester.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromCodedInputStream(input:CodedInputStream) throws -> Semester {
    return try Semester.Builder().mergeFromCodedInputStream(input).build()
  }
  public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Semester {
    return try Semester.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func getBuilder() -> Semester.Builder {
    return Semester.classBuilder() as! Semester.Builder
  }
  public func getBuilder() -> Semester.Builder {
    return classBuilder() as! Semester.Builder
  }
  public override class func classBuilder() -> MessageBuilder {
    return Semester.Builder()
  }
  public override func classBuilder() -> MessageBuilder {
    return Semester.Builder()
  }
  public func toBuilder() throws -> Semester.Builder {
    return try Semester.builderWithPrototype(self)
  }
  public class func builderWithPrototype(prototype:Semester) throws -> Semester.Builder {
    return try Semester.Builder().mergeFrom(prototype)
  }
  override public func getDescription(indent:String) throws -> String {
    var output:String = ""
    if hasYear {
      output += "\(indent) year: \(year) \n"
    }
    if hasSeason {
      output += "\(indent) season: \(season) \n"
    }
    output += unknownFields.getDescription(indent)
    return output
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasYear {
             hashCode = (hashCode &* 31) &+ year.hashValue
          }
          if hasSeason {
             hashCode = (hashCode &* 31) &+ season.hashValue
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "Semester"
  }
  override public func className() -> String {
      return "Semester"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return Semester.self
  }
  //Meta information declaration end

  final public class Builder : GeneratedMessageBuilder {
    private var builderResult:Semester = Semester()
    public func getMessage() -> Semester {
        return builderResult
    }

    required override public init () {
       super.init()
    }
    public var hasYear:Bool {
         get {
              return builderResult.hasYear
         }
    }
    public var year:Int32 {
         get {
              return builderResult.year
         }
         set (value) {
             builderResult.hasYear = true
             builderResult.year = value
         }
    }
    public func setYear(value:Int32) -> Semester.Builder {
      self.year = value
      return self
    }
    public func clearYear() -> Semester.Builder{
         builderResult.hasYear = false
         builderResult.year = Int32(0)
         return self
    }
    public var hasSeason:Bool {
         get {
              return builderResult.hasSeason
         }
    }
    public var season:String {
         get {
              return builderResult.season
         }
         set (value) {
             builderResult.hasSeason = true
             builderResult.season = value
         }
    }
    public func setSeason(value:String) -> Semester.Builder {
      self.season = value
      return self
    }
    public func clearSeason() -> Semester.Builder{
         builderResult.hasSeason = false
         builderResult.season = ""
         return self
    }
    override public var internalGetResult:GeneratedMessage {
         get {
            return builderResult
         }
    }
    public override func clear() -> Semester.Builder {
      builderResult = Semester()
      return self
    }
    public override func clone() throws -> Semester.Builder {
      return try Semester.builderWithPrototype(builderResult)
    }
    public override func build() throws -> Semester {
         try checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> Semester {
      let returnMe:Semester = builderResult
      return returnMe
    }
    public func mergeFrom(other:Semester) throws -> Semester.Builder {
      if other == Semester() {
       return self
      }
      if other.hasYear {
           year = other.year
      }
      if other.hasSeason {
           season = other.season
      }
      try mergeUnknownFields(other.unknownFields)
      return self
    }
    public override func mergeFromCodedInputStream(input:CodedInputStream) throws -> Semester.Builder {
         return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
    }
    public override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Semester.Builder {
      let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
      while (true) {
        let protobufTag = try input.readTag()
        switch protobufTag {
        case 0: 
          self.unknownFields = try unknownFieldsBuilder.build()
          return self

        case 8 :
          year = try input.readInt32()

        case 18 :
          season = try input.readString()

        default:
          if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
             unknownFields = try unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
  }

}

final public class Uctnotification : GeneratedMessage, GeneratedMessageProtocol {
  public private(set) var notificationId:Int64 = Int64(0)

  public private(set) var hasNotificationId:Bool = false
  public private(set) var topicName:String = ""

  public private(set) var hasTopicName:Bool = false
  public private(set) var status:String = ""

  public private(set) var hasStatus:Bool = false
  public private(set) var university:University!
  public private(set) var hasUniversity:Bool = false
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
   return true
  }
  override public func writeToCodedOutputStream(output:CodedOutputStream) throws {
    if hasNotificationId {
      try output.writeInt64(1, value:notificationId)
    }
    if hasTopicName {
      try output.writeString(2, value:topicName)
    }
    if hasStatus {
      try output.writeString(3, value:status)
    }
    if hasUniversity {
      try output.writeMessage(4, value:university)
    }
    try unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var serialize_size:Int32 = memoizedSerializedSize
    if serialize_size != -1 {
     return serialize_size
    }

    serialize_size = 0
    if hasNotificationId {
      serialize_size += notificationId.computeInt64Size(1)
    }
    if hasTopicName {
      serialize_size += topicName.computeStringSize(2)
    }
    if hasStatus {
      serialize_size += status.computeStringSize(3)
    }
    if hasUniversity {
        if let varSizeuniversity = university?.computeMessageSize(4) {
            serialize_size += varSizeuniversity
        }
    }
    serialize_size += unknownFields.serializedSize()
    memoizedSerializedSize = serialize_size
    return serialize_size
  }
  public class func parseArrayDelimitedFromInputStream(input:NSInputStream) throws -> Array<Uctnotification> {
    var mergedArray = Array<Uctnotification>()
    while let value = try parseFromDelimitedFromInputStream(input) {
      mergedArray += [value]
    }
    return mergedArray
  }
  public class func parseFromDelimitedFromInputStream(input:NSInputStream) throws -> Uctnotification? {
    return try Uctnotification.Builder().mergeDelimitedFromInputStream(input)?.build()
  }
  public class func parseFromData(data:NSData) throws -> Uctnotification {
    return try Uctnotification.Builder().mergeFromData(data, extensionRegistry:ModelRoot.sharedInstance.extensionRegistry).build()
  }
  public class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) throws -> Uctnotification {
    return try Uctnotification.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromInputStream(input:NSInputStream) throws -> Uctnotification {
    return try Uctnotification.Builder().mergeFromInputStream(input).build()
  }
  public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> Uctnotification {
    return try Uctnotification.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromCodedInputStream(input:CodedInputStream) throws -> Uctnotification {
    return try Uctnotification.Builder().mergeFromCodedInputStream(input).build()
  }
  public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Uctnotification {
    return try Uctnotification.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func getBuilder() -> Uctnotification.Builder {
    return Uctnotification.classBuilder() as! Uctnotification.Builder
  }
  public func getBuilder() -> Uctnotification.Builder {
    return classBuilder() as! Uctnotification.Builder
  }
  public override class func classBuilder() -> MessageBuilder {
    return Uctnotification.Builder()
  }
  public override func classBuilder() -> MessageBuilder {
    return Uctnotification.Builder()
  }
  public func toBuilder() throws -> Uctnotification.Builder {
    return try Uctnotification.builderWithPrototype(self)
  }
  public class func builderWithPrototype(prototype:Uctnotification) throws -> Uctnotification.Builder {
    return try Uctnotification.Builder().mergeFrom(prototype)
  }
  override public func getDescription(indent:String) throws -> String {
    var output:String = ""
    if hasNotificationId {
      output += "\(indent) notificationId: \(notificationId) \n"
    }
    if hasTopicName {
      output += "\(indent) topicName: \(topicName) \n"
    }
    if hasStatus {
      output += "\(indent) status: \(status) \n"
    }
    if hasUniversity {
      output += "\(indent) university {\n"
      if let outDescUniversity = university {
        output += try outDescUniversity.getDescription("\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    output += unknownFields.getDescription(indent)
    return output
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasNotificationId {
             hashCode = (hashCode &* 31) &+ notificationId.hashValue
          }
          if hasTopicName {
             hashCode = (hashCode &* 31) &+ topicName.hashValue
          }
          if hasStatus {
             hashCode = (hashCode &* 31) &+ status.hashValue
          }
          if hasUniversity {
              if let hashValueuniversity = university?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValueuniversity
              }
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "Uctnotification"
  }
  override public func className() -> String {
      return "Uctnotification"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return Uctnotification.self
  }
  //Meta information declaration end

  final public class Builder : GeneratedMessageBuilder {
    private var builderResult:Uctnotification = Uctnotification()
    public func getMessage() -> Uctnotification {
        return builderResult
    }

    required override public init () {
       super.init()
    }
    public var hasNotificationId:Bool {
         get {
              return builderResult.hasNotificationId
         }
    }
    public var notificationId:Int64 {
         get {
              return builderResult.notificationId
         }
         set (value) {
             builderResult.hasNotificationId = true
             builderResult.notificationId = value
         }
    }
    public func setNotificationId(value:Int64) -> Uctnotification.Builder {
      self.notificationId = value
      return self
    }
    public func clearNotificationId() -> Uctnotification.Builder{
         builderResult.hasNotificationId = false
         builderResult.notificationId = Int64(0)
         return self
    }
    public var hasTopicName:Bool {
         get {
              return builderResult.hasTopicName
         }
    }
    public var topicName:String {
         get {
              return builderResult.topicName
         }
         set (value) {
             builderResult.hasTopicName = true
             builderResult.topicName = value
         }
    }
    public func setTopicName(value:String) -> Uctnotification.Builder {
      self.topicName = value
      return self
    }
    public func clearTopicName() -> Uctnotification.Builder{
         builderResult.hasTopicName = false
         builderResult.topicName = ""
         return self
    }
    public var hasStatus:Bool {
         get {
              return builderResult.hasStatus
         }
    }
    public var status:String {
         get {
              return builderResult.status
         }
         set (value) {
             builderResult.hasStatus = true
             builderResult.status = value
         }
    }
    public func setStatus(value:String) -> Uctnotification.Builder {
      self.status = value
      return self
    }
    public func clearStatus() -> Uctnotification.Builder{
         builderResult.hasStatus = false
         builderResult.status = ""
         return self
    }
    public var hasUniversity:Bool {
         get {
             return builderResult.hasUniversity
         }
    }
    public var university:University! {
         get {
             if universityBuilder_ != nil {
                builderResult.university = universityBuilder_.getMessage()
             }
             return builderResult.university
         }
         set (value) {
             builderResult.hasUniversity = true
             builderResult.university = value
         }
    }
    private var universityBuilder_:University.Builder! {
         didSet {
            builderResult.hasUniversity = true
         }
    }
    public func getUniversityBuilder() -> University.Builder {
      if universityBuilder_ == nil {
         universityBuilder_ = University.Builder()
         builderResult.university = universityBuilder_.getMessage()
         if university != nil {
            try! universityBuilder_.mergeFrom(university)
         }
      }
      return universityBuilder_
    }
    public func setUniversity(value:University!) -> Uctnotification.Builder {
      self.university = value
      return self
    }
    public func mergeUniversity(value:University) throws -> Uctnotification.Builder {
      if builderResult.hasUniversity {
        builderResult.university = try University.builderWithPrototype(builderResult.university).mergeFrom(value).buildPartial()
      } else {
        builderResult.university = value
      }
      builderResult.hasUniversity = true
      return self
    }
    public func clearUniversity() -> Uctnotification.Builder {
      universityBuilder_ = nil
      builderResult.hasUniversity = false
      builderResult.university = nil
      return self
    }
    override public var internalGetResult:GeneratedMessage {
         get {
            return builderResult
         }
    }
    public override func clear() -> Uctnotification.Builder {
      builderResult = Uctnotification()
      return self
    }
    public override func clone() throws -> Uctnotification.Builder {
      return try Uctnotification.builderWithPrototype(builderResult)
    }
    public override func build() throws -> Uctnotification {
         try checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> Uctnotification {
      let returnMe:Uctnotification = builderResult
      return returnMe
    }
    public func mergeFrom(other:Uctnotification) throws -> Uctnotification.Builder {
      if other == Uctnotification() {
       return self
      }
      if other.hasNotificationId {
           notificationId = other.notificationId
      }
      if other.hasTopicName {
           topicName = other.topicName
      }
      if other.hasStatus {
           status = other.status
      }
      if (other.hasUniversity) {
          try mergeUniversity(other.university)
      }
      try mergeUnknownFields(other.unknownFields)
      return self
    }
    public override func mergeFromCodedInputStream(input:CodedInputStream) throws -> Uctnotification.Builder {
         return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
    }
    public override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Uctnotification.Builder {
      let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
      while (true) {
        let protobufTag = try input.readTag()
        switch protobufTag {
        case 0: 
          self.unknownFields = try unknownFieldsBuilder.build()
          return self

        case 8 :
          notificationId = try input.readInt64()

        case 18 :
          topicName = try input.readString()

        case 26 :
          status = try input.readString()

        case 34 :
          let subBuilder:University.Builder = University.Builder()
          if hasUniversity {
            try subBuilder.mergeFrom(university)
          }
          try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
          university = subBuilder.buildPartial()

        default:
          if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
             unknownFields = try unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
  }

}

final public class Response : GeneratedMessage, GeneratedMessageProtocol {
  public private(set) var meta:Meta!
  public private(set) var hasMeta:Bool = false
  public private(set) var data:Data!
  public private(set) var hasData:Bool = false
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
   return true
  }
  override public func writeToCodedOutputStream(output:CodedOutputStream) throws {
    if hasMeta {
      try output.writeMessage(1, value:meta)
    }
    if hasData {
      try output.writeMessage(2, value:data)
    }
    try unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var serialize_size:Int32 = memoizedSerializedSize
    if serialize_size != -1 {
     return serialize_size
    }

    serialize_size = 0
    if hasMeta {
        if let varSizemeta = meta?.computeMessageSize(1) {
            serialize_size += varSizemeta
        }
    }
    if hasData {
        if let varSizedata = data?.computeMessageSize(2) {
            serialize_size += varSizedata
        }
    }
    serialize_size += unknownFields.serializedSize()
    memoizedSerializedSize = serialize_size
    return serialize_size
  }
  public class func parseArrayDelimitedFromInputStream(input:NSInputStream) throws -> Array<Response> {
    var mergedArray = Array<Response>()
    while let value = try parseFromDelimitedFromInputStream(input) {
      mergedArray += [value]
    }
    return mergedArray
  }
  public class func parseFromDelimitedFromInputStream(input:NSInputStream) throws -> Response? {
    return try Response.Builder().mergeDelimitedFromInputStream(input)?.build()
  }
  public class func parseFromData(data:NSData) throws -> Response {
    return try Response.Builder().mergeFromData(data, extensionRegistry:ModelRoot.sharedInstance.extensionRegistry).build()
  }
  public class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) throws -> Response {
    return try Response.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromInputStream(input:NSInputStream) throws -> Response {
    return try Response.Builder().mergeFromInputStream(input).build()
  }
  public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> Response {
    return try Response.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromCodedInputStream(input:CodedInputStream) throws -> Response {
    return try Response.Builder().mergeFromCodedInputStream(input).build()
  }
  public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Response {
    return try Response.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func getBuilder() -> Response.Builder {
    return Response.classBuilder() as! Response.Builder
  }
  public func getBuilder() -> Response.Builder {
    return classBuilder() as! Response.Builder
  }
  public override class func classBuilder() -> MessageBuilder {
    return Response.Builder()
  }
  public override func classBuilder() -> MessageBuilder {
    return Response.Builder()
  }
  public func toBuilder() throws -> Response.Builder {
    return try Response.builderWithPrototype(self)
  }
  public class func builderWithPrototype(prototype:Response) throws -> Response.Builder {
    return try Response.Builder().mergeFrom(prototype)
  }
  override public func getDescription(indent:String) throws -> String {
    var output:String = ""
    if hasMeta {
      output += "\(indent) meta {\n"
      if let outDescMeta = meta {
        output += try outDescMeta.getDescription("\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    if hasData {
      output += "\(indent) data {\n"
      if let outDescData = data {
        output += try outDescData.getDescription("\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    output += unknownFields.getDescription(indent)
    return output
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasMeta {
              if let hashValuemeta = meta?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValuemeta
              }
          }
          if hasData {
              if let hashValuedata = data?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValuedata
              }
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "Response"
  }
  override public func className() -> String {
      return "Response"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return Response.self
  }
  //Meta information declaration end

  final public class Builder : GeneratedMessageBuilder {
    private var builderResult:Response = Response()
    public func getMessage() -> Response {
        return builderResult
    }

    required override public init () {
       super.init()
    }
    public var hasMeta:Bool {
         get {
             return builderResult.hasMeta
         }
    }
    public var meta:Meta! {
         get {
             if metaBuilder_ != nil {
                builderResult.meta = metaBuilder_.getMessage()
             }
             return builderResult.meta
         }
         set (value) {
             builderResult.hasMeta = true
             builderResult.meta = value
         }
    }
    private var metaBuilder_:Meta.Builder! {
         didSet {
            builderResult.hasMeta = true
         }
    }
    public func getMetaBuilder() -> Meta.Builder {
      if metaBuilder_ == nil {
         metaBuilder_ = Meta.Builder()
         builderResult.meta = metaBuilder_.getMessage()
         if meta != nil {
            try! metaBuilder_.mergeFrom(meta)
         }
      }
      return metaBuilder_
    }
    public func setMeta(value:Meta!) -> Response.Builder {
      self.meta = value
      return self
    }
    public func mergeMeta(value:Meta) throws -> Response.Builder {
      if builderResult.hasMeta {
        builderResult.meta = try Meta.builderWithPrototype(builderResult.meta).mergeFrom(value).buildPartial()
      } else {
        builderResult.meta = value
      }
      builderResult.hasMeta = true
      return self
    }
    public func clearMeta() -> Response.Builder {
      metaBuilder_ = nil
      builderResult.hasMeta = false
      builderResult.meta = nil
      return self
    }
    public var hasData:Bool {
         get {
             return builderResult.hasData
         }
    }
    public var data:Data! {
         get {
             if dataBuilder_ != nil {
                builderResult.data = dataBuilder_.getMessage()
             }
             return builderResult.data
         }
         set (value) {
             builderResult.hasData = true
             builderResult.data = value
         }
    }
    private var dataBuilder_:Data.Builder! {
         didSet {
            builderResult.hasData = true
         }
    }
    public func getDataBuilder() -> Data.Builder {
      if dataBuilder_ == nil {
         dataBuilder_ = Data.Builder()
         builderResult.data = dataBuilder_.getMessage()
         if data != nil {
            try! dataBuilder_.mergeFrom(data)
         }
      }
      return dataBuilder_
    }
    public func setData(value:Data!) -> Response.Builder {
      self.data = value
      return self
    }
    public func mergeData(value:Data) throws -> Response.Builder {
      if builderResult.hasData {
        builderResult.data = try Data.builderWithPrototype(builderResult.data).mergeFrom(value).buildPartial()
      } else {
        builderResult.data = value
      }
      builderResult.hasData = true
      return self
    }
    public func clearData() -> Response.Builder {
      dataBuilder_ = nil
      builderResult.hasData = false
      builderResult.data = nil
      return self
    }
    override public var internalGetResult:GeneratedMessage {
         get {
            return builderResult
         }
    }
    public override func clear() -> Response.Builder {
      builderResult = Response()
      return self
    }
    public override func clone() throws -> Response.Builder {
      return try Response.builderWithPrototype(builderResult)
    }
    public override func build() throws -> Response {
         try checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> Response {
      let returnMe:Response = builderResult
      return returnMe
    }
    public func mergeFrom(other:Response) throws -> Response.Builder {
      if other == Response() {
       return self
      }
      if (other.hasMeta) {
          try mergeMeta(other.meta)
      }
      if (other.hasData) {
          try mergeData(other.data)
      }
      try mergeUnknownFields(other.unknownFields)
      return self
    }
    public override func mergeFromCodedInputStream(input:CodedInputStream) throws -> Response.Builder {
         return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
    }
    public override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Response.Builder {
      let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
      while (true) {
        let protobufTag = try input.readTag()
        switch protobufTag {
        case 0: 
          self.unknownFields = try unknownFieldsBuilder.build()
          return self

        case 10 :
          let subBuilder:Meta.Builder = Meta.Builder()
          if hasMeta {
            try subBuilder.mergeFrom(meta)
          }
          try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
          meta = subBuilder.buildPartial()

        case 18 :
          let subBuilder:Data.Builder = Data.Builder()
          if hasData {
            try subBuilder.mergeFrom(data)
          }
          try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
          data = subBuilder.buildPartial()

        default:
          if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
             unknownFields = try unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
  }

}

final public class Meta : GeneratedMessage, GeneratedMessageProtocol {
  public private(set) var code:Int32 = Int32(0)

  public private(set) var hasCode:Bool = false
  public private(set) var message_:String = ""

  public private(set) var hasMessage_:Bool = false
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
   return true
  }
  override public func writeToCodedOutputStream(output:CodedOutputStream) throws {
    if hasCode {
      try output.writeInt32(1, value:code)
    }
    if hasMessage_ {
      try output.writeString(2, value:message_)
    }
    try unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var serialize_size:Int32 = memoizedSerializedSize
    if serialize_size != -1 {
     return serialize_size
    }

    serialize_size = 0
    if hasCode {
      serialize_size += code.computeInt32Size(1)
    }
    if hasMessage_ {
      serialize_size += message_.computeStringSize(2)
    }
    serialize_size += unknownFields.serializedSize()
    memoizedSerializedSize = serialize_size
    return serialize_size
  }
  public class func parseArrayDelimitedFromInputStream(input:NSInputStream) throws -> Array<Meta> {
    var mergedArray = Array<Meta>()
    while let value = try parseFromDelimitedFromInputStream(input) {
      mergedArray += [value]
    }
    return mergedArray
  }
  public class func parseFromDelimitedFromInputStream(input:NSInputStream) throws -> Meta? {
    return try Meta.Builder().mergeDelimitedFromInputStream(input)?.build()
  }
  public class func parseFromData(data:NSData) throws -> Meta {
    return try Meta.Builder().mergeFromData(data, extensionRegistry:ModelRoot.sharedInstance.extensionRegistry).build()
  }
  public class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) throws -> Meta {
    return try Meta.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromInputStream(input:NSInputStream) throws -> Meta {
    return try Meta.Builder().mergeFromInputStream(input).build()
  }
  public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> Meta {
    return try Meta.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromCodedInputStream(input:CodedInputStream) throws -> Meta {
    return try Meta.Builder().mergeFromCodedInputStream(input).build()
  }
  public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Meta {
    return try Meta.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func getBuilder() -> Meta.Builder {
    return Meta.classBuilder() as! Meta.Builder
  }
  public func getBuilder() -> Meta.Builder {
    return classBuilder() as! Meta.Builder
  }
  public override class func classBuilder() -> MessageBuilder {
    return Meta.Builder()
  }
  public override func classBuilder() -> MessageBuilder {
    return Meta.Builder()
  }
  public func toBuilder() throws -> Meta.Builder {
    return try Meta.builderWithPrototype(self)
  }
  public class func builderWithPrototype(prototype:Meta) throws -> Meta.Builder {
    return try Meta.Builder().mergeFrom(prototype)
  }
  override public func getDescription(indent:String) throws -> String {
    var output:String = ""
    if hasCode {
      output += "\(indent) code: \(code) \n"
    }
    if hasMessage_ {
      output += "\(indent) message_: \(message_) \n"
    }
    output += unknownFields.getDescription(indent)
    return output
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasCode {
             hashCode = (hashCode &* 31) &+ code.hashValue
          }
          if hasMessage_ {
             hashCode = (hashCode &* 31) &+ message_.hashValue
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "Meta"
  }
  override public func className() -> String {
      return "Meta"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return Meta.self
  }
  //Meta information declaration end

  final public class Builder : GeneratedMessageBuilder {
    private var builderResult:Meta = Meta()
    public func getMessage() -> Meta {
        return builderResult
    }

    required override public init () {
       super.init()
    }
    public var hasCode:Bool {
         get {
              return builderResult.hasCode
         }
    }
    public var code:Int32 {
         get {
              return builderResult.code
         }
         set (value) {
             builderResult.hasCode = true
             builderResult.code = value
         }
    }
    public func setCode(value:Int32) -> Meta.Builder {
      self.code = value
      return self
    }
    public func clearCode() -> Meta.Builder{
         builderResult.hasCode = false
         builderResult.code = Int32(0)
         return self
    }
    public var hasMessage_:Bool {
         get {
              return builderResult.hasMessage_
         }
    }
    public var message_:String {
         get {
              return builderResult.message_
         }
         set (value) {
             builderResult.hasMessage_ = true
             builderResult.message_ = value
         }
    }
    public func setMessage_(value:String) -> Meta.Builder {
      self.message_ = value
      return self
    }
    public func clearMessage_() -> Meta.Builder{
         builderResult.hasMessage_ = false
         builderResult.message_ = ""
         return self
    }
    override public var internalGetResult:GeneratedMessage {
         get {
            return builderResult
         }
    }
    public override func clear() -> Meta.Builder {
      builderResult = Meta()
      return self
    }
    public override func clone() throws -> Meta.Builder {
      return try Meta.builderWithPrototype(builderResult)
    }
    public override func build() throws -> Meta {
         try checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> Meta {
      let returnMe:Meta = builderResult
      return returnMe
    }
    public func mergeFrom(other:Meta) throws -> Meta.Builder {
      if other == Meta() {
       return self
      }
      if other.hasCode {
           code = other.code
      }
      if other.hasMessage_ {
           message_ = other.message_
      }
      try mergeUnknownFields(other.unknownFields)
      return self
    }
    public override func mergeFromCodedInputStream(input:CodedInputStream) throws -> Meta.Builder {
         return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
    }
    public override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Meta.Builder {
      let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
      while (true) {
        let protobufTag = try input.readTag()
        switch protobufTag {
        case 0: 
          self.unknownFields = try unknownFieldsBuilder.build()
          return self

        case 8 :
          code = try input.readInt32()

        case 18 :
          message_ = try input.readString()

        default:
          if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
             unknownFields = try unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
  }

}

final public class Data : GeneratedMessage, GeneratedMessageProtocol {
  public private(set) var universities:Array<University>  = Array<University>()
  public private(set) var subjects:Array<Subject>  = Array<Subject>()
  public private(set) var courses:Array<Course>  = Array<Course>()
  public private(set) var sections:Array<Section>  = Array<Section>()
  public private(set) var university:University!
  public private(set) var hasUniversity:Bool = false
  public private(set) var subject:Subject!
  public private(set) var hasSubject:Bool = false
  public private(set) var course:Course!
  public private(set) var hasCourse:Bool = false
  public private(set) var section:Section!
  public private(set) var hasSection:Bool = false
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
   return true
  }
  override public func writeToCodedOutputStream(output:CodedOutputStream) throws {
    for oneElementuniversities in universities {
        try output.writeMessage(1, value:oneElementuniversities)
    }
    for oneElementsubjects in subjects {
        try output.writeMessage(2, value:oneElementsubjects)
    }
    for oneElementcourses in courses {
        try output.writeMessage(3, value:oneElementcourses)
    }
    for oneElementsections in sections {
        try output.writeMessage(4, value:oneElementsections)
    }
    if hasUniversity {
      try output.writeMessage(5, value:university)
    }
    if hasSubject {
      try output.writeMessage(6, value:subject)
    }
    if hasCourse {
      try output.writeMessage(7, value:course)
    }
    if hasSection {
      try output.writeMessage(8, value:section)
    }
    try unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var serialize_size:Int32 = memoizedSerializedSize
    if serialize_size != -1 {
     return serialize_size
    }

    serialize_size = 0
    for oneElementuniversities in universities {
        serialize_size += oneElementuniversities.computeMessageSize(1)
    }
    for oneElementsubjects in subjects {
        serialize_size += oneElementsubjects.computeMessageSize(2)
    }
    for oneElementcourses in courses {
        serialize_size += oneElementcourses.computeMessageSize(3)
    }
    for oneElementsections in sections {
        serialize_size += oneElementsections.computeMessageSize(4)
    }
    if hasUniversity {
        if let varSizeuniversity = university?.computeMessageSize(5) {
            serialize_size += varSizeuniversity
        }
    }
    if hasSubject {
        if let varSizesubject = subject?.computeMessageSize(6) {
            serialize_size += varSizesubject
        }
    }
    if hasCourse {
        if let varSizecourse = course?.computeMessageSize(7) {
            serialize_size += varSizecourse
        }
    }
    if hasSection {
        if let varSizesection = section?.computeMessageSize(8) {
            serialize_size += varSizesection
        }
    }
    serialize_size += unknownFields.serializedSize()
    memoizedSerializedSize = serialize_size
    return serialize_size
  }
  public class func parseArrayDelimitedFromInputStream(input:NSInputStream) throws -> Array<Data> {
    var mergedArray = Array<Data>()
    while let value = try parseFromDelimitedFromInputStream(input) {
      mergedArray += [value]
    }
    return mergedArray
  }
  public class func parseFromDelimitedFromInputStream(input:NSInputStream) throws -> Data? {
    return try Data.Builder().mergeDelimitedFromInputStream(input)?.build()
  }
  public class func parseFromData(data:NSData) throws -> Data {
    return try Data.Builder().mergeFromData(data, extensionRegistry:ModelRoot.sharedInstance.extensionRegistry).build()
  }
  public class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) throws -> Data {
    return try Data.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromInputStream(input:NSInputStream) throws -> Data {
    return try Data.Builder().mergeFromInputStream(input).build()
  }
  public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> Data {
    return try Data.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromCodedInputStream(input:CodedInputStream) throws -> Data {
    return try Data.Builder().mergeFromCodedInputStream(input).build()
  }
  public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Data {
    return try Data.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func getBuilder() -> Data.Builder {
    return Data.classBuilder() as! Data.Builder
  }
  public func getBuilder() -> Data.Builder {
    return classBuilder() as! Data.Builder
  }
  public override class func classBuilder() -> MessageBuilder {
    return Data.Builder()
  }
  public override func classBuilder() -> MessageBuilder {
    return Data.Builder()
  }
  public func toBuilder() throws -> Data.Builder {
    return try Data.builderWithPrototype(self)
  }
  public class func builderWithPrototype(prototype:Data) throws -> Data.Builder {
    return try Data.Builder().mergeFrom(prototype)
  }
  override public func getDescription(indent:String) throws -> String {
    var output:String = ""
    var universitiesElementIndex:Int = 0
    for oneElementuniversities in universities {
        output += "\(indent) universities[\(universitiesElementIndex)] {\n"
        output += try oneElementuniversities.getDescription("\(indent)  ")
        output += "\(indent)}\n"
        universitiesElementIndex += 1
    }
    var subjectsElementIndex:Int = 0
    for oneElementsubjects in subjects {
        output += "\(indent) subjects[\(subjectsElementIndex)] {\n"
        output += try oneElementsubjects.getDescription("\(indent)  ")
        output += "\(indent)}\n"
        subjectsElementIndex += 1
    }
    var coursesElementIndex:Int = 0
    for oneElementcourses in courses {
        output += "\(indent) courses[\(coursesElementIndex)] {\n"
        output += try oneElementcourses.getDescription("\(indent)  ")
        output += "\(indent)}\n"
        coursesElementIndex += 1
    }
    var sectionsElementIndex:Int = 0
    for oneElementsections in sections {
        output += "\(indent) sections[\(sectionsElementIndex)] {\n"
        output += try oneElementsections.getDescription("\(indent)  ")
        output += "\(indent)}\n"
        sectionsElementIndex += 1
    }
    if hasUniversity {
      output += "\(indent) university {\n"
      if let outDescUniversity = university {
        output += try outDescUniversity.getDescription("\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    if hasSubject {
      output += "\(indent) subject {\n"
      if let outDescSubject = subject {
        output += try outDescSubject.getDescription("\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    if hasCourse {
      output += "\(indent) course {\n"
      if let outDescCourse = course {
        output += try outDescCourse.getDescription("\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    if hasSection {
      output += "\(indent) section {\n"
      if let outDescSection = section {
        output += try outDescSection.getDescription("\(indent)  ")
      }
      output += "\(indent) }\n"
    }
    output += unknownFields.getDescription(indent)
    return output
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          for oneElementuniversities in universities {
              hashCode = (hashCode &* 31) &+ oneElementuniversities.hashValue
          }
          for oneElementsubjects in subjects {
              hashCode = (hashCode &* 31) &+ oneElementsubjects.hashValue
          }
          for oneElementcourses in courses {
              hashCode = (hashCode &* 31) &+ oneElementcourses.hashValue
          }
          for oneElementsections in sections {
              hashCode = (hashCode &* 31) &+ oneElementsections.hashValue
          }
          if hasUniversity {
              if let hashValueuniversity = university?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValueuniversity
              }
          }
          if hasSubject {
              if let hashValuesubject = subject?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValuesubject
              }
          }
          if hasCourse {
              if let hashValuecourse = course?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValuecourse
              }
          }
          if hasSection {
              if let hashValuesection = section?.hashValue {
                  hashCode = (hashCode &* 31) &+ hashValuesection
              }
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "Data"
  }
  override public func className() -> String {
      return "Data"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return Data.self
  }
  //Meta information declaration end

  final public class Builder : GeneratedMessageBuilder {
    private var builderResult:Data = Data()
    public func getMessage() -> Data {
        return builderResult
    }

    required override public init () {
       super.init()
    }
    public var universities:Array<University> {
         get {
             return builderResult.universities
         }
         set (value) {
             builderResult.universities = value
         }
    }
    public func setUniversities(value:Array<University>) -> Data.Builder {
      self.universities = value
      return self
    }
    public func clearUniversities() -> Data.Builder {
      builderResult.universities.removeAll(keepCapacity: false)
      return self
    }
    public var subjects:Array<Subject> {
         get {
             return builderResult.subjects
         }
         set (value) {
             builderResult.subjects = value
         }
    }
    public func setSubjects(value:Array<Subject>) -> Data.Builder {
      self.subjects = value
      return self
    }
    public func clearSubjects() -> Data.Builder {
      builderResult.subjects.removeAll(keepCapacity: false)
      return self
    }
    public var courses:Array<Course> {
         get {
             return builderResult.courses
         }
         set (value) {
             builderResult.courses = value
         }
    }
    public func setCourses(value:Array<Course>) -> Data.Builder {
      self.courses = value
      return self
    }
    public func clearCourses() -> Data.Builder {
      builderResult.courses.removeAll(keepCapacity: false)
      return self
    }
    public var sections:Array<Section> {
         get {
             return builderResult.sections
         }
         set (value) {
             builderResult.sections = value
         }
    }
    public func setSections(value:Array<Section>) -> Data.Builder {
      self.sections = value
      return self
    }
    public func clearSections() -> Data.Builder {
      builderResult.sections.removeAll(keepCapacity: false)
      return self
    }
    public var hasUniversity:Bool {
         get {
             return builderResult.hasUniversity
         }
    }
    public var university:University! {
         get {
             if universityBuilder_ != nil {
                builderResult.university = universityBuilder_.getMessage()
             }
             return builderResult.university
         }
         set (value) {
             builderResult.hasUniversity = true
             builderResult.university = value
         }
    }
    private var universityBuilder_:University.Builder! {
         didSet {
            builderResult.hasUniversity = true
         }
    }
    public func getUniversityBuilder() -> University.Builder {
      if universityBuilder_ == nil {
         universityBuilder_ = University.Builder()
         builderResult.university = universityBuilder_.getMessage()
         if university != nil {
            try! universityBuilder_.mergeFrom(university)
         }
      }
      return universityBuilder_
    }
    public func setUniversity(value:University!) -> Data.Builder {
      self.university = value
      return self
    }
    public func mergeUniversity(value:University) throws -> Data.Builder {
      if builderResult.hasUniversity {
        builderResult.university = try University.builderWithPrototype(builderResult.university).mergeFrom(value).buildPartial()
      } else {
        builderResult.university = value
      }
      builderResult.hasUniversity = true
      return self
    }
    public func clearUniversity() -> Data.Builder {
      universityBuilder_ = nil
      builderResult.hasUniversity = false
      builderResult.university = nil
      return self
    }
    public var hasSubject:Bool {
         get {
             return builderResult.hasSubject
         }
    }
    public var subject:Subject! {
         get {
             if subjectBuilder_ != nil {
                builderResult.subject = subjectBuilder_.getMessage()
             }
             return builderResult.subject
         }
         set (value) {
             builderResult.hasSubject = true
             builderResult.subject = value
         }
    }
    private var subjectBuilder_:Subject.Builder! {
         didSet {
            builderResult.hasSubject = true
         }
    }
    public func getSubjectBuilder() -> Subject.Builder {
      if subjectBuilder_ == nil {
         subjectBuilder_ = Subject.Builder()
         builderResult.subject = subjectBuilder_.getMessage()
         if subject != nil {
            try! subjectBuilder_.mergeFrom(subject)
         }
      }
      return subjectBuilder_
    }
    public func setSubject(value:Subject!) -> Data.Builder {
      self.subject = value
      return self
    }
    public func mergeSubject(value:Subject) throws -> Data.Builder {
      if builderResult.hasSubject {
        builderResult.subject = try Subject.builderWithPrototype(builderResult.subject).mergeFrom(value).buildPartial()
      } else {
        builderResult.subject = value
      }
      builderResult.hasSubject = true
      return self
    }
    public func clearSubject() -> Data.Builder {
      subjectBuilder_ = nil
      builderResult.hasSubject = false
      builderResult.subject = nil
      return self
    }
    public var hasCourse:Bool {
         get {
             return builderResult.hasCourse
         }
    }
    public var course:Course! {
         get {
             if courseBuilder_ != nil {
                builderResult.course = courseBuilder_.getMessage()
             }
             return builderResult.course
         }
         set (value) {
             builderResult.hasCourse = true
             builderResult.course = value
         }
    }
    private var courseBuilder_:Course.Builder! {
         didSet {
            builderResult.hasCourse = true
         }
    }
    public func getCourseBuilder() -> Course.Builder {
      if courseBuilder_ == nil {
         courseBuilder_ = Course.Builder()
         builderResult.course = courseBuilder_.getMessage()
         if course != nil {
            try! courseBuilder_.mergeFrom(course)
         }
      }
      return courseBuilder_
    }
    public func setCourse(value:Course!) -> Data.Builder {
      self.course = value
      return self
    }
    public func mergeCourse(value:Course) throws -> Data.Builder {
      if builderResult.hasCourse {
        builderResult.course = try Course.builderWithPrototype(builderResult.course).mergeFrom(value).buildPartial()
      } else {
        builderResult.course = value
      }
      builderResult.hasCourse = true
      return self
    }
    public func clearCourse() -> Data.Builder {
      courseBuilder_ = nil
      builderResult.hasCourse = false
      builderResult.course = nil
      return self
    }
    public var hasSection:Bool {
         get {
             return builderResult.hasSection
         }
    }
    public var section:Section! {
         get {
             if sectionBuilder_ != nil {
                builderResult.section = sectionBuilder_.getMessage()
             }
             return builderResult.section
         }
         set (value) {
             builderResult.hasSection = true
             builderResult.section = value
         }
    }
    private var sectionBuilder_:Section.Builder! {
         didSet {
            builderResult.hasSection = true
         }
    }
    public func getSectionBuilder() -> Section.Builder {
      if sectionBuilder_ == nil {
         sectionBuilder_ = Section.Builder()
         builderResult.section = sectionBuilder_.getMessage()
         if section != nil {
            try! sectionBuilder_.mergeFrom(section)
         }
      }
      return sectionBuilder_
    }
    public func setSection(value:Section!) -> Data.Builder {
      self.section = value
      return self
    }
    public func mergeSection(value:Section) throws -> Data.Builder {
      if builderResult.hasSection {
        builderResult.section = try Section.builderWithPrototype(builderResult.section).mergeFrom(value).buildPartial()
      } else {
        builderResult.section = value
      }
      builderResult.hasSection = true
      return self
    }
    public func clearSection() -> Data.Builder {
      sectionBuilder_ = nil
      builderResult.hasSection = false
      builderResult.section = nil
      return self
    }
    override public var internalGetResult:GeneratedMessage {
         get {
            return builderResult
         }
    }
    public override func clear() -> Data.Builder {
      builderResult = Data()
      return self
    }
    public override func clone() throws -> Data.Builder {
      return try Data.builderWithPrototype(builderResult)
    }
    public override func build() throws -> Data {
         try checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> Data {
      let returnMe:Data = builderResult
      return returnMe
    }
    public func mergeFrom(other:Data) throws -> Data.Builder {
      if other == Data() {
       return self
      }
      if !other.universities.isEmpty  {
         builderResult.universities += other.universities
      }
      if !other.subjects.isEmpty  {
         builderResult.subjects += other.subjects
      }
      if !other.courses.isEmpty  {
         builderResult.courses += other.courses
      }
      if !other.sections.isEmpty  {
         builderResult.sections += other.sections
      }
      if (other.hasUniversity) {
          try mergeUniversity(other.university)
      }
      if (other.hasSubject) {
          try mergeSubject(other.subject)
      }
      if (other.hasCourse) {
          try mergeCourse(other.course)
      }
      if (other.hasSection) {
          try mergeSection(other.section)
      }
      try mergeUnknownFields(other.unknownFields)
      return self
    }
    public override func mergeFromCodedInputStream(input:CodedInputStream) throws -> Data.Builder {
         return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
    }
    public override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Data.Builder {
      let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
      while (true) {
        let protobufTag = try input.readTag()
        switch protobufTag {
        case 0: 
          self.unknownFields = try unknownFieldsBuilder.build()
          return self

        case 10 :
          let subBuilder = University.Builder()
          try input.readMessage(subBuilder,extensionRegistry:extensionRegistry)
          universities += [subBuilder.buildPartial()]

        case 18 :
          let subBuilder = Subject.Builder()
          try input.readMessage(subBuilder,extensionRegistry:extensionRegistry)
          subjects += [subBuilder.buildPartial()]

        case 26 :
          let subBuilder = Course.Builder()
          try input.readMessage(subBuilder,extensionRegistry:extensionRegistry)
          courses += [subBuilder.buildPartial()]

        case 34 :
          let subBuilder = Section.Builder()
          try input.readMessage(subBuilder,extensionRegistry:extensionRegistry)
          sections += [subBuilder.buildPartial()]

        case 42 :
          let subBuilder:University.Builder = University.Builder()
          if hasUniversity {
            try subBuilder.mergeFrom(university)
          }
          try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
          university = subBuilder.buildPartial()

        case 50 :
          let subBuilder:Subject.Builder = Subject.Builder()
          if hasSubject {
            try subBuilder.mergeFrom(subject)
          }
          try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
          subject = subBuilder.buildPartial()

        case 58 :
          let subBuilder:Course.Builder = Course.Builder()
          if hasCourse {
            try subBuilder.mergeFrom(course)
          }
          try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
          course = subBuilder.buildPartial()

        case 66 :
          let subBuilder:Section.Builder = Section.Builder()
          if hasSection {
            try subBuilder.mergeFrom(section)
          }
          try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
          section = subBuilder.buildPartial()

        default:
          if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
             unknownFields = try unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
  }

}


// @@protoc_insertion_point(global_scope)
