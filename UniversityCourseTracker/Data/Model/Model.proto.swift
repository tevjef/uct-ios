/// Generated by the Protocol Buffers 3.4.0 compiler.  DO NOT EDIT!
/// Protobuf-swift version: 3.0.24
/// Source file "model.proto"
/// Syntax "Proto2"

import Foundation
import ProtocolBuffers


public struct ModelRoot {
    public static let `default` = ModelRoot()
    public var extensionRegistry:ExtensionRegistry

    init() {
        extensionRegistry = ExtensionRegistry()
        registerAllExtensions(registry: extensionRegistry)
    }
    public func registerAllExtensions(registry: ExtensionRegistry) {
    }
}

final public class University : GeneratedMessage {
    public typealias BuilderType = University.Builder

    public static func == (lhs: University, rhs: University) -> Bool {
        if lhs === rhs {
            return true
        }
        var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
        fieldCheck = fieldCheck && (lhs.hasId == rhs.hasId) && (!lhs.hasId || lhs.id == rhs.id)
        fieldCheck = fieldCheck && (lhs.hasName == rhs.hasName) && (!lhs.hasName || lhs.name == rhs.name)
        fieldCheck = fieldCheck && (lhs.hasAbbr == rhs.hasAbbr) && (!lhs.hasAbbr || lhs.abbr == rhs.abbr)
        fieldCheck = fieldCheck && (lhs.hasHomePage == rhs.hasHomePage) && (!lhs.hasHomePage || lhs.homePage == rhs.homePage)
        fieldCheck = fieldCheck && (lhs.hasRegistrationPage == rhs.hasRegistrationPage) && (!lhs.hasRegistrationPage || lhs.registrationPage == rhs.registrationPage)
        fieldCheck = fieldCheck && (lhs.hasMainColor == rhs.hasMainColor) && (!lhs.hasMainColor || lhs.mainColor == rhs.mainColor)
        fieldCheck = fieldCheck && (lhs.hasAccentColor == rhs.hasAccentColor) && (!lhs.hasAccentColor || lhs.accentColor == rhs.accentColor)
        fieldCheck = fieldCheck && (lhs.hasTopicName == rhs.hasTopicName) && (!lhs.hasTopicName || lhs.topicName == rhs.topicName)
        fieldCheck = fieldCheck && (lhs.hasTopicId == rhs.hasTopicId) && (!lhs.hasTopicId || lhs.topicId == rhs.topicId)
        fieldCheck = fieldCheck && (lhs.hasResolvedSemesters == rhs.hasResolvedSemesters) && (!lhs.hasResolvedSemesters || lhs.resolvedSemesters == rhs.resolvedSemesters)
        fieldCheck = fieldCheck && (lhs.subjects == rhs.subjects)
        fieldCheck = fieldCheck && (lhs.availableSemesters == rhs.availableSemesters)
        fieldCheck = fieldCheck && (lhs.registrations == rhs.registrations)
        fieldCheck = fieldCheck && (lhs.metadata == rhs.metadata)
        fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
        return fieldCheck
    }

    public fileprivate(set) var id:Int64! = nil
    public fileprivate(set) var hasId:Bool = false

    public fileprivate(set) var name:String! = nil
    public fileprivate(set) var hasName:Bool = false

    public fileprivate(set) var abbr:String! = nil
    public fileprivate(set) var hasAbbr:Bool = false

    public fileprivate(set) var homePage:String! = nil
    public fileprivate(set) var hasHomePage:Bool = false

    public fileprivate(set) var registrationPage:String! = nil
    public fileprivate(set) var hasRegistrationPage:Bool = false

    public fileprivate(set) var mainColor:String! = nil
    public fileprivate(set) var hasMainColor:Bool = false

    public fileprivate(set) var accentColor:String! = nil
    public fileprivate(set) var hasAccentColor:Bool = false

    public fileprivate(set) var topicName:String! = nil
    public fileprivate(set) var hasTopicName:Bool = false

    public fileprivate(set) var topicId:String! = nil
    public fileprivate(set) var hasTopicId:Bool = false

    public fileprivate(set) var resolvedSemesters:ResolvedSemester!
    public fileprivate(set) var hasResolvedSemesters:Bool = false
    public fileprivate(set) var subjects:Array<Subject>  = Array<Subject>()
    public fileprivate(set) var availableSemesters:Array<Semester>  = Array<Semester>()
    public fileprivate(set) var registrations:Array<Registration>  = Array<Registration>()
    public fileprivate(set) var metadata:Array<Metadata>  = Array<Metadata>()
    required public init() {
        super.init()
    }
    override public func isInitialized() -> Bool {
        return true
    }
    override public func writeTo(codedOutputStream: CodedOutputStream) throws {
        if hasId {
            try codedOutputStream.writeInt64(fieldNumber: 1, value:id)
        }
        if hasName {
            try codedOutputStream.writeString(fieldNumber: 2, value:name)
        }
        if hasAbbr {
            try codedOutputStream.writeString(fieldNumber: 3, value:abbr)
        }
        if hasHomePage {
            try codedOutputStream.writeString(fieldNumber: 4, value:homePage)
        }
        if hasRegistrationPage {
            try codedOutputStream.writeString(fieldNumber: 5, value:registrationPage)
        }
        if hasMainColor {
            try codedOutputStream.writeString(fieldNumber: 6, value:mainColor)
        }
        if hasAccentColor {
            try codedOutputStream.writeString(fieldNumber: 7, value:accentColor)
        }
        if hasTopicName {
            try codedOutputStream.writeString(fieldNumber: 8, value:topicName)
        }
        if hasTopicId {
            try codedOutputStream.writeString(fieldNumber: 9, value:topicId)
        }
        if hasResolvedSemesters {
            try codedOutputStream.writeMessage(fieldNumber: 10, value:resolvedSemesters)
        }
        for oneElementSubjects in subjects {
              try codedOutputStream.writeMessage(fieldNumber: 11, value:oneElementSubjects)
        }
        for oneElementAvailableSemesters in availableSemesters {
              try codedOutputStream.writeMessage(fieldNumber: 12, value:oneElementAvailableSemesters)
        }
        for oneElementRegistrations in registrations {
              try codedOutputStream.writeMessage(fieldNumber: 13, value:oneElementRegistrations)
        }
        for oneElementMetadata in metadata {
              try codedOutputStream.writeMessage(fieldNumber: 14, value:oneElementMetadata)
        }
        try unknownFields.writeTo(codedOutputStream: codedOutputStream)
    }
    override public func serializedSize() -> Int32 {
        var serialize_size:Int32 = memoizedSerializedSize
        if serialize_size != -1 {
         return serialize_size
        }

        serialize_size = 0
        if hasId {
            serialize_size += id.computeInt64Size(fieldNumber: 1)
        }
        if hasName {
            serialize_size += name.computeStringSize(fieldNumber: 2)
        }
        if hasAbbr {
            serialize_size += abbr.computeStringSize(fieldNumber: 3)
        }
        if hasHomePage {
            serialize_size += homePage.computeStringSize(fieldNumber: 4)
        }
        if hasRegistrationPage {
            serialize_size += registrationPage.computeStringSize(fieldNumber: 5)
        }
        if hasMainColor {
            serialize_size += mainColor.computeStringSize(fieldNumber: 6)
        }
        if hasAccentColor {
            serialize_size += accentColor.computeStringSize(fieldNumber: 7)
        }
        if hasTopicName {
            serialize_size += topicName.computeStringSize(fieldNumber: 8)
        }
        if hasTopicId {
            serialize_size += topicId.computeStringSize(fieldNumber: 9)
        }
        if hasResolvedSemesters {
            if let varSizeresolvedSemesters = resolvedSemesters?.computeMessageSize(fieldNumber: 10) {
                serialize_size += varSizeresolvedSemesters
            }
        }
        for oneElementSubjects in subjects {
            serialize_size += oneElementSubjects.computeMessageSize(fieldNumber: 11)
        }
        for oneElementAvailableSemesters in availableSemesters {
            serialize_size += oneElementAvailableSemesters.computeMessageSize(fieldNumber: 12)
        }
        for oneElementRegistrations in registrations {
            serialize_size += oneElementRegistrations.computeMessageSize(fieldNumber: 13)
        }
        for oneElementMetadata in metadata {
            serialize_size += oneElementMetadata.computeMessageSize(fieldNumber: 14)
        }
        serialize_size += unknownFields.serializedSize()
        memoizedSerializedSize = serialize_size
        return serialize_size
    }
    public class func getBuilder() -> University.Builder {
        return University.classBuilder() as! University.Builder
    }
    public func getBuilder() -> University.Builder {
        return classBuilder() as! University.Builder
    }
    override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
        return University.Builder()
    }
    override public func classBuilder() -> ProtocolBuffersMessageBuilder {
        return University.Builder()
    }
    public func toBuilder() throws -> University.Builder {
        return try University.builderWithPrototype(prototype:self)
    }
    public class func builderWithPrototype(prototype:University) throws -> University.Builder {
        return try University.Builder().mergeFrom(other:prototype)
    }
    override public func encode() throws -> Dictionary<String,Any> {
        guard isInitialized() else {
            throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
        }

        var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
        if hasId {
            jsonMap["id"] = "\(id!)"
        }
        if hasName {
            jsonMap["name"] = name
        }
        if hasAbbr {
            jsonMap["abbr"] = abbr
        }
        if hasHomePage {
            jsonMap["homePage"] = homePage
        }
        if hasRegistrationPage {
            jsonMap["registrationPage"] = registrationPage
        }
        if hasMainColor {
            jsonMap["mainColor"] = mainColor
        }
        if hasAccentColor {
            jsonMap["accentColor"] = accentColor
        }
        if hasTopicName {
            jsonMap["topicName"] = topicName
        }
        if hasTopicId {
            jsonMap["topicId"] = topicId
        }
        if hasResolvedSemesters {
            jsonMap["resolvedSemesters"] = try resolvedSemesters.encode()
        }
        if !subjects.isEmpty {
            var jsonArraySubjects:Array<Dictionary<String,Any>> = []
            for oneValueSubjects in subjects {
                let ecodedMessageSubjects = try oneValueSubjects.encode()
                jsonArraySubjects.append(ecodedMessageSubjects)
            }
            jsonMap["subjects"] = jsonArraySubjects
        }
        if !availableSemesters.isEmpty {
            var jsonArrayAvailableSemesters:Array<Dictionary<String,Any>> = []
            for oneValueAvailableSemesters in availableSemesters {
                let ecodedMessageAvailableSemesters = try oneValueAvailableSemesters.encode()
                jsonArrayAvailableSemesters.append(ecodedMessageAvailableSemesters)
            }
            jsonMap["availableSemesters"] = jsonArrayAvailableSemesters
        }
        if !registrations.isEmpty {
            var jsonArrayRegistrations:Array<Dictionary<String,Any>> = []
            for oneValueRegistrations in registrations {
                let ecodedMessageRegistrations = try oneValueRegistrations.encode()
                jsonArrayRegistrations.append(ecodedMessageRegistrations)
            }
            jsonMap["registrations"] = jsonArrayRegistrations
        }
        if !metadata.isEmpty {
            var jsonArrayMetadata:Array<Dictionary<String,Any>> = []
            for oneValueMetadata in metadata {
                let ecodedMessageMetadata = try oneValueMetadata.encode()
                jsonArrayMetadata.append(ecodedMessageMetadata)
            }
            jsonMap["metadata"] = jsonArrayMetadata
        }
        return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,Any>) throws -> University {
        return try University.Builder.decodeToBuilder(jsonMap:jsonMap).build()
    }
    override class public func fromJSON(data:Data) throws -> University {
        return try University.Builder.fromJSONToBuilder(data:data).build()
    }
    override public func getDescription(indent:String) throws -> String {
        var output = ""
        if hasId {
            output += "\(indent) id: \(id) \n"
        }
        if hasName {
            output += "\(indent) name: \(name) \n"
        }
        if hasAbbr {
            output += "\(indent) abbr: \(abbr) \n"
        }
        if hasHomePage {
            output += "\(indent) homePage: \(homePage) \n"
        }
        if hasRegistrationPage {
            output += "\(indent) registrationPage: \(registrationPage) \n"
        }
        if hasMainColor {
            output += "\(indent) mainColor: \(mainColor) \n"
        }
        if hasAccentColor {
            output += "\(indent) accentColor: \(accentColor) \n"
        }
        if hasTopicName {
            output += "\(indent) topicName: \(topicName) \n"
        }
        if hasTopicId {
            output += "\(indent) topicId: \(topicId) \n"
        }
        if hasResolvedSemesters {
            output += "\(indent) resolvedSemesters {\n"
            if let outDescResolvedSemesters = resolvedSemesters {
                output += try outDescResolvedSemesters.getDescription(indent: "\(indent)  ")
            }
            output += "\(indent) }\n"
        }
        var subjectsElementIndex:Int = 0
        for oneElementSubjects in subjects {
            output += "\(indent) subjects[\(subjectsElementIndex)] {\n"
            output += try oneElementSubjects.getDescription(indent: "\(indent)  ")
            output += "\(indent)}\n"
            subjectsElementIndex += 1
        }
        var availableSemestersElementIndex:Int = 0
        for oneElementAvailableSemesters in availableSemesters {
            output += "\(indent) availableSemesters[\(availableSemestersElementIndex)] {\n"
            output += try oneElementAvailableSemesters.getDescription(indent: "\(indent)  ")
            output += "\(indent)}\n"
            availableSemestersElementIndex += 1
        }
        var registrationsElementIndex:Int = 0
        for oneElementRegistrations in registrations {
            output += "\(indent) registrations[\(registrationsElementIndex)] {\n"
            output += try oneElementRegistrations.getDescription(indent: "\(indent)  ")
            output += "\(indent)}\n"
            registrationsElementIndex += 1
        }
        var metadataElementIndex:Int = 0
        for oneElementMetadata in metadata {
            output += "\(indent) metadata[\(metadataElementIndex)] {\n"
            output += try oneElementMetadata.getDescription(indent: "\(indent)  ")
            output += "\(indent)}\n"
            metadataElementIndex += 1
        }
        output += unknownFields.getDescription(indent: indent)
        return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasId {
                hashCode = (hashCode &* 31) &+ id.hashValue
            }
            if hasName {
                hashCode = (hashCode &* 31) &+ name.hashValue
            }
            if hasAbbr {
                hashCode = (hashCode &* 31) &+ abbr.hashValue
            }
            if hasHomePage {
                hashCode = (hashCode &* 31) &+ homePage.hashValue
            }
            if hasRegistrationPage {
                hashCode = (hashCode &* 31) &+ registrationPage.hashValue
            }
            if hasMainColor {
                hashCode = (hashCode &* 31) &+ mainColor.hashValue
            }
            if hasAccentColor {
                hashCode = (hashCode &* 31) &+ accentColor.hashValue
            }
            if hasTopicName {
                hashCode = (hashCode &* 31) &+ topicName.hashValue
            }
            if hasTopicId {
                hashCode = (hashCode &* 31) &+ topicId.hashValue
            }
            if hasResolvedSemesters {
                if let hashValueresolvedSemesters = resolvedSemesters?.hashValue {
                    hashCode = (hashCode &* 31) &+ hashValueresolvedSemesters
                }
            }
            for oneElementSubjects in subjects {
                hashCode = (hashCode &* 31) &+ oneElementSubjects.hashValue
            }
            for oneElementAvailableSemesters in availableSemesters {
                hashCode = (hashCode &* 31) &+ oneElementAvailableSemesters.hashValue
            }
            for oneElementRegistrations in registrations {
                hashCode = (hashCode &* 31) &+ oneElementRegistrations.hashValue
            }
            for oneElementMetadata in metadata {
                hashCode = (hashCode &* 31) &+ oneElementMetadata.hashValue
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "University"
    }
    override public func className() -> String {
        return "University"
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
        fileprivate var builderResult:University = University()
        public func getMessage() -> University {
            return builderResult
        }

        required override public init () {
            super.init()
        }
        public var id:Int64 {
            get {
                return builderResult.id
            }
            set (value) {
                builderResult.hasId = true
                builderResult.id = value
            }
        }
        public var hasId:Bool {
            get {
                return builderResult.hasId
            }
        }
        @discardableResult
        public func setId(_ value:Int64) -> University.Builder {
            self.id = value
            return self
        }
        @discardableResult
        public func clearId() -> University.Builder{
            builderResult.hasId = false
            builderResult.id = nil
            return self
        }
        public var name:String {
            get {
                return builderResult.name
            }
            set (value) {
                builderResult.hasName = true
                builderResult.name = value
            }
        }
        public var hasName:Bool {
            get {
                return builderResult.hasName
            }
        }
        @discardableResult
        public func setName(_ value:String) -> University.Builder {
            self.name = value
            return self
        }
        @discardableResult
        public func clearName() -> University.Builder{
            builderResult.hasName = false
            builderResult.name = nil
            return self
        }
        public var abbr:String {
            get {
                return builderResult.abbr
            }
            set (value) {
                builderResult.hasAbbr = true
                builderResult.abbr = value
            }
        }
        public var hasAbbr:Bool {
            get {
                return builderResult.hasAbbr
            }
        }
        @discardableResult
        public func setAbbr(_ value:String) -> University.Builder {
            self.abbr = value
            return self
        }
        @discardableResult
        public func clearAbbr() -> University.Builder{
            builderResult.hasAbbr = false
            builderResult.abbr = nil
            return self
        }
        public var homePage:String {
            get {
                return builderResult.homePage
            }
            set (value) {
                builderResult.hasHomePage = true
                builderResult.homePage = value
            }
        }
        public var hasHomePage:Bool {
            get {
                return builderResult.hasHomePage
            }
        }
        @discardableResult
        public func setHomePage(_ value:String) -> University.Builder {
            self.homePage = value
            return self
        }
        @discardableResult
        public func clearHomePage() -> University.Builder{
            builderResult.hasHomePage = false
            builderResult.homePage = nil
            return self
        }
        public var registrationPage:String {
            get {
                return builderResult.registrationPage
            }
            set (value) {
                builderResult.hasRegistrationPage = true
                builderResult.registrationPage = value
            }
        }
        public var hasRegistrationPage:Bool {
            get {
                return builderResult.hasRegistrationPage
            }
        }
        @discardableResult
        public func setRegistrationPage(_ value:String) -> University.Builder {
            self.registrationPage = value
            return self
        }
        @discardableResult
        public func clearRegistrationPage() -> University.Builder{
            builderResult.hasRegistrationPage = false
            builderResult.registrationPage = nil
            return self
        }
        public var mainColor:String {
            get {
                return builderResult.mainColor
            }
            set (value) {
                builderResult.hasMainColor = true
                builderResult.mainColor = value
            }
        }
        public var hasMainColor:Bool {
            get {
                return builderResult.hasMainColor
            }
        }
        @discardableResult
        public func setMainColor(_ value:String) -> University.Builder {
            self.mainColor = value
            return self
        }
        @discardableResult
        public func clearMainColor() -> University.Builder{
            builderResult.hasMainColor = false
            builderResult.mainColor = nil
            return self
        }
        public var accentColor:String {
            get {
                return builderResult.accentColor
            }
            set (value) {
                builderResult.hasAccentColor = true
                builderResult.accentColor = value
            }
        }
        public var hasAccentColor:Bool {
            get {
                return builderResult.hasAccentColor
            }
        }
        @discardableResult
        public func setAccentColor(_ value:String) -> University.Builder {
            self.accentColor = value
            return self
        }
        @discardableResult
        public func clearAccentColor() -> University.Builder{
            builderResult.hasAccentColor = false
            builderResult.accentColor = nil
            return self
        }
        public var topicName:String {
            get {
                return builderResult.topicName
            }
            set (value) {
                builderResult.hasTopicName = true
                builderResult.topicName = value
            }
        }
        public var hasTopicName:Bool {
            get {
                return builderResult.hasTopicName
            }
        }
        @discardableResult
        public func setTopicName(_ value:String) -> University.Builder {
            self.topicName = value
            return self
        }
        @discardableResult
        public func clearTopicName() -> University.Builder{
            builderResult.hasTopicName = false
            builderResult.topicName = nil
            return self
        }
        public var topicId:String {
            get {
                return builderResult.topicId
            }
            set (value) {
                builderResult.hasTopicId = true
                builderResult.topicId = value
            }
        }
        public var hasTopicId:Bool {
            get {
                return builderResult.hasTopicId
            }
        }
        @discardableResult
        public func setTopicId(_ value:String) -> University.Builder {
            self.topicId = value
            return self
        }
        @discardableResult
        public func clearTopicId() -> University.Builder{
            builderResult.hasTopicId = false
            builderResult.topicId = nil
            return self
        }
        public var resolvedSemesters:ResolvedSemester! {
            get {
                if resolvedSemestersBuilder_ != nil {
                    builderResult.resolvedSemesters = resolvedSemestersBuilder_.getMessage()
                }
                return builderResult.resolvedSemesters
            }
            set (value) {
                builderResult.hasResolvedSemesters = value != nil
                builderResult.resolvedSemesters = value
            }
        }
        public var hasResolvedSemesters:Bool {
            get {
                return builderResult.hasResolvedSemesters
            }
        }
        fileprivate var resolvedSemestersBuilder_:ResolvedSemester.Builder! {
            didSet {
                builderResult.hasResolvedSemesters = true
            }
        }
        public func getResolvedSemestersBuilder() -> ResolvedSemester.Builder {
            if resolvedSemestersBuilder_ == nil {
                resolvedSemestersBuilder_ = ResolvedSemester.Builder()
                builderResult.resolvedSemesters = resolvedSemestersBuilder_.getMessage()
                if resolvedSemesters != nil {
                    try! resolvedSemestersBuilder_.mergeFrom(other: resolvedSemesters)
                }
            }
            return resolvedSemestersBuilder_
        }
        @discardableResult
        public func setResolvedSemesters(_ value:ResolvedSemester!) -> University.Builder {
            self.resolvedSemesters = value
            return self
        }
        @discardableResult
        public func mergeResolvedSemesters(value:ResolvedSemester) throws -> University.Builder {
            if builderResult.hasResolvedSemesters {
                builderResult.resolvedSemesters = try ResolvedSemester.builderWithPrototype(prototype:builderResult.resolvedSemesters).mergeFrom(other: value).buildPartial()
            } else {
                builderResult.resolvedSemesters = value
            }
            builderResult.hasResolvedSemesters = true
            return self
        }
        @discardableResult
        public func clearResolvedSemesters() -> University.Builder {
            resolvedSemestersBuilder_ = nil
            builderResult.hasResolvedSemesters = false
            builderResult.resolvedSemesters = nil
            return self
        }
        public var subjects:Array<Subject> {
            get {
                return builderResult.subjects
            }
            set (value) {
                builderResult.subjects = value
            }
        }
        @discardableResult
        public func setSubjects(_ value:Array<Subject>) -> University.Builder {
            self.subjects = value
            return self
        }
        @discardableResult
        public func clearSubjects() -> University.Builder {
            builderResult.subjects.removeAll(keepingCapacity: false)
            return self
        }
        public var availableSemesters:Array<Semester> {
            get {
                return builderResult.availableSemesters
            }
            set (value) {
                builderResult.availableSemesters = value
            }
        }
        @discardableResult
        public func setAvailableSemesters(_ value:Array<Semester>) -> University.Builder {
            self.availableSemesters = value
            return self
        }
        @discardableResult
        public func clearAvailableSemesters() -> University.Builder {
            builderResult.availableSemesters.removeAll(keepingCapacity: false)
            return self
        }
        public var registrations:Array<Registration> {
            get {
                return builderResult.registrations
            }
            set (value) {
                builderResult.registrations = value
            }
        }
        @discardableResult
        public func setRegistrations(_ value:Array<Registration>) -> University.Builder {
            self.registrations = value
            return self
        }
        @discardableResult
        public func clearRegistrations() -> University.Builder {
            builderResult.registrations.removeAll(keepingCapacity: false)
            return self
        }
        public var metadata:Array<Metadata> {
            get {
                return builderResult.metadata
            }
            set (value) {
                builderResult.metadata = value
            }
        }
        @discardableResult
        public func setMetadata(_ value:Array<Metadata>) -> University.Builder {
            self.metadata = value
            return self
        }
        @discardableResult
        public func clearMetadata() -> University.Builder {
            builderResult.metadata.removeAll(keepingCapacity: false)
            return self
        }
        override public var internalGetResult:GeneratedMessage {
            get {
                return builderResult
            }
        }
        @discardableResult
        override public func clear() -> University.Builder {
            builderResult = University()
            return self
        }
        override public func clone() throws -> University.Builder {
            return try University.builderWithPrototype(prototype:builderResult)
        }
        override public func build() throws -> University {
            try checkInitialized()
            return buildPartial()
        }
        public func buildPartial() -> University {
            let returnMe:University = builderResult
            return returnMe
        }
        @discardableResult
        public func mergeFrom(other:University) throws -> University.Builder {
            if other == University() {
                return self
            }
            if other.hasId {
                id = other.id
            }
            if other.hasName {
                name = other.name
            }
            if other.hasAbbr {
                abbr = other.abbr
            }
            if other.hasHomePage {
                homePage = other.homePage
            }
            if other.hasRegistrationPage {
                registrationPage = other.registrationPage
            }
            if other.hasMainColor {
                mainColor = other.mainColor
            }
            if other.hasAccentColor {
                accentColor = other.accentColor
            }
            if other.hasTopicName {
                topicName = other.topicName
            }
            if other.hasTopicId {
                topicId = other.topicId
            }
            if (other.hasResolvedSemesters) {
                try mergeResolvedSemesters(value: other.resolvedSemesters)
            }
            if !other.subjects.isEmpty  {
                 builderResult.subjects += other.subjects
            }
            if !other.availableSemesters.isEmpty  {
                 builderResult.availableSemesters += other.availableSemesters
            }
            if !other.registrations.isEmpty  {
                 builderResult.registrations += other.registrations
            }
            if !other.metadata.isEmpty  {
                 builderResult.metadata += other.metadata
            }
            try merge(unknownField: other.unknownFields)
            return self
        }
        @discardableResult
        override public func mergeFrom(codedInputStream: CodedInputStream) throws -> University.Builder {
            return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
        }
        @discardableResult
        override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> University.Builder {
            let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
            while (true) {
                let protobufTag = try codedInputStream.readTag()
                switch protobufTag {
                case 0: 
                    self.unknownFields = try unknownFieldsBuilder.build()
                    return self

                case 8:
                    id = try codedInputStream.readInt64()

                case 18:
                    name = try codedInputStream.readString()

                case 26:
                    abbr = try codedInputStream.readString()

                case 34:
                    homePage = try codedInputStream.readString()

                case 42:
                    registrationPage = try codedInputStream.readString()

                case 50:
                    mainColor = try codedInputStream.readString()

                case 58:
                    accentColor = try codedInputStream.readString()

                case 66:
                    topicName = try codedInputStream.readString()

                case 74:
                    topicId = try codedInputStream.readString()

                case 82:
                    let subBuilder:ResolvedSemester.Builder = ResolvedSemester.Builder()
                    if hasResolvedSemesters {
                        try subBuilder.mergeFrom(other: resolvedSemesters)
                    }
                    try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                    resolvedSemesters = subBuilder.buildPartial()

                case 90:
                    let subBuilder = Subject.Builder()
                    try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
                    subjects.append(subBuilder.buildPartial())

                case 98:
                    let subBuilder = Semester.Builder()
                    try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
                    availableSemesters.append(subBuilder.buildPartial())

                case 106:
                    let subBuilder = Registration.Builder()
                    try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
                    registrations.append(subBuilder.buildPartial())

                case 114:
                    let subBuilder = Metadata.Builder()
                    try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
                    metadata.append(subBuilder.buildPartial())

                default:
                    if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                        unknownFields = try unknownFieldsBuilder.build()
                        return self
                    }
                }
            }
        }
        class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> University.Builder {
            let resultDecodedBuilder = University.Builder()
            if let jsonValueId = jsonMap["id"] as? String {
                resultDecodedBuilder.id = Int64(jsonValueId)!
            } else if let jsonValueId = jsonMap["id"] as? Int {
                resultDecodedBuilder.id = Int64(jsonValueId)
            }
            if let jsonValueName = jsonMap["name"] as? String {
                resultDecodedBuilder.name = jsonValueName
            }
            if let jsonValueAbbr = jsonMap["abbr"] as? String {
                resultDecodedBuilder.abbr = jsonValueAbbr
            }
            if let jsonValueHomePage = jsonMap["homePage"] as? String {
                resultDecodedBuilder.homePage = jsonValueHomePage
            }
            if let jsonValueRegistrationPage = jsonMap["registrationPage"] as? String {
                resultDecodedBuilder.registrationPage = jsonValueRegistrationPage
            }
            if let jsonValueMainColor = jsonMap["mainColor"] as? String {
                resultDecodedBuilder.mainColor = jsonValueMainColor
            }
            if let jsonValueAccentColor = jsonMap["accentColor"] as? String {
                resultDecodedBuilder.accentColor = jsonValueAccentColor
            }
            if let jsonValueTopicName = jsonMap["topicName"] as? String {
                resultDecodedBuilder.topicName = jsonValueTopicName
            }
            if let jsonValueTopicId = jsonMap["topicId"] as? String {
                resultDecodedBuilder.topicId = jsonValueTopicId
            }
            if let jsonValueResolvedSemesters = jsonMap["resolvedSemesters"] as? Dictionary<String,Any> {
                resultDecodedBuilder.resolvedSemesters = try ResolvedSemester.Builder.decodeToBuilder(jsonMap:jsonValueResolvedSemesters).build()

            }
            if let jsonValueSubjects = jsonMap["subjects"] as? Array<Dictionary<String,Any>> {
                var jsonArraySubjects:Array<Subject> = []
                for oneValueSubjects in jsonValueSubjects {
                    let messageFromStringSubjects = try Subject.Builder.decodeToBuilder(jsonMap:oneValueSubjects).build()

                    jsonArraySubjects.append(messageFromStringSubjects)
                }
                resultDecodedBuilder.subjects = jsonArraySubjects
            }
            if let jsonValueAvailableSemesters = jsonMap["availableSemesters"] as? Array<Dictionary<String,Any>> {
                var jsonArrayAvailableSemesters:Array<Semester> = []
                for oneValueAvailableSemesters in jsonValueAvailableSemesters {
                    let messageFromStringAvailableSemesters = try Semester.Builder.decodeToBuilder(jsonMap:oneValueAvailableSemesters).build()

                    jsonArrayAvailableSemesters.append(messageFromStringAvailableSemesters)
                }
                resultDecodedBuilder.availableSemesters = jsonArrayAvailableSemesters
            }
            if let jsonValueRegistrations = jsonMap["registrations"] as? Array<Dictionary<String,Any>> {
                var jsonArrayRegistrations:Array<Registration> = []
                for oneValueRegistrations in jsonValueRegistrations {
                    let messageFromStringRegistrations = try Registration.Builder.decodeToBuilder(jsonMap:oneValueRegistrations).build()

                    jsonArrayRegistrations.append(messageFromStringRegistrations)
                }
                resultDecodedBuilder.registrations = jsonArrayRegistrations
            }
            if let jsonValueMetadata = jsonMap["metadata"] as? Array<Dictionary<String,Any>> {
                var jsonArrayMetadata:Array<Metadata> = []
                for oneValueMetadata in jsonValueMetadata {
                    let messageFromStringMetadata = try Metadata.Builder.decodeToBuilder(jsonMap:oneValueMetadata).build()

                    jsonArrayMetadata.append(messageFromStringMetadata)
                }
                resultDecodedBuilder.metadata = jsonArrayMetadata
            }
            return resultDecodedBuilder
        }
        override class public func fromJSONToBuilder(data:Data) throws -> University.Builder {
            let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
            guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
              throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
            }
            return try University.Builder.decodeToBuilder(jsonMap:jsDataCast)
        }
    }

}

final public class Subject : GeneratedMessage {
    public typealias BuilderType = Subject.Builder

    public static func == (lhs: Subject, rhs: Subject) -> Bool {
        if lhs === rhs {
            return true
        }
        var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
        fieldCheck = fieldCheck && (lhs.hasId == rhs.hasId) && (!lhs.hasId || lhs.id == rhs.id)
        fieldCheck = fieldCheck && (lhs.hasUniversityId == rhs.hasUniversityId) && (!lhs.hasUniversityId || lhs.universityId == rhs.universityId)
        fieldCheck = fieldCheck && (lhs.hasName == rhs.hasName) && (!lhs.hasName || lhs.name == rhs.name)
        fieldCheck = fieldCheck && (lhs.hasNumber == rhs.hasNumber) && (!lhs.hasNumber || lhs.number == rhs.number)
        fieldCheck = fieldCheck && (lhs.hasSeason == rhs.hasSeason) && (!lhs.hasSeason || lhs.season == rhs.season)
        fieldCheck = fieldCheck && (lhs.hasYear == rhs.hasYear) && (!lhs.hasYear || lhs.year == rhs.year)
        fieldCheck = fieldCheck && (lhs.hasTopicName == rhs.hasTopicName) && (!lhs.hasTopicName || lhs.topicName == rhs.topicName)
        fieldCheck = fieldCheck && (lhs.hasTopicId == rhs.hasTopicId) && (!lhs.hasTopicId || lhs.topicId == rhs.topicId)
        fieldCheck = fieldCheck && (lhs.courses == rhs.courses)
        fieldCheck = fieldCheck && (lhs.metadata == rhs.metadata)
        fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
        return fieldCheck
    }

    public fileprivate(set) var id:Int64! = nil
    public fileprivate(set) var hasId:Bool = false

    public fileprivate(set) var universityId:Int64! = nil
    public fileprivate(set) var hasUniversityId:Bool = false

    public fileprivate(set) var name:String! = nil
    public fileprivate(set) var hasName:Bool = false

    public fileprivate(set) var number:String! = nil
    public fileprivate(set) var hasNumber:Bool = false

    public fileprivate(set) var season:String! = nil
    public fileprivate(set) var hasSeason:Bool = false

    public fileprivate(set) var year:String! = nil
    public fileprivate(set) var hasYear:Bool = false

    public fileprivate(set) var topicName:String! = nil
    public fileprivate(set) var hasTopicName:Bool = false

    public fileprivate(set) var topicId:String! = nil
    public fileprivate(set) var hasTopicId:Bool = false

    public fileprivate(set) var courses:Array<Course>  = Array<Course>()
    public fileprivate(set) var metadata:Array<Metadata>  = Array<Metadata>()
    required public init() {
        super.init()
    }
    override public func isInitialized() -> Bool {
        return true
    }
    override public func writeTo(codedOutputStream: CodedOutputStream) throws {
        if hasId {
            try codedOutputStream.writeInt64(fieldNumber: 1, value:id)
        }
        if hasUniversityId {
            try codedOutputStream.writeInt64(fieldNumber: 2, value:universityId)
        }
        if hasName {
            try codedOutputStream.writeString(fieldNumber: 3, value:name)
        }
        if hasNumber {
            try codedOutputStream.writeString(fieldNumber: 4, value:number)
        }
        if hasSeason {
            try codedOutputStream.writeString(fieldNumber: 5, value:season)
        }
        if hasYear {
            try codedOutputStream.writeString(fieldNumber: 6, value:year)
        }
        if hasTopicName {
            try codedOutputStream.writeString(fieldNumber: 7, value:topicName)
        }
        if hasTopicId {
            try codedOutputStream.writeString(fieldNumber: 8, value:topicId)
        }
        for oneElementCourses in courses {
              try codedOutputStream.writeMessage(fieldNumber: 9, value:oneElementCourses)
        }
        for oneElementMetadata in metadata {
              try codedOutputStream.writeMessage(fieldNumber: 10, value:oneElementMetadata)
        }
        try unknownFields.writeTo(codedOutputStream: codedOutputStream)
    }
    override public func serializedSize() -> Int32 {
        var serialize_size:Int32 = memoizedSerializedSize
        if serialize_size != -1 {
         return serialize_size
        }

        serialize_size = 0
        if hasId {
            serialize_size += id.computeInt64Size(fieldNumber: 1)
        }
        if hasUniversityId {
            serialize_size += universityId.computeInt64Size(fieldNumber: 2)
        }
        if hasName {
            serialize_size += name.computeStringSize(fieldNumber: 3)
        }
        if hasNumber {
            serialize_size += number.computeStringSize(fieldNumber: 4)
        }
        if hasSeason {
            serialize_size += season.computeStringSize(fieldNumber: 5)
        }
        if hasYear {
            serialize_size += year.computeStringSize(fieldNumber: 6)
        }
        if hasTopicName {
            serialize_size += topicName.computeStringSize(fieldNumber: 7)
        }
        if hasTopicId {
            serialize_size += topicId.computeStringSize(fieldNumber: 8)
        }
        for oneElementCourses in courses {
            serialize_size += oneElementCourses.computeMessageSize(fieldNumber: 9)
        }
        for oneElementMetadata in metadata {
            serialize_size += oneElementMetadata.computeMessageSize(fieldNumber: 10)
        }
        serialize_size += unknownFields.serializedSize()
        memoizedSerializedSize = serialize_size
        return serialize_size
    }
    public class func getBuilder() -> Subject.Builder {
        return Subject.classBuilder() as! Subject.Builder
    }
    public func getBuilder() -> Subject.Builder {
        return classBuilder() as! Subject.Builder
    }
    override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
        return Subject.Builder()
    }
    override public func classBuilder() -> ProtocolBuffersMessageBuilder {
        return Subject.Builder()
    }
    public func toBuilder() throws -> Subject.Builder {
        return try Subject.builderWithPrototype(prototype:self)
    }
    public class func builderWithPrototype(prototype:Subject) throws -> Subject.Builder {
        return try Subject.Builder().mergeFrom(other:prototype)
    }
    override public func encode() throws -> Dictionary<String,Any> {
        guard isInitialized() else {
            throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
        }

        var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
        if hasId {
            jsonMap["id"] = "\(id!)"
        }
        if hasUniversityId {
            jsonMap["universityId"] = "\(universityId!)"
        }
        if hasName {
            jsonMap["name"] = name
        }
        if hasNumber {
            jsonMap["number"] = number
        }
        if hasSeason {
            jsonMap["season"] = season
        }
        if hasYear {
            jsonMap["year"] = year
        }
        if hasTopicName {
            jsonMap["topicName"] = topicName
        }
        if hasTopicId {
            jsonMap["topicId"] = topicId
        }
        if !courses.isEmpty {
            var jsonArrayCourses:Array<Dictionary<String,Any>> = []
            for oneValueCourses in courses {
                let ecodedMessageCourses = try oneValueCourses.encode()
                jsonArrayCourses.append(ecodedMessageCourses)
            }
            jsonMap["courses"] = jsonArrayCourses
        }
        if !metadata.isEmpty {
            var jsonArrayMetadata:Array<Dictionary<String,Any>> = []
            for oneValueMetadata in metadata {
                let ecodedMessageMetadata = try oneValueMetadata.encode()
                jsonArrayMetadata.append(ecodedMessageMetadata)
            }
            jsonMap["metadata"] = jsonArrayMetadata
        }
        return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Subject {
        return try Subject.Builder.decodeToBuilder(jsonMap:jsonMap).build()
    }
    override class public func fromJSON(data:Data) throws -> Subject {
        return try Subject.Builder.fromJSONToBuilder(data:data).build()
    }
    override public func getDescription(indent:String) throws -> String {
        var output = ""
        if hasId {
            output += "\(indent) id: \(id) \n"
        }
        if hasUniversityId {
            output += "\(indent) universityId: \(universityId) \n"
        }
        if hasName {
            output += "\(indent) name: \(name) \n"
        }
        if hasNumber {
            output += "\(indent) number: \(number) \n"
        }
        if hasSeason {
            output += "\(indent) season: \(season) \n"
        }
        if hasYear {
            output += "\(indent) year: \(year) \n"
        }
        if hasTopicName {
            output += "\(indent) topicName: \(topicName) \n"
        }
        if hasTopicId {
            output += "\(indent) topicId: \(topicId) \n"
        }
        var coursesElementIndex:Int = 0
        for oneElementCourses in courses {
            output += "\(indent) courses[\(coursesElementIndex)] {\n"
            output += try oneElementCourses.getDescription(indent: "\(indent)  ")
            output += "\(indent)}\n"
            coursesElementIndex += 1
        }
        var metadataElementIndex:Int = 0
        for oneElementMetadata in metadata {
            output += "\(indent) metadata[\(metadataElementIndex)] {\n"
            output += try oneElementMetadata.getDescription(indent: "\(indent)  ")
            output += "\(indent)}\n"
            metadataElementIndex += 1
        }
        output += unknownFields.getDescription(indent: indent)
        return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasId {
                hashCode = (hashCode &* 31) &+ id.hashValue
            }
            if hasUniversityId {
                hashCode = (hashCode &* 31) &+ universityId.hashValue
            }
            if hasName {
                hashCode = (hashCode &* 31) &+ name.hashValue
            }
            if hasNumber {
                hashCode = (hashCode &* 31) &+ number.hashValue
            }
            if hasSeason {
                hashCode = (hashCode &* 31) &+ season.hashValue
            }
            if hasYear {
                hashCode = (hashCode &* 31) &+ year.hashValue
            }
            if hasTopicName {
                hashCode = (hashCode &* 31) &+ topicName.hashValue
            }
            if hasTopicId {
                hashCode = (hashCode &* 31) &+ topicId.hashValue
            }
            for oneElementCourses in courses {
                hashCode = (hashCode &* 31) &+ oneElementCourses.hashValue
            }
            for oneElementMetadata in metadata {
                hashCode = (hashCode &* 31) &+ oneElementMetadata.hashValue
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Subject"
    }
    override public func className() -> String {
        return "Subject"
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
        fileprivate var builderResult:Subject = Subject()
        public func getMessage() -> Subject {
            return builderResult
        }

        required override public init () {
            super.init()
        }
        public var id:Int64 {
            get {
                return builderResult.id
            }
            set (value) {
                builderResult.hasId = true
                builderResult.id = value
            }
        }
        public var hasId:Bool {
            get {
                return builderResult.hasId
            }
        }
        @discardableResult
        public func setId(_ value:Int64) -> Subject.Builder {
            self.id = value
            return self
        }
        @discardableResult
        public func clearId() -> Subject.Builder{
            builderResult.hasId = false
            builderResult.id = nil
            return self
        }
        public var universityId:Int64 {
            get {
                return builderResult.universityId
            }
            set (value) {
                builderResult.hasUniversityId = true
                builderResult.universityId = value
            }
        }
        public var hasUniversityId:Bool {
            get {
                return builderResult.hasUniversityId
            }
        }
        @discardableResult
        public func setUniversityId(_ value:Int64) -> Subject.Builder {
            self.universityId = value
            return self
        }
        @discardableResult
        public func clearUniversityId() -> Subject.Builder{
            builderResult.hasUniversityId = false
            builderResult.universityId = nil
            return self
        }
        public var name:String {
            get {
                return builderResult.name
            }
            set (value) {
                builderResult.hasName = true
                builderResult.name = value
            }
        }
        public var hasName:Bool {
            get {
                return builderResult.hasName
            }
        }
        @discardableResult
        public func setName(_ value:String) -> Subject.Builder {
            self.name = value
            return self
        }
        @discardableResult
        public func clearName() -> Subject.Builder{
            builderResult.hasName = false
            builderResult.name = nil
            return self
        }
        public var number:String {
            get {
                return builderResult.number
            }
            set (value) {
                builderResult.hasNumber = true
                builderResult.number = value
            }
        }
        public var hasNumber:Bool {
            get {
                return builderResult.hasNumber
            }
        }
        @discardableResult
        public func setNumber(_ value:String) -> Subject.Builder {
            self.number = value
            return self
        }
        @discardableResult
        public func clearNumber() -> Subject.Builder{
            builderResult.hasNumber = false
            builderResult.number = nil
            return self
        }
        public var season:String {
            get {
                return builderResult.season
            }
            set (value) {
                builderResult.hasSeason = true
                builderResult.season = value
            }
        }
        public var hasSeason:Bool {
            get {
                return builderResult.hasSeason
            }
        }
        @discardableResult
        public func setSeason(_ value:String) -> Subject.Builder {
            self.season = value
            return self
        }
        @discardableResult
        public func clearSeason() -> Subject.Builder{
            builderResult.hasSeason = false
            builderResult.season = nil
            return self
        }
        public var year:String {
            get {
                return builderResult.year
            }
            set (value) {
                builderResult.hasYear = true
                builderResult.year = value
            }
        }
        public var hasYear:Bool {
            get {
                return builderResult.hasYear
            }
        }
        @discardableResult
        public func setYear(_ value:String) -> Subject.Builder {
            self.year = value
            return self
        }
        @discardableResult
        public func clearYear() -> Subject.Builder{
            builderResult.hasYear = false
            builderResult.year = nil
            return self
        }
        public var topicName:String {
            get {
                return builderResult.topicName
            }
            set (value) {
                builderResult.hasTopicName = true
                builderResult.topicName = value
            }
        }
        public var hasTopicName:Bool {
            get {
                return builderResult.hasTopicName
            }
        }
        @discardableResult
        public func setTopicName(_ value:String) -> Subject.Builder {
            self.topicName = value
            return self
        }
        @discardableResult
        public func clearTopicName() -> Subject.Builder{
            builderResult.hasTopicName = false
            builderResult.topicName = nil
            return self
        }
        public var topicId:String {
            get {
                return builderResult.topicId
            }
            set (value) {
                builderResult.hasTopicId = true
                builderResult.topicId = value
            }
        }
        public var hasTopicId:Bool {
            get {
                return builderResult.hasTopicId
            }
        }
        @discardableResult
        public func setTopicId(_ value:String) -> Subject.Builder {
            self.topicId = value
            return self
        }
        @discardableResult
        public func clearTopicId() -> Subject.Builder{
            builderResult.hasTopicId = false
            builderResult.topicId = nil
            return self
        }
        public var courses:Array<Course> {
            get {
                return builderResult.courses
            }
            set (value) {
                builderResult.courses = value
            }
        }
        @discardableResult
        public func setCourses(_ value:Array<Course>) -> Subject.Builder {
            self.courses = value
            return self
        }
        @discardableResult
        public func clearCourses() -> Subject.Builder {
            builderResult.courses.removeAll(keepingCapacity: false)
            return self
        }
        public var metadata:Array<Metadata> {
            get {
                return builderResult.metadata
            }
            set (value) {
                builderResult.metadata = value
            }
        }
        @discardableResult
        public func setMetadata(_ value:Array<Metadata>) -> Subject.Builder {
            self.metadata = value
            return self
        }
        @discardableResult
        public func clearMetadata() -> Subject.Builder {
            builderResult.metadata.removeAll(keepingCapacity: false)
            return self
        }
        override public var internalGetResult:GeneratedMessage {
            get {
                return builderResult
            }
        }
        @discardableResult
        override public func clear() -> Subject.Builder {
            builderResult = Subject()
            return self
        }
        override public func clone() throws -> Subject.Builder {
            return try Subject.builderWithPrototype(prototype:builderResult)
        }
        override public func build() throws -> Subject {
            try checkInitialized()
            return buildPartial()
        }
        public func buildPartial() -> Subject {
            let returnMe:Subject = builderResult
            return returnMe
        }
        @discardableResult
        public func mergeFrom(other:Subject) throws -> Subject.Builder {
            if other == Subject() {
                return self
            }
            if other.hasId {
                id = other.id
            }
            if other.hasUniversityId {
                universityId = other.universityId
            }
            if other.hasName {
                name = other.name
            }
            if other.hasNumber {
                number = other.number
            }
            if other.hasSeason {
                season = other.season
            }
            if other.hasYear {
                year = other.year
            }
            if other.hasTopicName {
                topicName = other.topicName
            }
            if other.hasTopicId {
                topicId = other.topicId
            }
            if !other.courses.isEmpty  {
                 builderResult.courses += other.courses
            }
            if !other.metadata.isEmpty  {
                 builderResult.metadata += other.metadata
            }
            try merge(unknownField: other.unknownFields)
            return self
        }
        @discardableResult
        override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Subject.Builder {
            return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
        }
        @discardableResult
        override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Subject.Builder {
            let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
            while (true) {
                let protobufTag = try codedInputStream.readTag()
                switch protobufTag {
                case 0: 
                    self.unknownFields = try unknownFieldsBuilder.build()
                    return self

                case 8:
                    id = try codedInputStream.readInt64()

                case 16:
                    universityId = try codedInputStream.readInt64()

                case 26:
                    name = try codedInputStream.readString()

                case 34:
                    number = try codedInputStream.readString()

                case 42:
                    season = try codedInputStream.readString()

                case 50:
                    year = try codedInputStream.readString()

                case 58:
                    topicName = try codedInputStream.readString()

                case 66:
                    topicId = try codedInputStream.readString()

                case 74:
                    let subBuilder = Course.Builder()
                    try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
                    courses.append(subBuilder.buildPartial())

                case 82:
                    let subBuilder = Metadata.Builder()
                    try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
                    metadata.append(subBuilder.buildPartial())

                default:
                    if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                        unknownFields = try unknownFieldsBuilder.build()
                        return self
                    }
                }
            }
        }
        class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Subject.Builder {
            let resultDecodedBuilder = Subject.Builder()
            if let jsonValueId = jsonMap["id"] as? String {
                resultDecodedBuilder.id = Int64(jsonValueId)!
            } else if let jsonValueId = jsonMap["id"] as? Int {
                resultDecodedBuilder.id = Int64(jsonValueId)
            }
            if let jsonValueUniversityId = jsonMap["universityId"] as? String {
                resultDecodedBuilder.universityId = Int64(jsonValueUniversityId)!
            } else if let jsonValueUniversityId = jsonMap["universityId"] as? Int {
                resultDecodedBuilder.universityId = Int64(jsonValueUniversityId)
            }
            if let jsonValueName = jsonMap["name"] as? String {
                resultDecodedBuilder.name = jsonValueName
            }
            if let jsonValueNumber = jsonMap["number"] as? String {
                resultDecodedBuilder.number = jsonValueNumber
            }
            if let jsonValueSeason = jsonMap["season"] as? String {
                resultDecodedBuilder.season = jsonValueSeason
            }
            if let jsonValueYear = jsonMap["year"] as? String {
                resultDecodedBuilder.year = jsonValueYear
            }
            if let jsonValueTopicName = jsonMap["topicName"] as? String {
                resultDecodedBuilder.topicName = jsonValueTopicName
            }
            if let jsonValueTopicId = jsonMap["topicId"] as? String {
                resultDecodedBuilder.topicId = jsonValueTopicId
            }
            if let jsonValueCourses = jsonMap["courses"] as? Array<Dictionary<String,Any>> {
                var jsonArrayCourses:Array<Course> = []
                for oneValueCourses in jsonValueCourses {
                    let messageFromStringCourses = try Course.Builder.decodeToBuilder(jsonMap:oneValueCourses).build()

                    jsonArrayCourses.append(messageFromStringCourses)
                }
                resultDecodedBuilder.courses = jsonArrayCourses
            }
            if let jsonValueMetadata = jsonMap["metadata"] as? Array<Dictionary<String,Any>> {
                var jsonArrayMetadata:Array<Metadata> = []
                for oneValueMetadata in jsonValueMetadata {
                    let messageFromStringMetadata = try Metadata.Builder.decodeToBuilder(jsonMap:oneValueMetadata).build()

                    jsonArrayMetadata.append(messageFromStringMetadata)
                }
                resultDecodedBuilder.metadata = jsonArrayMetadata
            }
            return resultDecodedBuilder
        }
        override class public func fromJSONToBuilder(data:Data) throws -> Subject.Builder {
            let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
            guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
              throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
            }
            return try Subject.Builder.decodeToBuilder(jsonMap:jsDataCast)
        }
    }

}

final public class Course : GeneratedMessage {
    public typealias BuilderType = Course.Builder

    public static func == (lhs: Course, rhs: Course) -> Bool {
        if lhs === rhs {
            return true
        }
        var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
        fieldCheck = fieldCheck && (lhs.hasId == rhs.hasId) && (!lhs.hasId || lhs.id == rhs.id)
        fieldCheck = fieldCheck && (lhs.hasSubjectId == rhs.hasSubjectId) && (!lhs.hasSubjectId || lhs.subjectId == rhs.subjectId)
        fieldCheck = fieldCheck && (lhs.hasName == rhs.hasName) && (!lhs.hasName || lhs.name == rhs.name)
        fieldCheck = fieldCheck && (lhs.hasNumber == rhs.hasNumber) && (!lhs.hasNumber || lhs.number == rhs.number)
        fieldCheck = fieldCheck && (lhs.hasSynopsis == rhs.hasSynopsis) && (!lhs.hasSynopsis || lhs.synopsis == rhs.synopsis)
        fieldCheck = fieldCheck && (lhs.hasTopicName == rhs.hasTopicName) && (!lhs.hasTopicName || lhs.topicName == rhs.topicName)
        fieldCheck = fieldCheck && (lhs.hasTopicId == rhs.hasTopicId) && (!lhs.hasTopicId || lhs.topicId == rhs.topicId)
        fieldCheck = fieldCheck && (lhs.sections == rhs.sections)
        fieldCheck = fieldCheck && (lhs.metadata == rhs.metadata)
        fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
        return fieldCheck
    }

    public fileprivate(set) var id:Int64! = nil
    public fileprivate(set) var hasId:Bool = false

    public fileprivate(set) var subjectId:Int64! = nil
    public fileprivate(set) var hasSubjectId:Bool = false

    public fileprivate(set) var name:String! = nil
    public fileprivate(set) var hasName:Bool = false

    public fileprivate(set) var number:String! = nil
    public fileprivate(set) var hasNumber:Bool = false

    public fileprivate(set) var synopsis:String! = nil
    public fileprivate(set) var hasSynopsis:Bool = false

    public fileprivate(set) var topicName:String! = nil
    public fileprivate(set) var hasTopicName:Bool = false

    public fileprivate(set) var topicId:String! = nil
    public fileprivate(set) var hasTopicId:Bool = false

    public fileprivate(set) var sections:Array<Section>  = Array<Section>()
    public fileprivate(set) var metadata:Array<Metadata>  = Array<Metadata>()
    required public init() {
        super.init()
    }
    override public func isInitialized() -> Bool {
        return true
    }
    override public func writeTo(codedOutputStream: CodedOutputStream) throws {
        if hasId {
            try codedOutputStream.writeInt64(fieldNumber: 1, value:id)
        }
        if hasSubjectId {
            try codedOutputStream.writeInt64(fieldNumber: 2, value:subjectId)
        }
        if hasName {
            try codedOutputStream.writeString(fieldNumber: 3, value:name)
        }
        if hasNumber {
            try codedOutputStream.writeString(fieldNumber: 4, value:number)
        }
        if hasSynopsis {
            try codedOutputStream.writeString(fieldNumber: 5, value:synopsis)
        }
        if hasTopicName {
            try codedOutputStream.writeString(fieldNumber: 6, value:topicName)
        }
        if hasTopicId {
            try codedOutputStream.writeString(fieldNumber: 7, value:topicId)
        }
        for oneElementSections in sections {
              try codedOutputStream.writeMessage(fieldNumber: 8, value:oneElementSections)
        }
        for oneElementMetadata in metadata {
              try codedOutputStream.writeMessage(fieldNumber: 9, value:oneElementMetadata)
        }
        try unknownFields.writeTo(codedOutputStream: codedOutputStream)
    }
    override public func serializedSize() -> Int32 {
        var serialize_size:Int32 = memoizedSerializedSize
        if serialize_size != -1 {
         return serialize_size
        }

        serialize_size = 0
        if hasId {
            serialize_size += id.computeInt64Size(fieldNumber: 1)
        }
        if hasSubjectId {
            serialize_size += subjectId.computeInt64Size(fieldNumber: 2)
        }
        if hasName {
            serialize_size += name.computeStringSize(fieldNumber: 3)
        }
        if hasNumber {
            serialize_size += number.computeStringSize(fieldNumber: 4)
        }
        if hasSynopsis {
            serialize_size += synopsis.computeStringSize(fieldNumber: 5)
        }
        if hasTopicName {
            serialize_size += topicName.computeStringSize(fieldNumber: 6)
        }
        if hasTopicId {
            serialize_size += topicId.computeStringSize(fieldNumber: 7)
        }
        for oneElementSections in sections {
            serialize_size += oneElementSections.computeMessageSize(fieldNumber: 8)
        }
        for oneElementMetadata in metadata {
            serialize_size += oneElementMetadata.computeMessageSize(fieldNumber: 9)
        }
        serialize_size += unknownFields.serializedSize()
        memoizedSerializedSize = serialize_size
        return serialize_size
    }
    public class func getBuilder() -> Course.Builder {
        return Course.classBuilder() as! Course.Builder
    }
    public func getBuilder() -> Course.Builder {
        return classBuilder() as! Course.Builder
    }
    override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
        return Course.Builder()
    }
    override public func classBuilder() -> ProtocolBuffersMessageBuilder {
        return Course.Builder()
    }
    public func toBuilder() throws -> Course.Builder {
        return try Course.builderWithPrototype(prototype:self)
    }
    public class func builderWithPrototype(prototype:Course) throws -> Course.Builder {
        return try Course.Builder().mergeFrom(other:prototype)
    }
    override public func encode() throws -> Dictionary<String,Any> {
        guard isInitialized() else {
            throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
        }

        var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
        if hasId {
            jsonMap["id"] = "\(id!)"
        }
        if hasSubjectId {
            jsonMap["subjectId"] = "\(subjectId!)"
        }
        if hasName {
            jsonMap["name"] = name
        }
        if hasNumber {
            jsonMap["number"] = number
        }
        if hasSynopsis {
            jsonMap["synopsis"] = synopsis
        }
        if hasTopicName {
            jsonMap["topicName"] = topicName
        }
        if hasTopicId {
            jsonMap["topicId"] = topicId
        }
        if !sections.isEmpty {
            var jsonArraySections:Array<Dictionary<String,Any>> = []
            for oneValueSections in sections {
                let ecodedMessageSections = try oneValueSections.encode()
                jsonArraySections.append(ecodedMessageSections)
            }
            jsonMap["sections"] = jsonArraySections
        }
        if !metadata.isEmpty {
            var jsonArrayMetadata:Array<Dictionary<String,Any>> = []
            for oneValueMetadata in metadata {
                let ecodedMessageMetadata = try oneValueMetadata.encode()
                jsonArrayMetadata.append(ecodedMessageMetadata)
            }
            jsonMap["metadata"] = jsonArrayMetadata
        }
        return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Course {
        return try Course.Builder.decodeToBuilder(jsonMap:jsonMap).build()
    }
    override class public func fromJSON(data:Data) throws -> Course {
        return try Course.Builder.fromJSONToBuilder(data:data).build()
    }
    override public func getDescription(indent:String) throws -> String {
        var output = ""
        if hasId {
            output += "\(indent) id: \(id) \n"
        }
        if hasSubjectId {
            output += "\(indent) subjectId: \(subjectId) \n"
        }
        if hasName {
            output += "\(indent) name: \(name) \n"
        }
        if hasNumber {
            output += "\(indent) number: \(number) \n"
        }
        if hasSynopsis {
            output += "\(indent) synopsis: \(synopsis) \n"
        }
        if hasTopicName {
            output += "\(indent) topicName: \(topicName) \n"
        }
        if hasTopicId {
            output += "\(indent) topicId: \(topicId) \n"
        }
        var sectionsElementIndex:Int = 0
        for oneElementSections in sections {
            output += "\(indent) sections[\(sectionsElementIndex)] {\n"
            output += try oneElementSections.getDescription(indent: "\(indent)  ")
            output += "\(indent)}\n"
            sectionsElementIndex += 1
        }
        var metadataElementIndex:Int = 0
        for oneElementMetadata in metadata {
            output += "\(indent) metadata[\(metadataElementIndex)] {\n"
            output += try oneElementMetadata.getDescription(indent: "\(indent)  ")
            output += "\(indent)}\n"
            metadataElementIndex += 1
        }
        output += unknownFields.getDescription(indent: indent)
        return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasId {
                hashCode = (hashCode &* 31) &+ id.hashValue
            }
            if hasSubjectId {
                hashCode = (hashCode &* 31) &+ subjectId.hashValue
            }
            if hasName {
                hashCode = (hashCode &* 31) &+ name.hashValue
            }
            if hasNumber {
                hashCode = (hashCode &* 31) &+ number.hashValue
            }
            if hasSynopsis {
                hashCode = (hashCode &* 31) &+ synopsis.hashValue
            }
            if hasTopicName {
                hashCode = (hashCode &* 31) &+ topicName.hashValue
            }
            if hasTopicId {
                hashCode = (hashCode &* 31) &+ topicId.hashValue
            }
            for oneElementSections in sections {
                hashCode = (hashCode &* 31) &+ oneElementSections.hashValue
            }
            for oneElementMetadata in metadata {
                hashCode = (hashCode &* 31) &+ oneElementMetadata.hashValue
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Course"
    }
    override public func className() -> String {
        return "Course"
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
        fileprivate var builderResult:Course = Course()
        public func getMessage() -> Course {
            return builderResult
        }

        required override public init () {
            super.init()
        }
        public var id:Int64 {
            get {
                return builderResult.id
            }
            set (value) {
                builderResult.hasId = true
                builderResult.id = value
            }
        }
        public var hasId:Bool {
            get {
                return builderResult.hasId
            }
        }
        @discardableResult
        public func setId(_ value:Int64) -> Course.Builder {
            self.id = value
            return self
        }
        @discardableResult
        public func clearId() -> Course.Builder{
            builderResult.hasId = false
            builderResult.id = nil
            return self
        }
        public var subjectId:Int64 {
            get {
                return builderResult.subjectId
            }
            set (value) {
                builderResult.hasSubjectId = true
                builderResult.subjectId = value
            }
        }
        public var hasSubjectId:Bool {
            get {
                return builderResult.hasSubjectId
            }
        }
        @discardableResult
        public func setSubjectId(_ value:Int64) -> Course.Builder {
            self.subjectId = value
            return self
        }
        @discardableResult
        public func clearSubjectId() -> Course.Builder{
            builderResult.hasSubjectId = false
            builderResult.subjectId = nil
            return self
        }
        public var name:String {
            get {
                return builderResult.name
            }
            set (value) {
                builderResult.hasName = true
                builderResult.name = value
            }
        }
        public var hasName:Bool {
            get {
                return builderResult.hasName
            }
        }
        @discardableResult
        public func setName(_ value:String) -> Course.Builder {
            self.name = value
            return self
        }
        @discardableResult
        public func clearName() -> Course.Builder{
            builderResult.hasName = false
            builderResult.name = nil
            return self
        }
        public var number:String {
            get {
                return builderResult.number
            }
            set (value) {
                builderResult.hasNumber = true
                builderResult.number = value
            }
        }
        public var hasNumber:Bool {
            get {
                return builderResult.hasNumber
            }
        }
        @discardableResult
        public func setNumber(_ value:String) -> Course.Builder {
            self.number = value
            return self
        }
        @discardableResult
        public func clearNumber() -> Course.Builder{
            builderResult.hasNumber = false
            builderResult.number = nil
            return self
        }
        public var synopsis:String {
            get {
                return builderResult.synopsis
            }
            set (value) {
                builderResult.hasSynopsis = true
                builderResult.synopsis = value
            }
        }
        public var hasSynopsis:Bool {
            get {
                return builderResult.hasSynopsis
            }
        }
        @discardableResult
        public func setSynopsis(_ value:String) -> Course.Builder {
            self.synopsis = value
            return self
        }
        @discardableResult
        public func clearSynopsis() -> Course.Builder{
            builderResult.hasSynopsis = false
            builderResult.synopsis = nil
            return self
        }
        public var topicName:String {
            get {
                return builderResult.topicName
            }
            set (value) {
                builderResult.hasTopicName = true
                builderResult.topicName = value
            }
        }
        public var hasTopicName:Bool {
            get {
                return builderResult.hasTopicName
            }
        }
        @discardableResult
        public func setTopicName(_ value:String) -> Course.Builder {
            self.topicName = value
            return self
        }
        @discardableResult
        public func clearTopicName() -> Course.Builder{
            builderResult.hasTopicName = false
            builderResult.topicName = nil
            return self
        }
        public var topicId:String {
            get {
                return builderResult.topicId
            }
            set (value) {
                builderResult.hasTopicId = true
                builderResult.topicId = value
            }
        }
        public var hasTopicId:Bool {
            get {
                return builderResult.hasTopicId
            }
        }
        @discardableResult
        public func setTopicId(_ value:String) -> Course.Builder {
            self.topicId = value
            return self
        }
        @discardableResult
        public func clearTopicId() -> Course.Builder{
            builderResult.hasTopicId = false
            builderResult.topicId = nil
            return self
        }
        public var sections:Array<Section> {
            get {
                return builderResult.sections
            }
            set (value) {
                builderResult.sections = value
            }
        }
        @discardableResult
        public func setSections(_ value:Array<Section>) -> Course.Builder {
            self.sections = value
            return self
        }
        @discardableResult
        public func clearSections() -> Course.Builder {
            builderResult.sections.removeAll(keepingCapacity: false)
            return self
        }
        public var metadata:Array<Metadata> {
            get {
                return builderResult.metadata
            }
            set (value) {
                builderResult.metadata = value
            }
        }
        @discardableResult
        public func setMetadata(_ value:Array<Metadata>) -> Course.Builder {
            self.metadata = value
            return self
        }
        @discardableResult
        public func clearMetadata() -> Course.Builder {
            builderResult.metadata.removeAll(keepingCapacity: false)
            return self
        }
        override public var internalGetResult:GeneratedMessage {
            get {
                return builderResult
            }
        }
        @discardableResult
        override public func clear() -> Course.Builder {
            builderResult = Course()
            return self
        }
        override public func clone() throws -> Course.Builder {
            return try Course.builderWithPrototype(prototype:builderResult)
        }
        override public func build() throws -> Course {
            try checkInitialized()
            return buildPartial()
        }
        public func buildPartial() -> Course {
            let returnMe:Course = builderResult
            return returnMe
        }
        @discardableResult
        public func mergeFrom(other:Course) throws -> Course.Builder {
            if other == Course() {
                return self
            }
            if other.hasId {
                id = other.id
            }
            if other.hasSubjectId {
                subjectId = other.subjectId
            }
            if other.hasName {
                name = other.name
            }
            if other.hasNumber {
                number = other.number
            }
            if other.hasSynopsis {
                synopsis = other.synopsis
            }
            if other.hasTopicName {
                topicName = other.topicName
            }
            if other.hasTopicId {
                topicId = other.topicId
            }
            if !other.sections.isEmpty  {
                 builderResult.sections += other.sections
            }
            if !other.metadata.isEmpty  {
                 builderResult.metadata += other.metadata
            }
            try merge(unknownField: other.unknownFields)
            return self
        }
        @discardableResult
        override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Course.Builder {
            return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
        }
        @discardableResult
        override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Course.Builder {
            let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
            while (true) {
                let protobufTag = try codedInputStream.readTag()
                switch protobufTag {
                case 0: 
                    self.unknownFields = try unknownFieldsBuilder.build()
                    return self

                case 8:
                    id = try codedInputStream.readInt64()

                case 16:
                    subjectId = try codedInputStream.readInt64()

                case 26:
                    name = try codedInputStream.readString()

                case 34:
                    number = try codedInputStream.readString()

                case 42:
                    synopsis = try codedInputStream.readString()

                case 50:
                    topicName = try codedInputStream.readString()

                case 58:
                    topicId = try codedInputStream.readString()

                case 66:
                    let subBuilder = Section.Builder()
                    try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
                    sections.append(subBuilder.buildPartial())

                case 74:
                    let subBuilder = Metadata.Builder()
                    try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
                    metadata.append(subBuilder.buildPartial())

                default:
                    if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                        unknownFields = try unknownFieldsBuilder.build()
                        return self
                    }
                }
            }
        }
        class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Course.Builder {
            let resultDecodedBuilder = Course.Builder()
            if let jsonValueId = jsonMap["id"] as? String {
                resultDecodedBuilder.id = Int64(jsonValueId)!
            } else if let jsonValueId = jsonMap["id"] as? Int {
                resultDecodedBuilder.id = Int64(jsonValueId)
            }
            if let jsonValueSubjectId = jsonMap["subjectId"] as? String {
                resultDecodedBuilder.subjectId = Int64(jsonValueSubjectId)!
            } else if let jsonValueSubjectId = jsonMap["subjectId"] as? Int {
                resultDecodedBuilder.subjectId = Int64(jsonValueSubjectId)
            }
            if let jsonValueName = jsonMap["name"] as? String {
                resultDecodedBuilder.name = jsonValueName
            }
            if let jsonValueNumber = jsonMap["number"] as? String {
                resultDecodedBuilder.number = jsonValueNumber
            }
            if let jsonValueSynopsis = jsonMap["synopsis"] as? String {
                resultDecodedBuilder.synopsis = jsonValueSynopsis
            }
            if let jsonValueTopicName = jsonMap["topicName"] as? String {
                resultDecodedBuilder.topicName = jsonValueTopicName
            }
            if let jsonValueTopicId = jsonMap["topicId"] as? String {
                resultDecodedBuilder.topicId = jsonValueTopicId
            }
            if let jsonValueSections = jsonMap["sections"] as? Array<Dictionary<String,Any>> {
                var jsonArraySections:Array<Section> = []
                for oneValueSections in jsonValueSections {
                    let messageFromStringSections = try Section.Builder.decodeToBuilder(jsonMap:oneValueSections).build()

                    jsonArraySections.append(messageFromStringSections)
                }
                resultDecodedBuilder.sections = jsonArraySections
            }
            if let jsonValueMetadata = jsonMap["metadata"] as? Array<Dictionary<String,Any>> {
                var jsonArrayMetadata:Array<Metadata> = []
                for oneValueMetadata in jsonValueMetadata {
                    let messageFromStringMetadata = try Metadata.Builder.decodeToBuilder(jsonMap:oneValueMetadata).build()

                    jsonArrayMetadata.append(messageFromStringMetadata)
                }
                resultDecodedBuilder.metadata = jsonArrayMetadata
            }
            return resultDecodedBuilder
        }
        override class public func fromJSONToBuilder(data:Data) throws -> Course.Builder {
            let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
            guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
              throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
            }
            return try Course.Builder.decodeToBuilder(jsonMap:jsDataCast)
        }
    }

}

final public class Section : GeneratedMessage {
    public typealias BuilderType = Section.Builder

    public static func == (lhs: Section, rhs: Section) -> Bool {
        if lhs === rhs {
            return true
        }
        var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
        fieldCheck = fieldCheck && (lhs.hasId == rhs.hasId) && (!lhs.hasId || lhs.id == rhs.id)
        fieldCheck = fieldCheck && (lhs.hasCourseId == rhs.hasCourseId) && (!lhs.hasCourseId || lhs.courseId == rhs.courseId)
        fieldCheck = fieldCheck && (lhs.hasNumber == rhs.hasNumber) && (!lhs.hasNumber || lhs.number == rhs.number)
        fieldCheck = fieldCheck && (lhs.hasCallNumber == rhs.hasCallNumber) && (!lhs.hasCallNumber || lhs.callNumber == rhs.callNumber)
        fieldCheck = fieldCheck && (lhs.hasMax == rhs.hasMax) && (!lhs.hasMax || lhs.max == rhs.max)
        fieldCheck = fieldCheck && (lhs.hasNow == rhs.hasNow) && (!lhs.hasNow || lhs.now == rhs.now)
        fieldCheck = fieldCheck && (lhs.hasStatus == rhs.hasStatus) && (!lhs.hasStatus || lhs.status == rhs.status)
        fieldCheck = fieldCheck && (lhs.hasCredits == rhs.hasCredits) && (!lhs.hasCredits || lhs.credits == rhs.credits)
        fieldCheck = fieldCheck && (lhs.hasTopicName == rhs.hasTopicName) && (!lhs.hasTopicName || lhs.topicName == rhs.topicName)
        fieldCheck = fieldCheck && (lhs.hasTopicId == rhs.hasTopicId) && (!lhs.hasTopicId || lhs.topicId == rhs.topicId)
        fieldCheck = fieldCheck && (lhs.meetings == rhs.meetings)
        fieldCheck = fieldCheck && (lhs.instructors == rhs.instructors)
        fieldCheck = fieldCheck && (lhs.books == rhs.books)
        fieldCheck = fieldCheck && (lhs.metadata == rhs.metadata)
        fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
        return fieldCheck
    }

    public fileprivate(set) var id:Int64! = nil
    public fileprivate(set) var hasId:Bool = false

    public fileprivate(set) var courseId:Int64! = nil
    public fileprivate(set) var hasCourseId:Bool = false

    public fileprivate(set) var number:String! = nil
    public fileprivate(set) var hasNumber:Bool = false

    public fileprivate(set) var callNumber:String! = nil
    public fileprivate(set) var hasCallNumber:Bool = false

    public fileprivate(set) var max:Int64! = nil
    public fileprivate(set) var hasMax:Bool = false

    public fileprivate(set) var now:Int64! = nil
    public fileprivate(set) var hasNow:Bool = false

    public fileprivate(set) var status:String! = nil
    public fileprivate(set) var hasStatus:Bool = false

    public fileprivate(set) var credits:String! = nil
    public fileprivate(set) var hasCredits:Bool = false

    public fileprivate(set) var topicName:String! = nil
    public fileprivate(set) var hasTopicName:Bool = false

    public fileprivate(set) var topicId:String! = nil
    public fileprivate(set) var hasTopicId:Bool = false

    public fileprivate(set) var meetings:Array<Meeting>  = Array<Meeting>()
    public fileprivate(set) var instructors:Array<Instructor>  = Array<Instructor>()
    public fileprivate(set) var books:Array<Book>  = Array<Book>()
    public fileprivate(set) var metadata:Array<Metadata>  = Array<Metadata>()
    required public init() {
        super.init()
    }
    override public func isInitialized() -> Bool {
        return true
    }
    override public func writeTo(codedOutputStream: CodedOutputStream) throws {
        if hasId {
            try codedOutputStream.writeInt64(fieldNumber: 1, value:id)
        }
        if hasCourseId {
            try codedOutputStream.writeInt64(fieldNumber: 2, value:courseId)
        }
        if hasNumber {
            try codedOutputStream.writeString(fieldNumber: 3, value:number)
        }
        if hasCallNumber {
            try codedOutputStream.writeString(fieldNumber: 4, value:callNumber)
        }
        if hasMax {
            try codedOutputStream.writeInt64(fieldNumber: 5, value:max)
        }
        if hasNow {
            try codedOutputStream.writeInt64(fieldNumber: 6, value:now)
        }
        if hasStatus {
            try codedOutputStream.writeString(fieldNumber: 7, value:status)
        }
        if hasCredits {
            try codedOutputStream.writeString(fieldNumber: 8, value:credits)
        }
        if hasTopicName {
            try codedOutputStream.writeString(fieldNumber: 9, value:topicName)
        }
        if hasTopicId {
            try codedOutputStream.writeString(fieldNumber: 10, value:topicId)
        }
        for oneElementMeetings in meetings {
              try codedOutputStream.writeMessage(fieldNumber: 11, value:oneElementMeetings)
        }
        for oneElementInstructors in instructors {
              try codedOutputStream.writeMessage(fieldNumber: 12, value:oneElementInstructors)
        }
        for oneElementBooks in books {
              try codedOutputStream.writeMessage(fieldNumber: 13, value:oneElementBooks)
        }
        for oneElementMetadata in metadata {
              try codedOutputStream.writeMessage(fieldNumber: 14, value:oneElementMetadata)
        }
        try unknownFields.writeTo(codedOutputStream: codedOutputStream)
    }
    override public func serializedSize() -> Int32 {
        var serialize_size:Int32 = memoizedSerializedSize
        if serialize_size != -1 {
         return serialize_size
        }

        serialize_size = 0
        if hasId {
            serialize_size += id.computeInt64Size(fieldNumber: 1)
        }
        if hasCourseId {
            serialize_size += courseId.computeInt64Size(fieldNumber: 2)
        }
        if hasNumber {
            serialize_size += number.computeStringSize(fieldNumber: 3)
        }
        if hasCallNumber {
            serialize_size += callNumber.computeStringSize(fieldNumber: 4)
        }
        if hasMax {
            serialize_size += max.computeInt64Size(fieldNumber: 5)
        }
        if hasNow {
            serialize_size += now.computeInt64Size(fieldNumber: 6)
        }
        if hasStatus {
            serialize_size += status.computeStringSize(fieldNumber: 7)
        }
        if hasCredits {
            serialize_size += credits.computeStringSize(fieldNumber: 8)
        }
        if hasTopicName {
            serialize_size += topicName.computeStringSize(fieldNumber: 9)
        }
        if hasTopicId {
            serialize_size += topicId.computeStringSize(fieldNumber: 10)
        }
        for oneElementMeetings in meetings {
            serialize_size += oneElementMeetings.computeMessageSize(fieldNumber: 11)
        }
        for oneElementInstructors in instructors {
            serialize_size += oneElementInstructors.computeMessageSize(fieldNumber: 12)
        }
        for oneElementBooks in books {
            serialize_size += oneElementBooks.computeMessageSize(fieldNumber: 13)
        }
        for oneElementMetadata in metadata {
            serialize_size += oneElementMetadata.computeMessageSize(fieldNumber: 14)
        }
        serialize_size += unknownFields.serializedSize()
        memoizedSerializedSize = serialize_size
        return serialize_size
    }
    public class func getBuilder() -> Section.Builder {
        return Section.classBuilder() as! Section.Builder
    }
    public func getBuilder() -> Section.Builder {
        return classBuilder() as! Section.Builder
    }
    override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
        return Section.Builder()
    }
    override public func classBuilder() -> ProtocolBuffersMessageBuilder {
        return Section.Builder()
    }
    public func toBuilder() throws -> Section.Builder {
        return try Section.builderWithPrototype(prototype:self)
    }
    public class func builderWithPrototype(prototype:Section) throws -> Section.Builder {
        return try Section.Builder().mergeFrom(other:prototype)
    }
    override public func encode() throws -> Dictionary<String,Any> {
        guard isInitialized() else {
            throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
        }

        var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
        if hasId {
            jsonMap["id"] = "\(id!)"
        }
        if hasCourseId {
            jsonMap["courseId"] = "\(courseId!)"
        }
        if hasNumber {
            jsonMap["number"] = number
        }
        if hasCallNumber {
            jsonMap["callNumber"] = callNumber
        }
        if hasMax {
            jsonMap["max"] = "\(max!)"
        }
        if hasNow {
            jsonMap["now"] = "\(now!)"
        }
        if hasStatus {
            jsonMap["status"] = status
        }
        if hasCredits {
            jsonMap["credits"] = credits
        }
        if hasTopicName {
            jsonMap["topicName"] = topicName
        }
        if hasTopicId {
            jsonMap["topicId"] = topicId
        }
        if !meetings.isEmpty {
            var jsonArrayMeetings:Array<Dictionary<String,Any>> = []
            for oneValueMeetings in meetings {
                let ecodedMessageMeetings = try oneValueMeetings.encode()
                jsonArrayMeetings.append(ecodedMessageMeetings)
            }
            jsonMap["meetings"] = jsonArrayMeetings
        }
        if !instructors.isEmpty {
            var jsonArrayInstructors:Array<Dictionary<String,Any>> = []
            for oneValueInstructors in instructors {
                let ecodedMessageInstructors = try oneValueInstructors.encode()
                jsonArrayInstructors.append(ecodedMessageInstructors)
            }
            jsonMap["instructors"] = jsonArrayInstructors
        }
        if !books.isEmpty {
            var jsonArrayBooks:Array<Dictionary<String,Any>> = []
            for oneValueBooks in books {
                let ecodedMessageBooks = try oneValueBooks.encode()
                jsonArrayBooks.append(ecodedMessageBooks)
            }
            jsonMap["books"] = jsonArrayBooks
        }
        if !metadata.isEmpty {
            var jsonArrayMetadata:Array<Dictionary<String,Any>> = []
            for oneValueMetadata in metadata {
                let ecodedMessageMetadata = try oneValueMetadata.encode()
                jsonArrayMetadata.append(ecodedMessageMetadata)
            }
            jsonMap["metadata"] = jsonArrayMetadata
        }
        return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Section {
        return try Section.Builder.decodeToBuilder(jsonMap:jsonMap).build()
    }
    override class public func fromJSON(data:Data) throws -> Section {
        return try Section.Builder.fromJSONToBuilder(data:data).build()
    }
    override public func getDescription(indent:String) throws -> String {
        var output = ""
        if hasId {
            output += "\(indent) id: \(id) \n"
        }
        if hasCourseId {
            output += "\(indent) courseId: \(courseId) \n"
        }
        if hasNumber {
            output += "\(indent) number: \(number) \n"
        }
        if hasCallNumber {
            output += "\(indent) callNumber: \(callNumber) \n"
        }
        if hasMax {
            output += "\(indent) max: \(max) \n"
        }
        if hasNow {
            output += "\(indent) now: \(now) \n"
        }
        if hasStatus {
            output += "\(indent) status: \(status) \n"
        }
        if hasCredits {
            output += "\(indent) credits: \(credits) \n"
        }
        if hasTopicName {
            output += "\(indent) topicName: \(topicName) \n"
        }
        if hasTopicId {
            output += "\(indent) topicId: \(topicId) \n"
        }
        var meetingsElementIndex:Int = 0
        for oneElementMeetings in meetings {
            output += "\(indent) meetings[\(meetingsElementIndex)] {\n"
            output += try oneElementMeetings.getDescription(indent: "\(indent)  ")
            output += "\(indent)}\n"
            meetingsElementIndex += 1
        }
        var instructorsElementIndex:Int = 0
        for oneElementInstructors in instructors {
            output += "\(indent) instructors[\(instructorsElementIndex)] {\n"
            output += try oneElementInstructors.getDescription(indent: "\(indent)  ")
            output += "\(indent)}\n"
            instructorsElementIndex += 1
        }
        var booksElementIndex:Int = 0
        for oneElementBooks in books {
            output += "\(indent) books[\(booksElementIndex)] {\n"
            output += try oneElementBooks.getDescription(indent: "\(indent)  ")
            output += "\(indent)}\n"
            booksElementIndex += 1
        }
        var metadataElementIndex:Int = 0
        for oneElementMetadata in metadata {
            output += "\(indent) metadata[\(metadataElementIndex)] {\n"
            output += try oneElementMetadata.getDescription(indent: "\(indent)  ")
            output += "\(indent)}\n"
            metadataElementIndex += 1
        }
        output += unknownFields.getDescription(indent: indent)
        return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasId {
                hashCode = (hashCode &* 31) &+ id.hashValue
            }
            if hasCourseId {
                hashCode = (hashCode &* 31) &+ courseId.hashValue
            }
            if hasNumber {
                hashCode = (hashCode &* 31) &+ number.hashValue
            }
            if hasCallNumber {
                hashCode = (hashCode &* 31) &+ callNumber.hashValue
            }
            if hasMax {
                hashCode = (hashCode &* 31) &+ max.hashValue
            }
            if hasNow {
                hashCode = (hashCode &* 31) &+ now.hashValue
            }
            if hasStatus {
                hashCode = (hashCode &* 31) &+ status.hashValue
            }
            if hasCredits {
                hashCode = (hashCode &* 31) &+ credits.hashValue
            }
            if hasTopicName {
                hashCode = (hashCode &* 31) &+ topicName.hashValue
            }
            if hasTopicId {
                hashCode = (hashCode &* 31) &+ topicId.hashValue
            }
            for oneElementMeetings in meetings {
                hashCode = (hashCode &* 31) &+ oneElementMeetings.hashValue
            }
            for oneElementInstructors in instructors {
                hashCode = (hashCode &* 31) &+ oneElementInstructors.hashValue
            }
            for oneElementBooks in books {
                hashCode = (hashCode &* 31) &+ oneElementBooks.hashValue
            }
            for oneElementMetadata in metadata {
                hashCode = (hashCode &* 31) &+ oneElementMetadata.hashValue
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Section"
    }
    override public func className() -> String {
        return "Section"
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
        fileprivate var builderResult:Section = Section()
        public func getMessage() -> Section {
            return builderResult
        }

        required override public init () {
            super.init()
        }
        public var id:Int64 {
            get {
                return builderResult.id
            }
            set (value) {
                builderResult.hasId = true
                builderResult.id = value
            }
        }
        public var hasId:Bool {
            get {
                return builderResult.hasId
            }
        }
        @discardableResult
        public func setId(_ value:Int64) -> Section.Builder {
            self.id = value
            return self
        }
        @discardableResult
        public func clearId() -> Section.Builder{
            builderResult.hasId = false
            builderResult.id = nil
            return self
        }
        public var courseId:Int64 {
            get {
                return builderResult.courseId
            }
            set (value) {
                builderResult.hasCourseId = true
                builderResult.courseId = value
            }
        }
        public var hasCourseId:Bool {
            get {
                return builderResult.hasCourseId
            }
        }
        @discardableResult
        public func setCourseId(_ value:Int64) -> Section.Builder {
            self.courseId = value
            return self
        }
        @discardableResult
        public func clearCourseId() -> Section.Builder{
            builderResult.hasCourseId = false
            builderResult.courseId = nil
            return self
        }
        public var number:String {
            get {
                return builderResult.number
            }
            set (value) {
                builderResult.hasNumber = true
                builderResult.number = value
            }
        }
        public var hasNumber:Bool {
            get {
                return builderResult.hasNumber
            }
        }
        @discardableResult
        public func setNumber(_ value:String) -> Section.Builder {
            self.number = value
            return self
        }
        @discardableResult
        public func clearNumber() -> Section.Builder{
            builderResult.hasNumber = false
            builderResult.number = nil
            return self
        }
        public var callNumber:String {
            get {
                return builderResult.callNumber
            }
            set (value) {
                builderResult.hasCallNumber = true
                builderResult.callNumber = value
            }
        }
        public var hasCallNumber:Bool {
            get {
                return builderResult.hasCallNumber
            }
        }
        @discardableResult
        public func setCallNumber(_ value:String) -> Section.Builder {
            self.callNumber = value
            return self
        }
        @discardableResult
        public func clearCallNumber() -> Section.Builder{
            builderResult.hasCallNumber = false
            builderResult.callNumber = nil
            return self
        }
        public var max:Int64 {
            get {
                return builderResult.max
            }
            set (value) {
                builderResult.hasMax = true
                builderResult.max = value
            }
        }
        public var hasMax:Bool {
            get {
                return builderResult.hasMax
            }
        }
        @discardableResult
        public func setMax(_ value:Int64) -> Section.Builder {
            self.max = value
            return self
        }
        @discardableResult
        public func clearMax() -> Section.Builder{
            builderResult.hasMax = false
            builderResult.max = nil
            return self
        }
        public var now:Int64 {
            get {
                return builderResult.now
            }
            set (value) {
                builderResult.hasNow = true
                builderResult.now = value
            }
        }
        public var hasNow:Bool {
            get {
                return builderResult.hasNow
            }
        }
        @discardableResult
        public func setNow(_ value:Int64) -> Section.Builder {
            self.now = value
            return self
        }
        @discardableResult
        public func clearNow() -> Section.Builder{
            builderResult.hasNow = false
            builderResult.now = nil
            return self
        }
        public var status:String {
            get {
                return builderResult.status
            }
            set (value) {
                builderResult.hasStatus = true
                builderResult.status = value
            }
        }
        public var hasStatus:Bool {
            get {
                return builderResult.hasStatus
            }
        }
        @discardableResult
        public func setStatus(_ value:String) -> Section.Builder {
            self.status = value
            return self
        }
        @discardableResult
        public func clearStatus() -> Section.Builder{
            builderResult.hasStatus = false
            builderResult.status = nil
            return self
        }
        public var credits:String {
            get {
                return builderResult.credits
            }
            set (value) {
                builderResult.hasCredits = true
                builderResult.credits = value
            }
        }
        public var hasCredits:Bool {
            get {
                return builderResult.hasCredits
            }
        }
        @discardableResult
        public func setCredits(_ value:String) -> Section.Builder {
            self.credits = value
            return self
        }
        @discardableResult
        public func clearCredits() -> Section.Builder{
            builderResult.hasCredits = false
            builderResult.credits = nil
            return self
        }
        public var topicName:String {
            get {
                return builderResult.topicName
            }
            set (value) {
                builderResult.hasTopicName = true
                builderResult.topicName = value
            }
        }
        public var hasTopicName:Bool {
            get {
                return builderResult.hasTopicName
            }
        }
        @discardableResult
        public func setTopicName(_ value:String) -> Section.Builder {
            self.topicName = value
            return self
        }
        @discardableResult
        public func clearTopicName() -> Section.Builder{
            builderResult.hasTopicName = false
            builderResult.topicName = nil
            return self
        }
        public var topicId:String {
            get {
                return builderResult.topicId
            }
            set (value) {
                builderResult.hasTopicId = true
                builderResult.topicId = value
            }
        }
        public var hasTopicId:Bool {
            get {
                return builderResult.hasTopicId
            }
        }
        @discardableResult
        public func setTopicId(_ value:String) -> Section.Builder {
            self.topicId = value
            return self
        }
        @discardableResult
        public func clearTopicId() -> Section.Builder{
            builderResult.hasTopicId = false
            builderResult.topicId = nil
            return self
        }
        public var meetings:Array<Meeting> {
            get {
                return builderResult.meetings
            }
            set (value) {
                builderResult.meetings = value
            }
        }
        @discardableResult
        public func setMeetings(_ value:Array<Meeting>) -> Section.Builder {
            self.meetings = value
            return self
        }
        @discardableResult
        public func clearMeetings() -> Section.Builder {
            builderResult.meetings.removeAll(keepingCapacity: false)
            return self
        }
        public var instructors:Array<Instructor> {
            get {
                return builderResult.instructors
            }
            set (value) {
                builderResult.instructors = value
            }
        }
        @discardableResult
        public func setInstructors(_ value:Array<Instructor>) -> Section.Builder {
            self.instructors = value
            return self
        }
        @discardableResult
        public func clearInstructors() -> Section.Builder {
            builderResult.instructors.removeAll(keepingCapacity: false)
            return self
        }
        public var books:Array<Book> {
            get {
                return builderResult.books
            }
            set (value) {
                builderResult.books = value
            }
        }
        @discardableResult
        public func setBooks(_ value:Array<Book>) -> Section.Builder {
            self.books = value
            return self
        }
        @discardableResult
        public func clearBooks() -> Section.Builder {
            builderResult.books.removeAll(keepingCapacity: false)
            return self
        }
        public var metadata:Array<Metadata> {
            get {
                return builderResult.metadata
            }
            set (value) {
                builderResult.metadata = value
            }
        }
        @discardableResult
        public func setMetadata(_ value:Array<Metadata>) -> Section.Builder {
            self.metadata = value
            return self
        }
        @discardableResult
        public func clearMetadata() -> Section.Builder {
            builderResult.metadata.removeAll(keepingCapacity: false)
            return self
        }
        override public var internalGetResult:GeneratedMessage {
            get {
                return builderResult
            }
        }
        @discardableResult
        override public func clear() -> Section.Builder {
            builderResult = Section()
            return self
        }
        override public func clone() throws -> Section.Builder {
            return try Section.builderWithPrototype(prototype:builderResult)
        }
        override public func build() throws -> Section {
            try checkInitialized()
            return buildPartial()
        }
        public func buildPartial() -> Section {
            let returnMe:Section = builderResult
            return returnMe
        }
        @discardableResult
        public func mergeFrom(other:Section) throws -> Section.Builder {
            if other == Section() {
                return self
            }
            if other.hasId {
                id = other.id
            }
            if other.hasCourseId {
                courseId = other.courseId
            }
            if other.hasNumber {
                number = other.number
            }
            if other.hasCallNumber {
                callNumber = other.callNumber
            }
            if other.hasMax {
                max = other.max
            }
            if other.hasNow {
                now = other.now
            }
            if other.hasStatus {
                status = other.status
            }
            if other.hasCredits {
                credits = other.credits
            }
            if other.hasTopicName {
                topicName = other.topicName
            }
            if other.hasTopicId {
                topicId = other.topicId
            }
            if !other.meetings.isEmpty  {
                 builderResult.meetings += other.meetings
            }
            if !other.instructors.isEmpty  {
                 builderResult.instructors += other.instructors
            }
            if !other.books.isEmpty  {
                 builderResult.books += other.books
            }
            if !other.metadata.isEmpty  {
                 builderResult.metadata += other.metadata
            }
            try merge(unknownField: other.unknownFields)
            return self
        }
        @discardableResult
        override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Section.Builder {
            return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
        }
        @discardableResult
        override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Section.Builder {
            let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
            while (true) {
                let protobufTag = try codedInputStream.readTag()
                switch protobufTag {
                case 0: 
                    self.unknownFields = try unknownFieldsBuilder.build()
                    return self

                case 8:
                    id = try codedInputStream.readInt64()

                case 16:
                    courseId = try codedInputStream.readInt64()

                case 26:
                    number = try codedInputStream.readString()

                case 34:
                    callNumber = try codedInputStream.readString()

                case 40:
                    max = try codedInputStream.readInt64()

                case 48:
                    now = try codedInputStream.readInt64()

                case 58:
                    status = try codedInputStream.readString()

                case 66:
                    credits = try codedInputStream.readString()

                case 74:
                    topicName = try codedInputStream.readString()

                case 82:
                    topicId = try codedInputStream.readString()

                case 90:
                    let subBuilder = Meeting.Builder()
                    try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
                    meetings.append(subBuilder.buildPartial())

                case 98:
                    let subBuilder = Instructor.Builder()
                    try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
                    instructors.append(subBuilder.buildPartial())

                case 106:
                    let subBuilder = Book.Builder()
                    try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
                    books.append(subBuilder.buildPartial())

                case 114:
                    let subBuilder = Metadata.Builder()
                    try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
                    metadata.append(subBuilder.buildPartial())

                default:
                    if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                        unknownFields = try unknownFieldsBuilder.build()
                        return self
                    }
                }
            }
        }
        class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Section.Builder {
            let resultDecodedBuilder = Section.Builder()
            if let jsonValueId = jsonMap["id"] as? String {
                resultDecodedBuilder.id = Int64(jsonValueId)!
            } else if let jsonValueId = jsonMap["id"] as? Int {
                resultDecodedBuilder.id = Int64(jsonValueId)
            }
            if let jsonValueCourseId = jsonMap["courseId"] as? String {
                resultDecodedBuilder.courseId = Int64(jsonValueCourseId)!
            } else if let jsonValueCourseId = jsonMap["courseId"] as? Int {
                resultDecodedBuilder.courseId = Int64(jsonValueCourseId)
            }
            if let jsonValueNumber = jsonMap["number"] as? String {
                resultDecodedBuilder.number = jsonValueNumber
            }
            if let jsonValueCallNumber = jsonMap["callNumber"] as? String {
                resultDecodedBuilder.callNumber = jsonValueCallNumber
            }
            if let jsonValueMax = jsonMap["max"] as? String {
                resultDecodedBuilder.max = Int64(jsonValueMax)!
            } else if let jsonValueMax = jsonMap["max"] as? Int {
                resultDecodedBuilder.max = Int64(jsonValueMax)
            }
            if let jsonValueNow = jsonMap["now"] as? String {
                resultDecodedBuilder.now = Int64(jsonValueNow)!
            } else if let jsonValueNow = jsonMap["now"] as? Int {
                resultDecodedBuilder.now = Int64(jsonValueNow)
            }
            if let jsonValueStatus = jsonMap["status"] as? String {
                resultDecodedBuilder.status = jsonValueStatus
            }
            if let jsonValueCredits = jsonMap["credits"] as? String {
                resultDecodedBuilder.credits = jsonValueCredits
            }
            if let jsonValueTopicName = jsonMap["topicName"] as? String {
                resultDecodedBuilder.topicName = jsonValueTopicName
            }
            if let jsonValueTopicId = jsonMap["topicId"] as? String {
                resultDecodedBuilder.topicId = jsonValueTopicId
            }
            if let jsonValueMeetings = jsonMap["meetings"] as? Array<Dictionary<String,Any>> {
                var jsonArrayMeetings:Array<Meeting> = []
                for oneValueMeetings in jsonValueMeetings {
                    let messageFromStringMeetings = try Meeting.Builder.decodeToBuilder(jsonMap:oneValueMeetings).build()

                    jsonArrayMeetings.append(messageFromStringMeetings)
                }
                resultDecodedBuilder.meetings = jsonArrayMeetings
            }
            if let jsonValueInstructors = jsonMap["instructors"] as? Array<Dictionary<String,Any>> {
                var jsonArrayInstructors:Array<Instructor> = []
                for oneValueInstructors in jsonValueInstructors {
                    let messageFromStringInstructors = try Instructor.Builder.decodeToBuilder(jsonMap:oneValueInstructors).build()

                    jsonArrayInstructors.append(messageFromStringInstructors)
                }
                resultDecodedBuilder.instructors = jsonArrayInstructors
            }
            if let jsonValueBooks = jsonMap["books"] as? Array<Dictionary<String,Any>> {
                var jsonArrayBooks:Array<Book> = []
                for oneValueBooks in jsonValueBooks {
                    let messageFromStringBooks = try Book.Builder.decodeToBuilder(jsonMap:oneValueBooks).build()

                    jsonArrayBooks.append(messageFromStringBooks)
                }
                resultDecodedBuilder.books = jsonArrayBooks
            }
            if let jsonValueMetadata = jsonMap["metadata"] as? Array<Dictionary<String,Any>> {
                var jsonArrayMetadata:Array<Metadata> = []
                for oneValueMetadata in jsonValueMetadata {
                    let messageFromStringMetadata = try Metadata.Builder.decodeToBuilder(jsonMap:oneValueMetadata).build()

                    jsonArrayMetadata.append(messageFromStringMetadata)
                }
                resultDecodedBuilder.metadata = jsonArrayMetadata
            }
            return resultDecodedBuilder
        }
        override class public func fromJSONToBuilder(data:Data) throws -> Section.Builder {
            let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
            guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
              throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
            }
            return try Section.Builder.decodeToBuilder(jsonMap:jsDataCast)
        }
    }

}

final public class Meeting : GeneratedMessage {
    public typealias BuilderType = Meeting.Builder

    public static func == (lhs: Meeting, rhs: Meeting) -> Bool {
        if lhs === rhs {
            return true
        }
        var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
        fieldCheck = fieldCheck && (lhs.hasId == rhs.hasId) && (!lhs.hasId || lhs.id == rhs.id)
        fieldCheck = fieldCheck && (lhs.hasSectionId == rhs.hasSectionId) && (!lhs.hasSectionId || lhs.sectionId == rhs.sectionId)
        fieldCheck = fieldCheck && (lhs.hasRoom == rhs.hasRoom) && (!lhs.hasRoom || lhs.room == rhs.room)
        fieldCheck = fieldCheck && (lhs.hasDay == rhs.hasDay) && (!lhs.hasDay || lhs.day == rhs.day)
        fieldCheck = fieldCheck && (lhs.hasStartTime == rhs.hasStartTime) && (!lhs.hasStartTime || lhs.startTime == rhs.startTime)
        fieldCheck = fieldCheck && (lhs.hasEndTime == rhs.hasEndTime) && (!lhs.hasEndTime || lhs.endTime == rhs.endTime)
        fieldCheck = fieldCheck && (lhs.hasClassType == rhs.hasClassType) && (!lhs.hasClassType || lhs.classType == rhs.classType)
        fieldCheck = fieldCheck && (lhs.hasIndex == rhs.hasIndex) && (!lhs.hasIndex || lhs.index == rhs.index)
        fieldCheck = fieldCheck && (lhs.metadata == rhs.metadata)
        fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
        return fieldCheck
    }

    public fileprivate(set) var id:Int64! = nil
    public fileprivate(set) var hasId:Bool = false

    public fileprivate(set) var sectionId:Int64! = nil
    public fileprivate(set) var hasSectionId:Bool = false

    public fileprivate(set) var room:String! = nil
    public fileprivate(set) var hasRoom:Bool = false

    public fileprivate(set) var day:String! = nil
    public fileprivate(set) var hasDay:Bool = false

    public fileprivate(set) var startTime:String! = nil
    public fileprivate(set) var hasStartTime:Bool = false

    public fileprivate(set) var endTime:String! = nil
    public fileprivate(set) var hasEndTime:Bool = false

    public fileprivate(set) var classType:String! = nil
    public fileprivate(set) var hasClassType:Bool = false

    public fileprivate(set) var index:Int32! = nil
    public fileprivate(set) var hasIndex:Bool = false

    public fileprivate(set) var metadata:Array<Metadata>  = Array<Metadata>()
    required public init() {
        super.init()
    }
    override public func isInitialized() -> Bool {
        return true
    }
    override public func writeTo(codedOutputStream: CodedOutputStream) throws {
        if hasId {
            try codedOutputStream.writeInt64(fieldNumber: 1, value:id)
        }
        if hasSectionId {
            try codedOutputStream.writeInt64(fieldNumber: 2, value:sectionId)
        }
        if hasRoom {
            try codedOutputStream.writeString(fieldNumber: 3, value:room)
        }
        if hasDay {
            try codedOutputStream.writeString(fieldNumber: 4, value:day)
        }
        if hasStartTime {
            try codedOutputStream.writeString(fieldNumber: 5, value:startTime)
        }
        if hasEndTime {
            try codedOutputStream.writeString(fieldNumber: 6, value:endTime)
        }
        if hasClassType {
            try codedOutputStream.writeString(fieldNumber: 7, value:classType)
        }
        if hasIndex {
            try codedOutputStream.writeInt32(fieldNumber: 8, value:index)
        }
        for oneElementMetadata in metadata {
              try codedOutputStream.writeMessage(fieldNumber: 9, value:oneElementMetadata)
        }
        try unknownFields.writeTo(codedOutputStream: codedOutputStream)
    }
    override public func serializedSize() -> Int32 {
        var serialize_size:Int32 = memoizedSerializedSize
        if serialize_size != -1 {
         return serialize_size
        }

        serialize_size = 0
        if hasId {
            serialize_size += id.computeInt64Size(fieldNumber: 1)
        }
        if hasSectionId {
            serialize_size += sectionId.computeInt64Size(fieldNumber: 2)
        }
        if hasRoom {
            serialize_size += room.computeStringSize(fieldNumber: 3)
        }
        if hasDay {
            serialize_size += day.computeStringSize(fieldNumber: 4)
        }
        if hasStartTime {
            serialize_size += startTime.computeStringSize(fieldNumber: 5)
        }
        if hasEndTime {
            serialize_size += endTime.computeStringSize(fieldNumber: 6)
        }
        if hasClassType {
            serialize_size += classType.computeStringSize(fieldNumber: 7)
        }
        if hasIndex {
            serialize_size += index.computeInt32Size(fieldNumber: 8)
        }
        for oneElementMetadata in metadata {
            serialize_size += oneElementMetadata.computeMessageSize(fieldNumber: 9)
        }
        serialize_size += unknownFields.serializedSize()
        memoizedSerializedSize = serialize_size
        return serialize_size
    }
    public class func getBuilder() -> Meeting.Builder {
        return Meeting.classBuilder() as! Meeting.Builder
    }
    public func getBuilder() -> Meeting.Builder {
        return classBuilder() as! Meeting.Builder
    }
    override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
        return Meeting.Builder()
    }
    override public func classBuilder() -> ProtocolBuffersMessageBuilder {
        return Meeting.Builder()
    }
    public func toBuilder() throws -> Meeting.Builder {
        return try Meeting.builderWithPrototype(prototype:self)
    }
    public class func builderWithPrototype(prototype:Meeting) throws -> Meeting.Builder {
        return try Meeting.Builder().mergeFrom(other:prototype)
    }
    override public func encode() throws -> Dictionary<String,Any> {
        guard isInitialized() else {
            throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
        }

        var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
        if hasId {
            jsonMap["id"] = "\(id!)"
        }
        if hasSectionId {
            jsonMap["sectionId"] = "\(sectionId!)"
        }
        if hasRoom {
            jsonMap["room"] = room
        }
        if hasDay {
            jsonMap["day"] = day
        }
        if hasStartTime {
            jsonMap["startTime"] = startTime
        }
        if hasEndTime {
            jsonMap["endTime"] = endTime
        }
        if hasClassType {
            jsonMap["classType"] = classType
        }
        if hasIndex {
            jsonMap["index"] = Int(index)
        }
        if !metadata.isEmpty {
            var jsonArrayMetadata:Array<Dictionary<String,Any>> = []
            for oneValueMetadata in metadata {
                let ecodedMessageMetadata = try oneValueMetadata.encode()
                jsonArrayMetadata.append(ecodedMessageMetadata)
            }
            jsonMap["metadata"] = jsonArrayMetadata
        }
        return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Meeting {
        return try Meeting.Builder.decodeToBuilder(jsonMap:jsonMap).build()
    }
    override class public func fromJSON(data:Data) throws -> Meeting {
        return try Meeting.Builder.fromJSONToBuilder(data:data).build()
    }
    override public func getDescription(indent:String) throws -> String {
        var output = ""
        if hasId {
            output += "\(indent) id: \(id) \n"
        }
        if hasSectionId {
            output += "\(indent) sectionId: \(sectionId) \n"
        }
        if hasRoom {
            output += "\(indent) room: \(room) \n"
        }
        if hasDay {
            output += "\(indent) day: \(day) \n"
        }
        if hasStartTime {
            output += "\(indent) startTime: \(startTime) \n"
        }
        if hasEndTime {
            output += "\(indent) endTime: \(endTime) \n"
        }
        if hasClassType {
            output += "\(indent) classType: \(classType) \n"
        }
        if hasIndex {
            output += "\(indent) index: \(index) \n"
        }
        var metadataElementIndex:Int = 0
        for oneElementMetadata in metadata {
            output += "\(indent) metadata[\(metadataElementIndex)] {\n"
            output += try oneElementMetadata.getDescription(indent: "\(indent)  ")
            output += "\(indent)}\n"
            metadataElementIndex += 1
        }
        output += unknownFields.getDescription(indent: indent)
        return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasId {
                hashCode = (hashCode &* 31) &+ id.hashValue
            }
            if hasSectionId {
                hashCode = (hashCode &* 31) &+ sectionId.hashValue
            }
            if hasRoom {
                hashCode = (hashCode &* 31) &+ room.hashValue
            }
            if hasDay {
                hashCode = (hashCode &* 31) &+ day.hashValue
            }
            if hasStartTime {
                hashCode = (hashCode &* 31) &+ startTime.hashValue
            }
            if hasEndTime {
                hashCode = (hashCode &* 31) &+ endTime.hashValue
            }
            if hasClassType {
                hashCode = (hashCode &* 31) &+ classType.hashValue
            }
            if hasIndex {
                hashCode = (hashCode &* 31) &+ index.hashValue
            }
            for oneElementMetadata in metadata {
                hashCode = (hashCode &* 31) &+ oneElementMetadata.hashValue
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Meeting"
    }
    override public func className() -> String {
        return "Meeting"
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
        fileprivate var builderResult:Meeting = Meeting()
        public func getMessage() -> Meeting {
            return builderResult
        }

        required override public init () {
            super.init()
        }
        public var id:Int64 {
            get {
                return builderResult.id
            }
            set (value) {
                builderResult.hasId = true
                builderResult.id = value
            }
        }
        public var hasId:Bool {
            get {
                return builderResult.hasId
            }
        }
        @discardableResult
        public func setId(_ value:Int64) -> Meeting.Builder {
            self.id = value
            return self
        }
        @discardableResult
        public func clearId() -> Meeting.Builder{
            builderResult.hasId = false
            builderResult.id = nil
            return self
        }
        public var sectionId:Int64 {
            get {
                return builderResult.sectionId
            }
            set (value) {
                builderResult.hasSectionId = true
                builderResult.sectionId = value
            }
        }
        public var hasSectionId:Bool {
            get {
                return builderResult.hasSectionId
            }
        }
        @discardableResult
        public func setSectionId(_ value:Int64) -> Meeting.Builder {
            self.sectionId = value
            return self
        }
        @discardableResult
        public func clearSectionId() -> Meeting.Builder{
            builderResult.hasSectionId = false
            builderResult.sectionId = nil
            return self
        }
        public var room:String {
            get {
                return builderResult.room
            }
            set (value) {
                builderResult.hasRoom = true
                builderResult.room = value
            }
        }
        public var hasRoom:Bool {
            get {
                return builderResult.hasRoom
            }
        }
        @discardableResult
        public func setRoom(_ value:String) -> Meeting.Builder {
            self.room = value
            return self
        }
        @discardableResult
        public func clearRoom() -> Meeting.Builder{
            builderResult.hasRoom = false
            builderResult.room = nil
            return self
        }
        public var day:String {
            get {
                return builderResult.day
            }
            set (value) {
                builderResult.hasDay = true
                builderResult.day = value
            }
        }
        public var hasDay:Bool {
            get {
                return builderResult.hasDay
            }
        }
        @discardableResult
        public func setDay(_ value:String) -> Meeting.Builder {
            self.day = value
            return self
        }
        @discardableResult
        public func clearDay() -> Meeting.Builder{
            builderResult.hasDay = false
            builderResult.day = nil
            return self
        }
        public var startTime:String {
            get {
                return builderResult.startTime
            }
            set (value) {
                builderResult.hasStartTime = true
                builderResult.startTime = value
            }
        }
        public var hasStartTime:Bool {
            get {
                return builderResult.hasStartTime
            }
        }
        @discardableResult
        public func setStartTime(_ value:String) -> Meeting.Builder {
            self.startTime = value
            return self
        }
        @discardableResult
        public func clearStartTime() -> Meeting.Builder{
            builderResult.hasStartTime = false
            builderResult.startTime = nil
            return self
        }
        public var endTime:String {
            get {
                return builderResult.endTime
            }
            set (value) {
                builderResult.hasEndTime = true
                builderResult.endTime = value
            }
        }
        public var hasEndTime:Bool {
            get {
                return builderResult.hasEndTime
            }
        }
        @discardableResult
        public func setEndTime(_ value:String) -> Meeting.Builder {
            self.endTime = value
            return self
        }
        @discardableResult
        public func clearEndTime() -> Meeting.Builder{
            builderResult.hasEndTime = false
            builderResult.endTime = nil
            return self
        }
        public var classType:String {
            get {
                return builderResult.classType
            }
            set (value) {
                builderResult.hasClassType = true
                builderResult.classType = value
            }
        }
        public var hasClassType:Bool {
            get {
                return builderResult.hasClassType
            }
        }
        @discardableResult
        public func setClassType(_ value:String) -> Meeting.Builder {
            self.classType = value
            return self
        }
        @discardableResult
        public func clearClassType() -> Meeting.Builder{
            builderResult.hasClassType = false
            builderResult.classType = nil
            return self
        }
        public var index:Int32 {
            get {
                return builderResult.index
            }
            set (value) {
                builderResult.hasIndex = true
                builderResult.index = value
            }
        }
        public var hasIndex:Bool {
            get {
                return builderResult.hasIndex
            }
        }
        @discardableResult
        public func setIndex(_ value:Int32) -> Meeting.Builder {
            self.index = value
            return self
        }
        @discardableResult
        public func clearIndex() -> Meeting.Builder{
            builderResult.hasIndex = false
            builderResult.index = nil
            return self
        }
        public var metadata:Array<Metadata> {
            get {
                return builderResult.metadata
            }
            set (value) {
                builderResult.metadata = value
            }
        }
        @discardableResult
        public func setMetadata(_ value:Array<Metadata>) -> Meeting.Builder {
            self.metadata = value
            return self
        }
        @discardableResult
        public func clearMetadata() -> Meeting.Builder {
            builderResult.metadata.removeAll(keepingCapacity: false)
            return self
        }
        override public var internalGetResult:GeneratedMessage {
            get {
                return builderResult
            }
        }
        @discardableResult
        override public func clear() -> Meeting.Builder {
            builderResult = Meeting()
            return self
        }
        override public func clone() throws -> Meeting.Builder {
            return try Meeting.builderWithPrototype(prototype:builderResult)
        }
        override public func build() throws -> Meeting {
            try checkInitialized()
            return buildPartial()
        }
        public func buildPartial() -> Meeting {
            let returnMe:Meeting = builderResult
            return returnMe
        }
        @discardableResult
        public func mergeFrom(other:Meeting) throws -> Meeting.Builder {
            if other == Meeting() {
                return self
            }
            if other.hasId {
                id = other.id
            }
            if other.hasSectionId {
                sectionId = other.sectionId
            }
            if other.hasRoom {
                room = other.room
            }
            if other.hasDay {
                day = other.day
            }
            if other.hasStartTime {
                startTime = other.startTime
            }
            if other.hasEndTime {
                endTime = other.endTime
            }
            if other.hasClassType {
                classType = other.classType
            }
            if other.hasIndex {
                index = other.index
            }
            if !other.metadata.isEmpty  {
                 builderResult.metadata += other.metadata
            }
            try merge(unknownField: other.unknownFields)
            return self
        }
        @discardableResult
        override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Meeting.Builder {
            return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
        }
        @discardableResult
        override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Meeting.Builder {
            let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
            while (true) {
                let protobufTag = try codedInputStream.readTag()
                switch protobufTag {
                case 0: 
                    self.unknownFields = try unknownFieldsBuilder.build()
                    return self

                case 8:
                    id = try codedInputStream.readInt64()

                case 16:
                    sectionId = try codedInputStream.readInt64()

                case 26:
                    room = try codedInputStream.readString()

                case 34:
                    day = try codedInputStream.readString()

                case 42:
                    startTime = try codedInputStream.readString()

                case 50:
                    endTime = try codedInputStream.readString()

                case 58:
                    classType = try codedInputStream.readString()

                case 64:
                    index = try codedInputStream.readInt32()

                case 74:
                    let subBuilder = Metadata.Builder()
                    try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
                    metadata.append(subBuilder.buildPartial())

                default:
                    if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                        unknownFields = try unknownFieldsBuilder.build()
                        return self
                    }
                }
            }
        }
        class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Meeting.Builder {
            let resultDecodedBuilder = Meeting.Builder()
            if let jsonValueId = jsonMap["id"] as? String {
                resultDecodedBuilder.id = Int64(jsonValueId)!
            } else if let jsonValueId = jsonMap["id"] as? Int {
                resultDecodedBuilder.id = Int64(jsonValueId)
            }
            if let jsonValueSectionId = jsonMap["sectionId"] as? String {
                resultDecodedBuilder.sectionId = Int64(jsonValueSectionId)!
            } else if let jsonValueSectionId = jsonMap["sectionId"] as? Int {
                resultDecodedBuilder.sectionId = Int64(jsonValueSectionId)
            }
            if let jsonValueRoom = jsonMap["room"] as? String {
                resultDecodedBuilder.room = jsonValueRoom
            }
            if let jsonValueDay = jsonMap["day"] as? String {
                resultDecodedBuilder.day = jsonValueDay
            }
            if let jsonValueStartTime = jsonMap["startTime"] as? String {
                resultDecodedBuilder.startTime = jsonValueStartTime
            }
            if let jsonValueEndTime = jsonMap["endTime"] as? String {
                resultDecodedBuilder.endTime = jsonValueEndTime
            }
            if let jsonValueClassType = jsonMap["classType"] as? String {
                resultDecodedBuilder.classType = jsonValueClassType
            }
            if let jsonValueIndex = jsonMap["index"] as? Int {
                resultDecodedBuilder.index = Int32(jsonValueIndex)
            } else if let jsonValueIndex = jsonMap["index"] as? String {
                resultDecodedBuilder.index = Int32(jsonValueIndex)!
            }
            if let jsonValueMetadata = jsonMap["metadata"] as? Array<Dictionary<String,Any>> {
                var jsonArrayMetadata:Array<Metadata> = []
                for oneValueMetadata in jsonValueMetadata {
                    let messageFromStringMetadata = try Metadata.Builder.decodeToBuilder(jsonMap:oneValueMetadata).build()

                    jsonArrayMetadata.append(messageFromStringMetadata)
                }
                resultDecodedBuilder.metadata = jsonArrayMetadata
            }
            return resultDecodedBuilder
        }
        override class public func fromJSONToBuilder(data:Data) throws -> Meeting.Builder {
            let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
            guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
              throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
            }
            return try Meeting.Builder.decodeToBuilder(jsonMap:jsDataCast)
        }
    }

}

final public class Instructor : GeneratedMessage {
    public typealias BuilderType = Instructor.Builder

    public static func == (lhs: Instructor, rhs: Instructor) -> Bool {
        if lhs === rhs {
            return true
        }
        var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
        fieldCheck = fieldCheck && (lhs.hasId == rhs.hasId) && (!lhs.hasId || lhs.id == rhs.id)
        fieldCheck = fieldCheck && (lhs.hasSectionId == rhs.hasSectionId) && (!lhs.hasSectionId || lhs.sectionId == rhs.sectionId)
        fieldCheck = fieldCheck && (lhs.hasName == rhs.hasName) && (!lhs.hasName || lhs.name == rhs.name)
        fieldCheck = fieldCheck && (lhs.hasIndex == rhs.hasIndex) && (!lhs.hasIndex || lhs.index == rhs.index)
        fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
        return fieldCheck
    }

    public fileprivate(set) var id:Int64! = nil
    public fileprivate(set) var hasId:Bool = false

    public fileprivate(set) var sectionId:Int64! = nil
    public fileprivate(set) var hasSectionId:Bool = false

    public fileprivate(set) var name:String! = nil
    public fileprivate(set) var hasName:Bool = false

    public fileprivate(set) var index:Int32! = nil
    public fileprivate(set) var hasIndex:Bool = false

    required public init() {
        super.init()
    }
    override public func isInitialized() -> Bool {
        return true
    }
    override public func writeTo(codedOutputStream: CodedOutputStream) throws {
        if hasId {
            try codedOutputStream.writeInt64(fieldNumber: 1, value:id)
        }
        if hasSectionId {
            try codedOutputStream.writeInt64(fieldNumber: 2, value:sectionId)
        }
        if hasName {
            try codedOutputStream.writeString(fieldNumber: 3, value:name)
        }
        if hasIndex {
            try codedOutputStream.writeInt32(fieldNumber: 4, value:index)
        }
        try unknownFields.writeTo(codedOutputStream: codedOutputStream)
    }
    override public func serializedSize() -> Int32 {
        var serialize_size:Int32 = memoizedSerializedSize
        if serialize_size != -1 {
         return serialize_size
        }

        serialize_size = 0
        if hasId {
            serialize_size += id.computeInt64Size(fieldNumber: 1)
        }
        if hasSectionId {
            serialize_size += sectionId.computeInt64Size(fieldNumber: 2)
        }
        if hasName {
            serialize_size += name.computeStringSize(fieldNumber: 3)
        }
        if hasIndex {
            serialize_size += index.computeInt32Size(fieldNumber: 4)
        }
        serialize_size += unknownFields.serializedSize()
        memoizedSerializedSize = serialize_size
        return serialize_size
    }
    public class func getBuilder() -> Instructor.Builder {
        return Instructor.classBuilder() as! Instructor.Builder
    }
    public func getBuilder() -> Instructor.Builder {
        return classBuilder() as! Instructor.Builder
    }
    override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
        return Instructor.Builder()
    }
    override public func classBuilder() -> ProtocolBuffersMessageBuilder {
        return Instructor.Builder()
    }
    public func toBuilder() throws -> Instructor.Builder {
        return try Instructor.builderWithPrototype(prototype:self)
    }
    public class func builderWithPrototype(prototype:Instructor) throws -> Instructor.Builder {
        return try Instructor.Builder().mergeFrom(other:prototype)
    }
    override public func encode() throws -> Dictionary<String,Any> {
        guard isInitialized() else {
            throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
        }

        var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
        if hasId {
            jsonMap["id"] = "\(id!)"
        }
        if hasSectionId {
            jsonMap["sectionId"] = "\(sectionId!)"
        }
        if hasName {
            jsonMap["name"] = name
        }
        if hasIndex {
            jsonMap["index"] = Int(index)
        }
        return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Instructor {
        return try Instructor.Builder.decodeToBuilder(jsonMap:jsonMap).build()
    }
    override class public func fromJSON(data:Data) throws -> Instructor {
        return try Instructor.Builder.fromJSONToBuilder(data:data).build()
    }
    override public func getDescription(indent:String) throws -> String {
        var output = ""
        if hasId {
            output += "\(indent) id: \(id) \n"
        }
        if hasSectionId {
            output += "\(indent) sectionId: \(sectionId) \n"
        }
        if hasName {
            output += "\(indent) name: \(name) \n"
        }
        if hasIndex {
            output += "\(indent) index: \(index) \n"
        }
        output += unknownFields.getDescription(indent: indent)
        return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasId {
                hashCode = (hashCode &* 31) &+ id.hashValue
            }
            if hasSectionId {
                hashCode = (hashCode &* 31) &+ sectionId.hashValue
            }
            if hasName {
                hashCode = (hashCode &* 31) &+ name.hashValue
            }
            if hasIndex {
                hashCode = (hashCode &* 31) &+ index.hashValue
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Instructor"
    }
    override public func className() -> String {
        return "Instructor"
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
        fileprivate var builderResult:Instructor = Instructor()
        public func getMessage() -> Instructor {
            return builderResult
        }

        required override public init () {
            super.init()
        }
        public var id:Int64 {
            get {
                return builderResult.id
            }
            set (value) {
                builderResult.hasId = true
                builderResult.id = value
            }
        }
        public var hasId:Bool {
            get {
                return builderResult.hasId
            }
        }
        @discardableResult
        public func setId(_ value:Int64) -> Instructor.Builder {
            self.id = value
            return self
        }
        @discardableResult
        public func clearId() -> Instructor.Builder{
            builderResult.hasId = false
            builderResult.id = nil
            return self
        }
        public var sectionId:Int64 {
            get {
                return builderResult.sectionId
            }
            set (value) {
                builderResult.hasSectionId = true
                builderResult.sectionId = value
            }
        }
        public var hasSectionId:Bool {
            get {
                return builderResult.hasSectionId
            }
        }
        @discardableResult
        public func setSectionId(_ value:Int64) -> Instructor.Builder {
            self.sectionId = value
            return self
        }
        @discardableResult
        public func clearSectionId() -> Instructor.Builder{
            builderResult.hasSectionId = false
            builderResult.sectionId = nil
            return self
        }
        public var name:String {
            get {
                return builderResult.name
            }
            set (value) {
                builderResult.hasName = true
                builderResult.name = value
            }
        }
        public var hasName:Bool {
            get {
                return builderResult.hasName
            }
        }
        @discardableResult
        public func setName(_ value:String) -> Instructor.Builder {
            self.name = value
            return self
        }
        @discardableResult
        public func clearName() -> Instructor.Builder{
            builderResult.hasName = false
            builderResult.name = nil
            return self
        }
        public var index:Int32 {
            get {
                return builderResult.index
            }
            set (value) {
                builderResult.hasIndex = true
                builderResult.index = value
            }
        }
        public var hasIndex:Bool {
            get {
                return builderResult.hasIndex
            }
        }
        @discardableResult
        public func setIndex(_ value:Int32) -> Instructor.Builder {
            self.index = value
            return self
        }
        @discardableResult
        public func clearIndex() -> Instructor.Builder{
            builderResult.hasIndex = false
            builderResult.index = nil
            return self
        }
        override public var internalGetResult:GeneratedMessage {
            get {
                return builderResult
            }
        }
        @discardableResult
        override public func clear() -> Instructor.Builder {
            builderResult = Instructor()
            return self
        }
        override public func clone() throws -> Instructor.Builder {
            return try Instructor.builderWithPrototype(prototype:builderResult)
        }
        override public func build() throws -> Instructor {
            try checkInitialized()
            return buildPartial()
        }
        public func buildPartial() -> Instructor {
            let returnMe:Instructor = builderResult
            return returnMe
        }
        @discardableResult
        public func mergeFrom(other:Instructor) throws -> Instructor.Builder {
            if other == Instructor() {
                return self
            }
            if other.hasId {
                id = other.id
            }
            if other.hasSectionId {
                sectionId = other.sectionId
            }
            if other.hasName {
                name = other.name
            }
            if other.hasIndex {
                index = other.index
            }
            try merge(unknownField: other.unknownFields)
            return self
        }
        @discardableResult
        override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Instructor.Builder {
            return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
        }
        @discardableResult
        override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Instructor.Builder {
            let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
            while (true) {
                let protobufTag = try codedInputStream.readTag()
                switch protobufTag {
                case 0: 
                    self.unknownFields = try unknownFieldsBuilder.build()
                    return self

                case 8:
                    id = try codedInputStream.readInt64()

                case 16:
                    sectionId = try codedInputStream.readInt64()

                case 26:
                    name = try codedInputStream.readString()

                case 32:
                    index = try codedInputStream.readInt32()

                default:
                    if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                        unknownFields = try unknownFieldsBuilder.build()
                        return self
                    }
                }
            }
        }
        class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Instructor.Builder {
            let resultDecodedBuilder = Instructor.Builder()
            if let jsonValueId = jsonMap["id"] as? String {
                resultDecodedBuilder.id = Int64(jsonValueId)!
            } else if let jsonValueId = jsonMap["id"] as? Int {
                resultDecodedBuilder.id = Int64(jsonValueId)
            }
            if let jsonValueSectionId = jsonMap["sectionId"] as? String {
                resultDecodedBuilder.sectionId = Int64(jsonValueSectionId)!
            } else if let jsonValueSectionId = jsonMap["sectionId"] as? Int {
                resultDecodedBuilder.sectionId = Int64(jsonValueSectionId)
            }
            if let jsonValueName = jsonMap["name"] as? String {
                resultDecodedBuilder.name = jsonValueName
            }
            if let jsonValueIndex = jsonMap["index"] as? Int {
                resultDecodedBuilder.index = Int32(jsonValueIndex)
            } else if let jsonValueIndex = jsonMap["index"] as? String {
                resultDecodedBuilder.index = Int32(jsonValueIndex)!
            }
            return resultDecodedBuilder
        }
        override class public func fromJSONToBuilder(data:Data) throws -> Instructor.Builder {
            let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
            guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
              throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
            }
            return try Instructor.Builder.decodeToBuilder(jsonMap:jsDataCast)
        }
    }

}

final public class Book : GeneratedMessage {
    public typealias BuilderType = Book.Builder

    public static func == (lhs: Book, rhs: Book) -> Bool {
        if lhs === rhs {
            return true
        }
        var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
        fieldCheck = fieldCheck && (lhs.hasId == rhs.hasId) && (!lhs.hasId || lhs.id == rhs.id)
        fieldCheck = fieldCheck && (lhs.hasSectionId == rhs.hasSectionId) && (!lhs.hasSectionId || lhs.sectionId == rhs.sectionId)
        fieldCheck = fieldCheck && (lhs.hasTitle == rhs.hasTitle) && (!lhs.hasTitle || lhs.title == rhs.title)
        fieldCheck = fieldCheck && (lhs.hasUrl == rhs.hasUrl) && (!lhs.hasUrl || lhs.url == rhs.url)
        fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
        return fieldCheck
    }

    public fileprivate(set) var id:Int64! = nil
    public fileprivate(set) var hasId:Bool = false

    public fileprivate(set) var sectionId:Int64! = nil
    public fileprivate(set) var hasSectionId:Bool = false

    public fileprivate(set) var title:String! = nil
    public fileprivate(set) var hasTitle:Bool = false

    public fileprivate(set) var url:String! = nil
    public fileprivate(set) var hasUrl:Bool = false

    required public init() {
        super.init()
    }
    override public func isInitialized() -> Bool {
        return true
    }
    override public func writeTo(codedOutputStream: CodedOutputStream) throws {
        if hasId {
            try codedOutputStream.writeInt64(fieldNumber: 1, value:id)
        }
        if hasSectionId {
            try codedOutputStream.writeInt64(fieldNumber: 2, value:sectionId)
        }
        if hasTitle {
            try codedOutputStream.writeString(fieldNumber: 3, value:title)
        }
        if hasUrl {
            try codedOutputStream.writeString(fieldNumber: 4, value:url)
        }
        try unknownFields.writeTo(codedOutputStream: codedOutputStream)
    }
    override public func serializedSize() -> Int32 {
        var serialize_size:Int32 = memoizedSerializedSize
        if serialize_size != -1 {
         return serialize_size
        }

        serialize_size = 0
        if hasId {
            serialize_size += id.computeInt64Size(fieldNumber: 1)
        }
        if hasSectionId {
            serialize_size += sectionId.computeInt64Size(fieldNumber: 2)
        }
        if hasTitle {
            serialize_size += title.computeStringSize(fieldNumber: 3)
        }
        if hasUrl {
            serialize_size += url.computeStringSize(fieldNumber: 4)
        }
        serialize_size += unknownFields.serializedSize()
        memoizedSerializedSize = serialize_size
        return serialize_size
    }
    public class func getBuilder() -> Book.Builder {
        return Book.classBuilder() as! Book.Builder
    }
    public func getBuilder() -> Book.Builder {
        return classBuilder() as! Book.Builder
    }
    override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
        return Book.Builder()
    }
    override public func classBuilder() -> ProtocolBuffersMessageBuilder {
        return Book.Builder()
    }
    public func toBuilder() throws -> Book.Builder {
        return try Book.builderWithPrototype(prototype:self)
    }
    public class func builderWithPrototype(prototype:Book) throws -> Book.Builder {
        return try Book.Builder().mergeFrom(other:prototype)
    }
    override public func encode() throws -> Dictionary<String,Any> {
        guard isInitialized() else {
            throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
        }

        var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
        if hasId {
            jsonMap["id"] = "\(id!)"
        }
        if hasSectionId {
            jsonMap["sectionId"] = "\(sectionId!)"
        }
        if hasTitle {
            jsonMap["title"] = title
        }
        if hasUrl {
            jsonMap["url"] = url
        }
        return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Book {
        return try Book.Builder.decodeToBuilder(jsonMap:jsonMap).build()
    }
    override class public func fromJSON(data:Data) throws -> Book {
        return try Book.Builder.fromJSONToBuilder(data:data).build()
    }
    override public func getDescription(indent:String) throws -> String {
        var output = ""
        if hasId {
            output += "\(indent) id: \(id) \n"
        }
        if hasSectionId {
            output += "\(indent) sectionId: \(sectionId) \n"
        }
        if hasTitle {
            output += "\(indent) title: \(title) \n"
        }
        if hasUrl {
            output += "\(indent) url: \(url) \n"
        }
        output += unknownFields.getDescription(indent: indent)
        return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasId {
                hashCode = (hashCode &* 31) &+ id.hashValue
            }
            if hasSectionId {
                hashCode = (hashCode &* 31) &+ sectionId.hashValue
            }
            if hasTitle {
                hashCode = (hashCode &* 31) &+ title.hashValue
            }
            if hasUrl {
                hashCode = (hashCode &* 31) &+ url.hashValue
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Book"
    }
    override public func className() -> String {
        return "Book"
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
        fileprivate var builderResult:Book = Book()
        public func getMessage() -> Book {
            return builderResult
        }

        required override public init () {
            super.init()
        }
        public var id:Int64 {
            get {
                return builderResult.id
            }
            set (value) {
                builderResult.hasId = true
                builderResult.id = value
            }
        }
        public var hasId:Bool {
            get {
                return builderResult.hasId
            }
        }
        @discardableResult
        public func setId(_ value:Int64) -> Book.Builder {
            self.id = value
            return self
        }
        @discardableResult
        public func clearId() -> Book.Builder{
            builderResult.hasId = false
            builderResult.id = nil
            return self
        }
        public var sectionId:Int64 {
            get {
                return builderResult.sectionId
            }
            set (value) {
                builderResult.hasSectionId = true
                builderResult.sectionId = value
            }
        }
        public var hasSectionId:Bool {
            get {
                return builderResult.hasSectionId
            }
        }
        @discardableResult
        public func setSectionId(_ value:Int64) -> Book.Builder {
            self.sectionId = value
            return self
        }
        @discardableResult
        public func clearSectionId() -> Book.Builder{
            builderResult.hasSectionId = false
            builderResult.sectionId = nil
            return self
        }
        public var title:String {
            get {
                return builderResult.title
            }
            set (value) {
                builderResult.hasTitle = true
                builderResult.title = value
            }
        }
        public var hasTitle:Bool {
            get {
                return builderResult.hasTitle
            }
        }
        @discardableResult
        public func setTitle(_ value:String) -> Book.Builder {
            self.title = value
            return self
        }
        @discardableResult
        public func clearTitle() -> Book.Builder{
            builderResult.hasTitle = false
            builderResult.title = nil
            return self
        }
        public var url:String {
            get {
                return builderResult.url
            }
            set (value) {
                builderResult.hasUrl = true
                builderResult.url = value
            }
        }
        public var hasUrl:Bool {
            get {
                return builderResult.hasUrl
            }
        }
        @discardableResult
        public func setUrl(_ value:String) -> Book.Builder {
            self.url = value
            return self
        }
        @discardableResult
        public func clearUrl() -> Book.Builder{
            builderResult.hasUrl = false
            builderResult.url = nil
            return self
        }
        override public var internalGetResult:GeneratedMessage {
            get {
                return builderResult
            }
        }
        @discardableResult
        override public func clear() -> Book.Builder {
            builderResult = Book()
            return self
        }
        override public func clone() throws -> Book.Builder {
            return try Book.builderWithPrototype(prototype:builderResult)
        }
        override public func build() throws -> Book {
            try checkInitialized()
            return buildPartial()
        }
        public func buildPartial() -> Book {
            let returnMe:Book = builderResult
            return returnMe
        }
        @discardableResult
        public func mergeFrom(other:Book) throws -> Book.Builder {
            if other == Book() {
                return self
            }
            if other.hasId {
                id = other.id
            }
            if other.hasSectionId {
                sectionId = other.sectionId
            }
            if other.hasTitle {
                title = other.title
            }
            if other.hasUrl {
                url = other.url
            }
            try merge(unknownField: other.unknownFields)
            return self
        }
        @discardableResult
        override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Book.Builder {
            return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
        }
        @discardableResult
        override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Book.Builder {
            let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
            while (true) {
                let protobufTag = try codedInputStream.readTag()
                switch protobufTag {
                case 0: 
                    self.unknownFields = try unknownFieldsBuilder.build()
                    return self

                case 8:
                    id = try codedInputStream.readInt64()

                case 16:
                    sectionId = try codedInputStream.readInt64()

                case 26:
                    title = try codedInputStream.readString()

                case 34:
                    url = try codedInputStream.readString()

                default:
                    if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                        unknownFields = try unknownFieldsBuilder.build()
                        return self
                    }
                }
            }
        }
        class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Book.Builder {
            let resultDecodedBuilder = Book.Builder()
            if let jsonValueId = jsonMap["id"] as? String {
                resultDecodedBuilder.id = Int64(jsonValueId)!
            } else if let jsonValueId = jsonMap["id"] as? Int {
                resultDecodedBuilder.id = Int64(jsonValueId)
            }
            if let jsonValueSectionId = jsonMap["sectionId"] as? String {
                resultDecodedBuilder.sectionId = Int64(jsonValueSectionId)!
            } else if let jsonValueSectionId = jsonMap["sectionId"] as? Int {
                resultDecodedBuilder.sectionId = Int64(jsonValueSectionId)
            }
            if let jsonValueTitle = jsonMap["title"] as? String {
                resultDecodedBuilder.title = jsonValueTitle
            }
            if let jsonValueUrl = jsonMap["url"] as? String {
                resultDecodedBuilder.url = jsonValueUrl
            }
            return resultDecodedBuilder
        }
        override class public func fromJSONToBuilder(data:Data) throws -> Book.Builder {
            let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
            guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
              throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
            }
            return try Book.Builder.decodeToBuilder(jsonMap:jsDataCast)
        }
    }

}

final public class Metadata : GeneratedMessage {
    public typealias BuilderType = Metadata.Builder

    public static func == (lhs: Metadata, rhs: Metadata) -> Bool {
        if lhs === rhs {
            return true
        }
        var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
        fieldCheck = fieldCheck && (lhs.hasId == rhs.hasId) && (!lhs.hasId || lhs.id == rhs.id)
        fieldCheck = fieldCheck && (lhs.hasUniversityId == rhs.hasUniversityId) && (!lhs.hasUniversityId || lhs.universityId == rhs.universityId)
        fieldCheck = fieldCheck && (lhs.hasSubjectId == rhs.hasSubjectId) && (!lhs.hasSubjectId || lhs.subjectId == rhs.subjectId)
        fieldCheck = fieldCheck && (lhs.hasCourseId == rhs.hasCourseId) && (!lhs.hasCourseId || lhs.courseId == rhs.courseId)
        fieldCheck = fieldCheck && (lhs.hasSectionId == rhs.hasSectionId) && (!lhs.hasSectionId || lhs.sectionId == rhs.sectionId)
        fieldCheck = fieldCheck && (lhs.hasMeetingId == rhs.hasMeetingId) && (!lhs.hasMeetingId || lhs.meetingId == rhs.meetingId)
        fieldCheck = fieldCheck && (lhs.hasTitle == rhs.hasTitle) && (!lhs.hasTitle || lhs.title == rhs.title)
        fieldCheck = fieldCheck && (lhs.hasContent == rhs.hasContent) && (!lhs.hasContent || lhs.content == rhs.content)
        fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
        return fieldCheck
    }

    public fileprivate(set) var id:Int64! = nil
    public fileprivate(set) var hasId:Bool = false

    public fileprivate(set) var universityId:Int64! = nil
    public fileprivate(set) var hasUniversityId:Bool = false

    public fileprivate(set) var subjectId:Int64! = nil
    public fileprivate(set) var hasSubjectId:Bool = false

    public fileprivate(set) var courseId:Int64! = nil
    public fileprivate(set) var hasCourseId:Bool = false

    public fileprivate(set) var sectionId:Int64! = nil
    public fileprivate(set) var hasSectionId:Bool = false

    public fileprivate(set) var meetingId:Int64! = nil
    public fileprivate(set) var hasMeetingId:Bool = false

    public fileprivate(set) var title:String! = nil
    public fileprivate(set) var hasTitle:Bool = false

    public fileprivate(set) var content:String! = nil
    public fileprivate(set) var hasContent:Bool = false

    required public init() {
        super.init()
    }
    override public func isInitialized() -> Bool {
        return true
    }
    override public func writeTo(codedOutputStream: CodedOutputStream) throws {
        if hasId {
            try codedOutputStream.writeInt64(fieldNumber: 1, value:id)
        }
        if hasUniversityId {
            try codedOutputStream.writeInt64(fieldNumber: 2, value:universityId)
        }
        if hasSubjectId {
            try codedOutputStream.writeInt64(fieldNumber: 3, value:subjectId)
        }
        if hasCourseId {
            try codedOutputStream.writeInt64(fieldNumber: 4, value:courseId)
        }
        if hasSectionId {
            try codedOutputStream.writeInt64(fieldNumber: 5, value:sectionId)
        }
        if hasMeetingId {
            try codedOutputStream.writeInt64(fieldNumber: 6, value:meetingId)
        }
        if hasTitle {
            try codedOutputStream.writeString(fieldNumber: 7, value:title)
        }
        if hasContent {
            try codedOutputStream.writeString(fieldNumber: 8, value:content)
        }
        try unknownFields.writeTo(codedOutputStream: codedOutputStream)
    }
    override public func serializedSize() -> Int32 {
        var serialize_size:Int32 = memoizedSerializedSize
        if serialize_size != -1 {
         return serialize_size
        }

        serialize_size = 0
        if hasId {
            serialize_size += id.computeInt64Size(fieldNumber: 1)
        }
        if hasUniversityId {
            serialize_size += universityId.computeInt64Size(fieldNumber: 2)
        }
        if hasSubjectId {
            serialize_size += subjectId.computeInt64Size(fieldNumber: 3)
        }
        if hasCourseId {
            serialize_size += courseId.computeInt64Size(fieldNumber: 4)
        }
        if hasSectionId {
            serialize_size += sectionId.computeInt64Size(fieldNumber: 5)
        }
        if hasMeetingId {
            serialize_size += meetingId.computeInt64Size(fieldNumber: 6)
        }
        if hasTitle {
            serialize_size += title.computeStringSize(fieldNumber: 7)
        }
        if hasContent {
            serialize_size += content.computeStringSize(fieldNumber: 8)
        }
        serialize_size += unknownFields.serializedSize()
        memoizedSerializedSize = serialize_size
        return serialize_size
    }
    public class func getBuilder() -> Metadata.Builder {
        return Metadata.classBuilder() as! Metadata.Builder
    }
    public func getBuilder() -> Metadata.Builder {
        return classBuilder() as! Metadata.Builder
    }
    override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
        return Metadata.Builder()
    }
    override public func classBuilder() -> ProtocolBuffersMessageBuilder {
        return Metadata.Builder()
    }
    public func toBuilder() throws -> Metadata.Builder {
        return try Metadata.builderWithPrototype(prototype:self)
    }
    public class func builderWithPrototype(prototype:Metadata) throws -> Metadata.Builder {
        return try Metadata.Builder().mergeFrom(other:prototype)
    }
    override public func encode() throws -> Dictionary<String,Any> {
        guard isInitialized() else {
            throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
        }

        var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
        if hasId {
            jsonMap["id"] = "\(id!)"
        }
        if hasUniversityId {
            jsonMap["universityId"] = "\(universityId!)"
        }
        if hasSubjectId {
            jsonMap["subjectId"] = "\(subjectId!)"
        }
        if hasCourseId {
            jsonMap["courseId"] = "\(courseId!)"
        }
        if hasSectionId {
            jsonMap["sectionId"] = "\(sectionId!)"
        }
        if hasMeetingId {
            jsonMap["meetingId"] = "\(meetingId!)"
        }
        if hasTitle {
            jsonMap["title"] = title
        }
        if hasContent {
            jsonMap["content"] = content
        }
        return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Metadata {
        return try Metadata.Builder.decodeToBuilder(jsonMap:jsonMap).build()
    }
    override class public func fromJSON(data:Data) throws -> Metadata {
        return try Metadata.Builder.fromJSONToBuilder(data:data).build()
    }
    override public func getDescription(indent:String) throws -> String {
        var output = ""
        if hasId {
            output += "\(indent) id: \(id) \n"
        }
        if hasUniversityId {
            output += "\(indent) universityId: \(universityId) \n"
        }
        if hasSubjectId {
            output += "\(indent) subjectId: \(subjectId) \n"
        }
        if hasCourseId {
            output += "\(indent) courseId: \(courseId) \n"
        }
        if hasSectionId {
            output += "\(indent) sectionId: \(sectionId) \n"
        }
        if hasMeetingId {
            output += "\(indent) meetingId: \(meetingId) \n"
        }
        if hasTitle {
            output += "\(indent) title: \(title) \n"
        }
        if hasContent {
            output += "\(indent) content: \(content) \n"
        }
        output += unknownFields.getDescription(indent: indent)
        return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasId {
                hashCode = (hashCode &* 31) &+ id.hashValue
            }
            if hasUniversityId {
                hashCode = (hashCode &* 31) &+ universityId.hashValue
            }
            if hasSubjectId {
                hashCode = (hashCode &* 31) &+ subjectId.hashValue
            }
            if hasCourseId {
                hashCode = (hashCode &* 31) &+ courseId.hashValue
            }
            if hasSectionId {
                hashCode = (hashCode &* 31) &+ sectionId.hashValue
            }
            if hasMeetingId {
                hashCode = (hashCode &* 31) &+ meetingId.hashValue
            }
            if hasTitle {
                hashCode = (hashCode &* 31) &+ title.hashValue
            }
            if hasContent {
                hashCode = (hashCode &* 31) &+ content.hashValue
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Metadata"
    }
    override public func className() -> String {
        return "Metadata"
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
        fileprivate var builderResult:Metadata = Metadata()
        public func getMessage() -> Metadata {
            return builderResult
        }

        required override public init () {
            super.init()
        }
        public var id:Int64 {
            get {
                return builderResult.id
            }
            set (value) {
                builderResult.hasId = true
                builderResult.id = value
            }
        }
        public var hasId:Bool {
            get {
                return builderResult.hasId
            }
        }
        @discardableResult
        public func setId(_ value:Int64) -> Metadata.Builder {
            self.id = value
            return self
        }
        @discardableResult
        public func clearId() -> Metadata.Builder{
            builderResult.hasId = false
            builderResult.id = nil
            return self
        }
        public var universityId:Int64 {
            get {
                return builderResult.universityId
            }
            set (value) {
                builderResult.hasUniversityId = true
                builderResult.universityId = value
            }
        }
        public var hasUniversityId:Bool {
            get {
                return builderResult.hasUniversityId
            }
        }
        @discardableResult
        public func setUniversityId(_ value:Int64) -> Metadata.Builder {
            self.universityId = value
            return self
        }
        @discardableResult
        public func clearUniversityId() -> Metadata.Builder{
            builderResult.hasUniversityId = false
            builderResult.universityId = nil
            return self
        }
        public var subjectId:Int64 {
            get {
                return builderResult.subjectId
            }
            set (value) {
                builderResult.hasSubjectId = true
                builderResult.subjectId = value
            }
        }
        public var hasSubjectId:Bool {
            get {
                return builderResult.hasSubjectId
            }
        }
        @discardableResult
        public func setSubjectId(_ value:Int64) -> Metadata.Builder {
            self.subjectId = value
            return self
        }
        @discardableResult
        public func clearSubjectId() -> Metadata.Builder{
            builderResult.hasSubjectId = false
            builderResult.subjectId = nil
            return self
        }
        public var courseId:Int64 {
            get {
                return builderResult.courseId
            }
            set (value) {
                builderResult.hasCourseId = true
                builderResult.courseId = value
            }
        }
        public var hasCourseId:Bool {
            get {
                return builderResult.hasCourseId
            }
        }
        @discardableResult
        public func setCourseId(_ value:Int64) -> Metadata.Builder {
            self.courseId = value
            return self
        }
        @discardableResult
        public func clearCourseId() -> Metadata.Builder{
            builderResult.hasCourseId = false
            builderResult.courseId = nil
            return self
        }
        public var sectionId:Int64 {
            get {
                return builderResult.sectionId
            }
            set (value) {
                builderResult.hasSectionId = true
                builderResult.sectionId = value
            }
        }
        public var hasSectionId:Bool {
            get {
                return builderResult.hasSectionId
            }
        }
        @discardableResult
        public func setSectionId(_ value:Int64) -> Metadata.Builder {
            self.sectionId = value
            return self
        }
        @discardableResult
        public func clearSectionId() -> Metadata.Builder{
            builderResult.hasSectionId = false
            builderResult.sectionId = nil
            return self
        }
        public var meetingId:Int64 {
            get {
                return builderResult.meetingId
            }
            set (value) {
                builderResult.hasMeetingId = true
                builderResult.meetingId = value
            }
        }
        public var hasMeetingId:Bool {
            get {
                return builderResult.hasMeetingId
            }
        }
        @discardableResult
        public func setMeetingId(_ value:Int64) -> Metadata.Builder {
            self.meetingId = value
            return self
        }
        @discardableResult
        public func clearMeetingId() -> Metadata.Builder{
            builderResult.hasMeetingId = false
            builderResult.meetingId = nil
            return self
        }
        public var title:String {
            get {
                return builderResult.title
            }
            set (value) {
                builderResult.hasTitle = true
                builderResult.title = value
            }
        }
        public var hasTitle:Bool {
            get {
                return builderResult.hasTitle
            }
        }
        @discardableResult
        public func setTitle(_ value:String) -> Metadata.Builder {
            self.title = value
            return self
        }
        @discardableResult
        public func clearTitle() -> Metadata.Builder{
            builderResult.hasTitle = false
            builderResult.title = nil
            return self
        }
        public var content:String {
            get {
                return builderResult.content
            }
            set (value) {
                builderResult.hasContent = true
                builderResult.content = value
            }
        }
        public var hasContent:Bool {
            get {
                return builderResult.hasContent
            }
        }
        @discardableResult
        public func setContent(_ value:String) -> Metadata.Builder {
            self.content = value
            return self
        }
        @discardableResult
        public func clearContent() -> Metadata.Builder{
            builderResult.hasContent = false
            builderResult.content = nil
            return self
        }
        override public var internalGetResult:GeneratedMessage {
            get {
                return builderResult
            }
        }
        @discardableResult
        override public func clear() -> Metadata.Builder {
            builderResult = Metadata()
            return self
        }
        override public func clone() throws -> Metadata.Builder {
            return try Metadata.builderWithPrototype(prototype:builderResult)
        }
        override public func build() throws -> Metadata {
            try checkInitialized()
            return buildPartial()
        }
        public func buildPartial() -> Metadata {
            let returnMe:Metadata = builderResult
            return returnMe
        }
        @discardableResult
        public func mergeFrom(other:Metadata) throws -> Metadata.Builder {
            if other == Metadata() {
                return self
            }
            if other.hasId {
                id = other.id
            }
            if other.hasUniversityId {
                universityId = other.universityId
            }
            if other.hasSubjectId {
                subjectId = other.subjectId
            }
            if other.hasCourseId {
                courseId = other.courseId
            }
            if other.hasSectionId {
                sectionId = other.sectionId
            }
            if other.hasMeetingId {
                meetingId = other.meetingId
            }
            if other.hasTitle {
                title = other.title
            }
            if other.hasContent {
                content = other.content
            }
            try merge(unknownField: other.unknownFields)
            return self
        }
        @discardableResult
        override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Metadata.Builder {
            return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
        }
        @discardableResult
        override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Metadata.Builder {
            let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
            while (true) {
                let protobufTag = try codedInputStream.readTag()
                switch protobufTag {
                case 0: 
                    self.unknownFields = try unknownFieldsBuilder.build()
                    return self

                case 8:
                    id = try codedInputStream.readInt64()

                case 16:
                    universityId = try codedInputStream.readInt64()

                case 24:
                    subjectId = try codedInputStream.readInt64()

                case 32:
                    courseId = try codedInputStream.readInt64()

                case 40:
                    sectionId = try codedInputStream.readInt64()

                case 48:
                    meetingId = try codedInputStream.readInt64()

                case 58:
                    title = try codedInputStream.readString()

                case 66:
                    content = try codedInputStream.readString()

                default:
                    if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                        unknownFields = try unknownFieldsBuilder.build()
                        return self
                    }
                }
            }
        }
        class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Metadata.Builder {
            let resultDecodedBuilder = Metadata.Builder()
            if let jsonValueId = jsonMap["id"] as? String {
                resultDecodedBuilder.id = Int64(jsonValueId)!
            } else if let jsonValueId = jsonMap["id"] as? Int {
                resultDecodedBuilder.id = Int64(jsonValueId)
            }
            if let jsonValueUniversityId = jsonMap["universityId"] as? String {
                resultDecodedBuilder.universityId = Int64(jsonValueUniversityId)!
            } else if let jsonValueUniversityId = jsonMap["universityId"] as? Int {
                resultDecodedBuilder.universityId = Int64(jsonValueUniversityId)
            }
            if let jsonValueSubjectId = jsonMap["subjectId"] as? String {
                resultDecodedBuilder.subjectId = Int64(jsonValueSubjectId)!
            } else if let jsonValueSubjectId = jsonMap["subjectId"] as? Int {
                resultDecodedBuilder.subjectId = Int64(jsonValueSubjectId)
            }
            if let jsonValueCourseId = jsonMap["courseId"] as? String {
                resultDecodedBuilder.courseId = Int64(jsonValueCourseId)!
            } else if let jsonValueCourseId = jsonMap["courseId"] as? Int {
                resultDecodedBuilder.courseId = Int64(jsonValueCourseId)
            }
            if let jsonValueSectionId = jsonMap["sectionId"] as? String {
                resultDecodedBuilder.sectionId = Int64(jsonValueSectionId)!
            } else if let jsonValueSectionId = jsonMap["sectionId"] as? Int {
                resultDecodedBuilder.sectionId = Int64(jsonValueSectionId)
            }
            if let jsonValueMeetingId = jsonMap["meetingId"] as? String {
                resultDecodedBuilder.meetingId = Int64(jsonValueMeetingId)!
            } else if let jsonValueMeetingId = jsonMap["meetingId"] as? Int {
                resultDecodedBuilder.meetingId = Int64(jsonValueMeetingId)
            }
            if let jsonValueTitle = jsonMap["title"] as? String {
                resultDecodedBuilder.title = jsonValueTitle
            }
            if let jsonValueContent = jsonMap["content"] as? String {
                resultDecodedBuilder.content = jsonValueContent
            }
            return resultDecodedBuilder
        }
        override class public func fromJSONToBuilder(data:Data) throws -> Metadata.Builder {
            let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
            guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
              throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
            }
            return try Metadata.Builder.decodeToBuilder(jsonMap:jsDataCast)
        }
    }

}

final public class Registration : GeneratedMessage {
    public typealias BuilderType = Registration.Builder

    public static func == (lhs: Registration, rhs: Registration) -> Bool {
        if lhs === rhs {
            return true
        }
        var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
        fieldCheck = fieldCheck && (lhs.hasId == rhs.hasId) && (!lhs.hasId || lhs.id == rhs.id)
        fieldCheck = fieldCheck && (lhs.hasUniversityId == rhs.hasUniversityId) && (!lhs.hasUniversityId || lhs.universityId == rhs.universityId)
        fieldCheck = fieldCheck && (lhs.hasPeriod == rhs.hasPeriod) && (!lhs.hasPeriod || lhs.period == rhs.period)
        fieldCheck = fieldCheck && (lhs.hasPeriodDate == rhs.hasPeriodDate) && (!lhs.hasPeriodDate || lhs.periodDate == rhs.periodDate)
        fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
        return fieldCheck
    }

    public fileprivate(set) var id:Int64! = nil
    public fileprivate(set) var hasId:Bool = false

    public fileprivate(set) var universityId:Int64! = nil
    public fileprivate(set) var hasUniversityId:Bool = false

    public fileprivate(set) var period:String! = nil
    public fileprivate(set) var hasPeriod:Bool = false

    public fileprivate(set) var periodDate:Int64! = nil
    public fileprivate(set) var hasPeriodDate:Bool = false

    required public init() {
        super.init()
    }
    override public func isInitialized() -> Bool {
        return true
    }
    override public func writeTo(codedOutputStream: CodedOutputStream) throws {
        if hasId {
            try codedOutputStream.writeInt64(fieldNumber: 1, value:id)
        }
        if hasUniversityId {
            try codedOutputStream.writeInt64(fieldNumber: 2, value:universityId)
        }
        if hasPeriod {
            try codedOutputStream.writeString(fieldNumber: 3, value:period)
        }
        if hasPeriodDate {
            try codedOutputStream.writeInt64(fieldNumber: 4, value:periodDate)
        }
        try unknownFields.writeTo(codedOutputStream: codedOutputStream)
    }
    override public func serializedSize() -> Int32 {
        var serialize_size:Int32 = memoizedSerializedSize
        if serialize_size != -1 {
         return serialize_size
        }

        serialize_size = 0
        if hasId {
            serialize_size += id.computeInt64Size(fieldNumber: 1)
        }
        if hasUniversityId {
            serialize_size += universityId.computeInt64Size(fieldNumber: 2)
        }
        if hasPeriod {
            serialize_size += period.computeStringSize(fieldNumber: 3)
        }
        if hasPeriodDate {
            serialize_size += periodDate.computeInt64Size(fieldNumber: 4)
        }
        serialize_size += unknownFields.serializedSize()
        memoizedSerializedSize = serialize_size
        return serialize_size
    }
    public class func getBuilder() -> Registration.Builder {
        return Registration.classBuilder() as! Registration.Builder
    }
    public func getBuilder() -> Registration.Builder {
        return classBuilder() as! Registration.Builder
    }
    override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
        return Registration.Builder()
    }
    override public func classBuilder() -> ProtocolBuffersMessageBuilder {
        return Registration.Builder()
    }
    public func toBuilder() throws -> Registration.Builder {
        return try Registration.builderWithPrototype(prototype:self)
    }
    public class func builderWithPrototype(prototype:Registration) throws -> Registration.Builder {
        return try Registration.Builder().mergeFrom(other:prototype)
    }
    override public func encode() throws -> Dictionary<String,Any> {
        guard isInitialized() else {
            throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
        }

        var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
        if hasId {
            jsonMap["id"] = "\(id!)"
        }
        if hasUniversityId {
            jsonMap["universityId"] = "\(universityId!)"
        }
        if hasPeriod {
            jsonMap["period"] = period
        }
        if hasPeriodDate {
            jsonMap["periodDate"] = "\(periodDate!)"
        }
        return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Registration {
        return try Registration.Builder.decodeToBuilder(jsonMap:jsonMap).build()
    }
    override class public func fromJSON(data:Data) throws -> Registration {
        return try Registration.Builder.fromJSONToBuilder(data:data).build()
    }
    override public func getDescription(indent:String) throws -> String {
        var output = ""
        if hasId {
            output += "\(indent) id: \(id) \n"
        }
        if hasUniversityId {
            output += "\(indent) universityId: \(universityId) \n"
        }
        if hasPeriod {
            output += "\(indent) period: \(period) \n"
        }
        if hasPeriodDate {
            output += "\(indent) periodDate: \(periodDate) \n"
        }
        output += unknownFields.getDescription(indent: indent)
        return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasId {
                hashCode = (hashCode &* 31) &+ id.hashValue
            }
            if hasUniversityId {
                hashCode = (hashCode &* 31) &+ universityId.hashValue
            }
            if hasPeriod {
                hashCode = (hashCode &* 31) &+ period.hashValue
            }
            if hasPeriodDate {
                hashCode = (hashCode &* 31) &+ periodDate.hashValue
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Registration"
    }
    override public func className() -> String {
        return "Registration"
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
        fileprivate var builderResult:Registration = Registration()
        public func getMessage() -> Registration {
            return builderResult
        }

        required override public init () {
            super.init()
        }
        public var id:Int64 {
            get {
                return builderResult.id
            }
            set (value) {
                builderResult.hasId = true
                builderResult.id = value
            }
        }
        public var hasId:Bool {
            get {
                return builderResult.hasId
            }
        }
        @discardableResult
        public func setId(_ value:Int64) -> Registration.Builder {
            self.id = value
            return self
        }
        @discardableResult
        public func clearId() -> Registration.Builder{
            builderResult.hasId = false
            builderResult.id = nil
            return self
        }
        public var universityId:Int64 {
            get {
                return builderResult.universityId
            }
            set (value) {
                builderResult.hasUniversityId = true
                builderResult.universityId = value
            }
        }
        public var hasUniversityId:Bool {
            get {
                return builderResult.hasUniversityId
            }
        }
        @discardableResult
        public func setUniversityId(_ value:Int64) -> Registration.Builder {
            self.universityId = value
            return self
        }
        @discardableResult
        public func clearUniversityId() -> Registration.Builder{
            builderResult.hasUniversityId = false
            builderResult.universityId = nil
            return self
        }
        public var period:String {
            get {
                return builderResult.period
            }
            set (value) {
                builderResult.hasPeriod = true
                builderResult.period = value
            }
        }
        public var hasPeriod:Bool {
            get {
                return builderResult.hasPeriod
            }
        }
        @discardableResult
        public func setPeriod(_ value:String) -> Registration.Builder {
            self.period = value
            return self
        }
        @discardableResult
        public func clearPeriod() -> Registration.Builder{
            builderResult.hasPeriod = false
            builderResult.period = nil
            return self
        }
        public var periodDate:Int64 {
            get {
                return builderResult.periodDate
            }
            set (value) {
                builderResult.hasPeriodDate = true
                builderResult.periodDate = value
            }
        }
        public var hasPeriodDate:Bool {
            get {
                return builderResult.hasPeriodDate
            }
        }
        @discardableResult
        public func setPeriodDate(_ value:Int64) -> Registration.Builder {
            self.periodDate = value
            return self
        }
        @discardableResult
        public func clearPeriodDate() -> Registration.Builder{
            builderResult.hasPeriodDate = false
            builderResult.periodDate = nil
            return self
        }
        override public var internalGetResult:GeneratedMessage {
            get {
                return builderResult
            }
        }
        @discardableResult
        override public func clear() -> Registration.Builder {
            builderResult = Registration()
            return self
        }
        override public func clone() throws -> Registration.Builder {
            return try Registration.builderWithPrototype(prototype:builderResult)
        }
        override public func build() throws -> Registration {
            try checkInitialized()
            return buildPartial()
        }
        public func buildPartial() -> Registration {
            let returnMe:Registration = builderResult
            return returnMe
        }
        @discardableResult
        public func mergeFrom(other:Registration) throws -> Registration.Builder {
            if other == Registration() {
                return self
            }
            if other.hasId {
                id = other.id
            }
            if other.hasUniversityId {
                universityId = other.universityId
            }
            if other.hasPeriod {
                period = other.period
            }
            if other.hasPeriodDate {
                periodDate = other.periodDate
            }
            try merge(unknownField: other.unknownFields)
            return self
        }
        @discardableResult
        override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Registration.Builder {
            return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
        }
        @discardableResult
        override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Registration.Builder {
            let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
            while (true) {
                let protobufTag = try codedInputStream.readTag()
                switch protobufTag {
                case 0: 
                    self.unknownFields = try unknownFieldsBuilder.build()
                    return self

                case 8:
                    id = try codedInputStream.readInt64()

                case 16:
                    universityId = try codedInputStream.readInt64()

                case 26:
                    period = try codedInputStream.readString()

                case 32:
                    periodDate = try codedInputStream.readInt64()

                default:
                    if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                        unknownFields = try unknownFieldsBuilder.build()
                        return self
                    }
                }
            }
        }
        class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Registration.Builder {
            let resultDecodedBuilder = Registration.Builder()
            if let jsonValueId = jsonMap["id"] as? String {
                resultDecodedBuilder.id = Int64(jsonValueId)!
            } else if let jsonValueId = jsonMap["id"] as? Int {
                resultDecodedBuilder.id = Int64(jsonValueId)
            }
            if let jsonValueUniversityId = jsonMap["universityId"] as? String {
                resultDecodedBuilder.universityId = Int64(jsonValueUniversityId)!
            } else if let jsonValueUniversityId = jsonMap["universityId"] as? Int {
                resultDecodedBuilder.universityId = Int64(jsonValueUniversityId)
            }
            if let jsonValuePeriod = jsonMap["period"] as? String {
                resultDecodedBuilder.period = jsonValuePeriod
            }
            if let jsonValuePeriodDate = jsonMap["periodDate"] as? String {
                resultDecodedBuilder.periodDate = Int64(jsonValuePeriodDate)!
            } else if let jsonValuePeriodDate = jsonMap["periodDate"] as? Int {
                resultDecodedBuilder.periodDate = Int64(jsonValuePeriodDate)
            }
            return resultDecodedBuilder
        }
        override class public func fromJSONToBuilder(data:Data) throws -> Registration.Builder {
            let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
            guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
              throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
            }
            return try Registration.Builder.decodeToBuilder(jsonMap:jsDataCast)
        }
    }

}

final public class ResolvedSemester : GeneratedMessage {
    public typealias BuilderType = ResolvedSemester.Builder

    public static func == (lhs: ResolvedSemester, rhs: ResolvedSemester) -> Bool {
        if lhs === rhs {
            return true
        }
        var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
        fieldCheck = fieldCheck && (lhs.hasCurrent == rhs.hasCurrent) && (!lhs.hasCurrent || lhs.current == rhs.current)
        fieldCheck = fieldCheck && (lhs.hasLast == rhs.hasLast) && (!lhs.hasLast || lhs.last == rhs.last)
        fieldCheck = fieldCheck && (lhs.hasNext == rhs.hasNext) && (!lhs.hasNext || lhs.next == rhs.next)
        fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
        return fieldCheck
    }

    public fileprivate(set) var current:Semester!
    public fileprivate(set) var hasCurrent:Bool = false
    public fileprivate(set) var last:Semester!
    public fileprivate(set) var hasLast:Bool = false
    public fileprivate(set) var next:Semester!
    public fileprivate(set) var hasNext:Bool = false
    required public init() {
        super.init()
    }
    override public func isInitialized() -> Bool {
        return true
    }
    override public func writeTo(codedOutputStream: CodedOutputStream) throws {
        if hasCurrent {
            try codedOutputStream.writeMessage(fieldNumber: 1, value:current)
        }
        if hasLast {
            try codedOutputStream.writeMessage(fieldNumber: 2, value:last)
        }
        if hasNext {
            try codedOutputStream.writeMessage(fieldNumber: 3, value:next)
        }
        try unknownFields.writeTo(codedOutputStream: codedOutputStream)
    }
    override public func serializedSize() -> Int32 {
        var serialize_size:Int32 = memoizedSerializedSize
        if serialize_size != -1 {
         return serialize_size
        }

        serialize_size = 0
        if hasCurrent {
            if let varSizecurrent = current?.computeMessageSize(fieldNumber: 1) {
                serialize_size += varSizecurrent
            }
        }
        if hasLast {
            if let varSizelast = last?.computeMessageSize(fieldNumber: 2) {
                serialize_size += varSizelast
            }
        }
        if hasNext {
            if let varSizenext = next?.computeMessageSize(fieldNumber: 3) {
                serialize_size += varSizenext
            }
        }
        serialize_size += unknownFields.serializedSize()
        memoizedSerializedSize = serialize_size
        return serialize_size
    }
    public class func getBuilder() -> ResolvedSemester.Builder {
        return ResolvedSemester.classBuilder() as! ResolvedSemester.Builder
    }
    public func getBuilder() -> ResolvedSemester.Builder {
        return classBuilder() as! ResolvedSemester.Builder
    }
    override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
        return ResolvedSemester.Builder()
    }
    override public func classBuilder() -> ProtocolBuffersMessageBuilder {
        return ResolvedSemester.Builder()
    }
    public func toBuilder() throws -> ResolvedSemester.Builder {
        return try ResolvedSemester.builderWithPrototype(prototype:self)
    }
    public class func builderWithPrototype(prototype:ResolvedSemester) throws -> ResolvedSemester.Builder {
        return try ResolvedSemester.Builder().mergeFrom(other:prototype)
    }
    override public func encode() throws -> Dictionary<String,Any> {
        guard isInitialized() else {
            throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
        }

        var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
        if hasCurrent {
            jsonMap["current"] = try current.encode()
        }
        if hasLast {
            jsonMap["last"] = try last.encode()
        }
        if hasNext {
            jsonMap["next"] = try next.encode()
        }
        return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,Any>) throws -> ResolvedSemester {
        return try ResolvedSemester.Builder.decodeToBuilder(jsonMap:jsonMap).build()
    }
    override class public func fromJSON(data:Data) throws -> ResolvedSemester {
        return try ResolvedSemester.Builder.fromJSONToBuilder(data:data).build()
    }
    override public func getDescription(indent:String) throws -> String {
        var output = ""
        if hasCurrent {
            output += "\(indent) current {\n"
            if let outDescCurrent = current {
                output += try outDescCurrent.getDescription(indent: "\(indent)  ")
            }
            output += "\(indent) }\n"
        }
        if hasLast {
            output += "\(indent) last {\n"
            if let outDescLast = last {
                output += try outDescLast.getDescription(indent: "\(indent)  ")
            }
            output += "\(indent) }\n"
        }
        if hasNext {
            output += "\(indent) next {\n"
            if let outDescNext = next {
                output += try outDescNext.getDescription(indent: "\(indent)  ")
            }
            output += "\(indent) }\n"
        }
        output += unknownFields.getDescription(indent: indent)
        return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasCurrent {
                if let hashValuecurrent = current?.hashValue {
                    hashCode = (hashCode &* 31) &+ hashValuecurrent
                }
            }
            if hasLast {
                if let hashValuelast = last?.hashValue {
                    hashCode = (hashCode &* 31) &+ hashValuelast
                }
            }
            if hasNext {
                if let hashValuenext = next?.hashValue {
                    hashCode = (hashCode &* 31) &+ hashValuenext
                }
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "ResolvedSemester"
    }
    override public func className() -> String {
        return "ResolvedSemester"
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
        fileprivate var builderResult:ResolvedSemester = ResolvedSemester()
        public func getMessage() -> ResolvedSemester {
            return builderResult
        }

        required override public init () {
            super.init()
        }
        public var current:Semester! {
            get {
                if currentBuilder_ != nil {
                    builderResult.current = currentBuilder_.getMessage()
                }
                return builderResult.current
            }
            set (value) {
                builderResult.hasCurrent = value != nil
                builderResult.current = value
            }
        }
        public var hasCurrent:Bool {
            get {
                return builderResult.hasCurrent
            }
        }
        fileprivate var currentBuilder_:Semester.Builder! {
            didSet {
                builderResult.hasCurrent = true
            }
        }
        public func getCurrentBuilder() -> Semester.Builder {
            if currentBuilder_ == nil {
                currentBuilder_ = Semester.Builder()
                builderResult.current = currentBuilder_.getMessage()
                if current != nil {
                    try! currentBuilder_.mergeFrom(other: current)
                }
            }
            return currentBuilder_
        }
        @discardableResult
        public func setCurrent(_ value:Semester!) -> ResolvedSemester.Builder {
            self.current = value
            return self
        }
        @discardableResult
        public func mergeCurrent(value:Semester) throws -> ResolvedSemester.Builder {
            if builderResult.hasCurrent {
                builderResult.current = try Semester.builderWithPrototype(prototype:builderResult.current).mergeFrom(other: value).buildPartial()
            } else {
                builderResult.current = value
            }
            builderResult.hasCurrent = true
            return self
        }
        @discardableResult
        public func clearCurrent() -> ResolvedSemester.Builder {
            currentBuilder_ = nil
            builderResult.hasCurrent = false
            builderResult.current = nil
            return self
        }
        public var last:Semester! {
            get {
                if lastBuilder_ != nil {
                    builderResult.last = lastBuilder_.getMessage()
                }
                return builderResult.last
            }
            set (value) {
                builderResult.hasLast = value != nil
                builderResult.last = value
            }
        }
        public var hasLast:Bool {
            get {
                return builderResult.hasLast
            }
        }
        fileprivate var lastBuilder_:Semester.Builder! {
            didSet {
                builderResult.hasLast = true
            }
        }
        public func getLastBuilder() -> Semester.Builder {
            if lastBuilder_ == nil {
                lastBuilder_ = Semester.Builder()
                builderResult.last = lastBuilder_.getMessage()
                if last != nil {
                    try! lastBuilder_.mergeFrom(other: last)
                }
            }
            return lastBuilder_
        }
        @discardableResult
        public func setLast(_ value:Semester!) -> ResolvedSemester.Builder {
            self.last = value
            return self
        }
        @discardableResult
        public func mergeLast(value:Semester) throws -> ResolvedSemester.Builder {
            if builderResult.hasLast {
                builderResult.last = try Semester.builderWithPrototype(prototype:builderResult.last).mergeFrom(other: value).buildPartial()
            } else {
                builderResult.last = value
            }
            builderResult.hasLast = true
            return self
        }
        @discardableResult
        public func clearLast() -> ResolvedSemester.Builder {
            lastBuilder_ = nil
            builderResult.hasLast = false
            builderResult.last = nil
            return self
        }
        public var next:Semester! {
            get {
                if nextBuilder_ != nil {
                    builderResult.next = nextBuilder_.getMessage()
                }
                return builderResult.next
            }
            set (value) {
                builderResult.hasNext = value != nil
                builderResult.next = value
            }
        }
        public var hasNext:Bool {
            get {
                return builderResult.hasNext
            }
        }
        fileprivate var nextBuilder_:Semester.Builder! {
            didSet {
                builderResult.hasNext = true
            }
        }
        public func getNextBuilder() -> Semester.Builder {
            if nextBuilder_ == nil {
                nextBuilder_ = Semester.Builder()
                builderResult.next = nextBuilder_.getMessage()
                if next != nil {
                    try! nextBuilder_.mergeFrom(other: next)
                }
            }
            return nextBuilder_
        }
        @discardableResult
        public func setNext(_ value:Semester!) -> ResolvedSemester.Builder {
            self.next = value
            return self
        }
        @discardableResult
        public func mergeNext(value:Semester) throws -> ResolvedSemester.Builder {
            if builderResult.hasNext {
                builderResult.next = try Semester.builderWithPrototype(prototype:builderResult.next).mergeFrom(other: value).buildPartial()
            } else {
                builderResult.next = value
            }
            builderResult.hasNext = true
            return self
        }
        @discardableResult
        public func clearNext() -> ResolvedSemester.Builder {
            nextBuilder_ = nil
            builderResult.hasNext = false
            builderResult.next = nil
            return self
        }
        override public var internalGetResult:GeneratedMessage {
            get {
                return builderResult
            }
        }
        @discardableResult
        override public func clear() -> ResolvedSemester.Builder {
            builderResult = ResolvedSemester()
            return self
        }
        override public func clone() throws -> ResolvedSemester.Builder {
            return try ResolvedSemester.builderWithPrototype(prototype:builderResult)
        }
        override public func build() throws -> ResolvedSemester {
            try checkInitialized()
            return buildPartial()
        }
        public func buildPartial() -> ResolvedSemester {
            let returnMe:ResolvedSemester = builderResult
            return returnMe
        }
        @discardableResult
        public func mergeFrom(other:ResolvedSemester) throws -> ResolvedSemester.Builder {
            if other == ResolvedSemester() {
                return self
            }
            if (other.hasCurrent) {
                try mergeCurrent(value: other.current)
            }
            if (other.hasLast) {
                try mergeLast(value: other.last)
            }
            if (other.hasNext) {
                try mergeNext(value: other.next)
            }
            try merge(unknownField: other.unknownFields)
            return self
        }
        @discardableResult
        override public func mergeFrom(codedInputStream: CodedInputStream) throws -> ResolvedSemester.Builder {
            return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
        }
        @discardableResult
        override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> ResolvedSemester.Builder {
            let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
            while (true) {
                let protobufTag = try codedInputStream.readTag()
                switch protobufTag {
                case 0: 
                    self.unknownFields = try unknownFieldsBuilder.build()
                    return self

                case 10:
                    let subBuilder:Semester.Builder = Semester.Builder()
                    if hasCurrent {
                        try subBuilder.mergeFrom(other: current)
                    }
                    try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                    current = subBuilder.buildPartial()

                case 18:
                    let subBuilder:Semester.Builder = Semester.Builder()
                    if hasLast {
                        try subBuilder.mergeFrom(other: last)
                    }
                    try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                    last = subBuilder.buildPartial()

                case 26:
                    let subBuilder:Semester.Builder = Semester.Builder()
                    if hasNext {
                        try subBuilder.mergeFrom(other: next)
                    }
                    try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                    next = subBuilder.buildPartial()

                default:
                    if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                        unknownFields = try unknownFieldsBuilder.build()
                        return self
                    }
                }
            }
        }
        class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> ResolvedSemester.Builder {
            let resultDecodedBuilder = ResolvedSemester.Builder()
            if let jsonValueCurrent = jsonMap["current"] as? Dictionary<String,Any> {
                resultDecodedBuilder.current = try Semester.Builder.decodeToBuilder(jsonMap:jsonValueCurrent).build()

            }
            if let jsonValueLast = jsonMap["last"] as? Dictionary<String,Any> {
                resultDecodedBuilder.last = try Semester.Builder.decodeToBuilder(jsonMap:jsonValueLast).build()

            }
            if let jsonValueNext = jsonMap["next"] as? Dictionary<String,Any> {
                resultDecodedBuilder.next = try Semester.Builder.decodeToBuilder(jsonMap:jsonValueNext).build()

            }
            return resultDecodedBuilder
        }
        override class public func fromJSONToBuilder(data:Data) throws -> ResolvedSemester.Builder {
            let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
            guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
              throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
            }
            return try ResolvedSemester.Builder.decodeToBuilder(jsonMap:jsDataCast)
        }
    }

}

final public class Semester : GeneratedMessage {
    public typealias BuilderType = Semester.Builder

    public static func == (lhs: Semester, rhs: Semester) -> Bool {
        if lhs === rhs {
            return true
        }
        var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
        fieldCheck = fieldCheck && (lhs.hasYear == rhs.hasYear) && (!lhs.hasYear || lhs.year == rhs.year)
        fieldCheck = fieldCheck && (lhs.hasSeason == rhs.hasSeason) && (!lhs.hasSeason || lhs.season == rhs.season)
        fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
        return fieldCheck
    }

    public fileprivate(set) var year:Int32! = nil
    public fileprivate(set) var hasYear:Bool = false

    public fileprivate(set) var season:String! = nil
    public fileprivate(set) var hasSeason:Bool = false

    required public init() {
        super.init()
    }
    override public func isInitialized() -> Bool {
        return true
    }
    override public func writeTo(codedOutputStream: CodedOutputStream) throws {
        if hasYear {
            try codedOutputStream.writeInt32(fieldNumber: 1, value:year)
        }
        if hasSeason {
            try codedOutputStream.writeString(fieldNumber: 2, value:season)
        }
        try unknownFields.writeTo(codedOutputStream: codedOutputStream)
    }
    override public func serializedSize() -> Int32 {
        var serialize_size:Int32 = memoizedSerializedSize
        if serialize_size != -1 {
         return serialize_size
        }

        serialize_size = 0
        if hasYear {
            serialize_size += year.computeInt32Size(fieldNumber: 1)
        }
        if hasSeason {
            serialize_size += season.computeStringSize(fieldNumber: 2)
        }
        serialize_size += unknownFields.serializedSize()
        memoizedSerializedSize = serialize_size
        return serialize_size
    }
    public class func getBuilder() -> Semester.Builder {
        return Semester.classBuilder() as! Semester.Builder
    }
    public func getBuilder() -> Semester.Builder {
        return classBuilder() as! Semester.Builder
    }
    override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
        return Semester.Builder()
    }
    override public func classBuilder() -> ProtocolBuffersMessageBuilder {
        return Semester.Builder()
    }
    public func toBuilder() throws -> Semester.Builder {
        return try Semester.builderWithPrototype(prototype:self)
    }
    public class func builderWithPrototype(prototype:Semester) throws -> Semester.Builder {
        return try Semester.Builder().mergeFrom(other:prototype)
    }
    override public func encode() throws -> Dictionary<String,Any> {
        guard isInitialized() else {
            throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
        }

        var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
        if hasYear {
            jsonMap["year"] = Int(year)
        }
        if hasSeason {
            jsonMap["season"] = season
        }
        return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Semester {
        return try Semester.Builder.decodeToBuilder(jsonMap:jsonMap).build()
    }
    override class public func fromJSON(data:Data) throws -> Semester {
        return try Semester.Builder.fromJSONToBuilder(data:data).build()
    }
    override public func getDescription(indent:String) throws -> String {
        var output = ""
        if hasYear {
            output += "\(indent) year: \(year) \n"
        }
        if hasSeason {
            output += "\(indent) season: \(season) \n"
        }
        output += unknownFields.getDescription(indent: indent)
        return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasYear {
                hashCode = (hashCode &* 31) &+ year.hashValue
            }
            if hasSeason {
                hashCode = (hashCode &* 31) &+ season.hashValue
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Semester"
    }
    override public func className() -> String {
        return "Semester"
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
        fileprivate var builderResult:Semester = Semester()
        public func getMessage() -> Semester {
            return builderResult
        }

        required override public init () {
            super.init()
        }
        public var year:Int32 {
            get {
                return builderResult.year
            }
            set (value) {
                builderResult.hasYear = true
                builderResult.year = value
            }
        }
        public var hasYear:Bool {
            get {
                return builderResult.hasYear
            }
        }
        @discardableResult
        public func setYear(_ value:Int32) -> Semester.Builder {
            self.year = value
            return self
        }
        @discardableResult
        public func clearYear() -> Semester.Builder{
            builderResult.hasYear = false
            builderResult.year = nil
            return self
        }
        public var season:String {
            get {
                return builderResult.season
            }
            set (value) {
                builderResult.hasSeason = true
                builderResult.season = value
            }
        }
        public var hasSeason:Bool {
            get {
                return builderResult.hasSeason
            }
        }
        @discardableResult
        public func setSeason(_ value:String) -> Semester.Builder {
            self.season = value
            return self
        }
        @discardableResult
        public func clearSeason() -> Semester.Builder{
            builderResult.hasSeason = false
            builderResult.season = nil
            return self
        }
        override public var internalGetResult:GeneratedMessage {
            get {
                return builderResult
            }
        }
        @discardableResult
        override public func clear() -> Semester.Builder {
            builderResult = Semester()
            return self
        }
        override public func clone() throws -> Semester.Builder {
            return try Semester.builderWithPrototype(prototype:builderResult)
        }
        override public func build() throws -> Semester {
            try checkInitialized()
            return buildPartial()
        }
        public func buildPartial() -> Semester {
            let returnMe:Semester = builderResult
            return returnMe
        }
        @discardableResult
        public func mergeFrom(other:Semester) throws -> Semester.Builder {
            if other == Semester() {
                return self
            }
            if other.hasYear {
                year = other.year
            }
            if other.hasSeason {
                season = other.season
            }
            try merge(unknownField: other.unknownFields)
            return self
        }
        @discardableResult
        override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Semester.Builder {
            return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
        }
        @discardableResult
        override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Semester.Builder {
            let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
            while (true) {
                let protobufTag = try codedInputStream.readTag()
                switch protobufTag {
                case 0: 
                    self.unknownFields = try unknownFieldsBuilder.build()
                    return self

                case 8:
                    year = try codedInputStream.readInt32()

                case 18:
                    season = try codedInputStream.readString()

                default:
                    if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                        unknownFields = try unknownFieldsBuilder.build()
                        return self
                    }
                }
            }
        }
        class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Semester.Builder {
            let resultDecodedBuilder = Semester.Builder()
            if let jsonValueYear = jsonMap["year"] as? Int {
                resultDecodedBuilder.year = Int32(jsonValueYear)
            } else if let jsonValueYear = jsonMap["year"] as? String {
                resultDecodedBuilder.year = Int32(jsonValueYear)!
            }
            if let jsonValueSeason = jsonMap["season"] as? String {
                resultDecodedBuilder.season = jsonValueSeason
            }
            return resultDecodedBuilder
        }
        override class public func fromJSONToBuilder(data:Data) throws -> Semester.Builder {
            let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
            guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
              throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
            }
            return try Semester.Builder.decodeToBuilder(jsonMap:jsDataCast)
        }
    }

}

final public class Uctnotification : GeneratedMessage {
    public typealias BuilderType = Uctnotification.Builder

    public static func == (lhs: Uctnotification, rhs: Uctnotification) -> Bool {
        if lhs === rhs {
            return true
        }
        var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
        fieldCheck = fieldCheck && (lhs.hasNotificationId == rhs.hasNotificationId) && (!lhs.hasNotificationId || lhs.notificationId == rhs.notificationId)
        fieldCheck = fieldCheck && (lhs.hasTopicName == rhs.hasTopicName) && (!lhs.hasTopicName || lhs.topicName == rhs.topicName)
        fieldCheck = fieldCheck && (lhs.hasStatus == rhs.hasStatus) && (!lhs.hasStatus || lhs.status == rhs.status)
        fieldCheck = fieldCheck && (lhs.hasUniversity == rhs.hasUniversity) && (!lhs.hasUniversity || lhs.university == rhs.university)
        fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
        return fieldCheck
    }

    public fileprivate(set) var notificationId:Int64! = nil
    public fileprivate(set) var hasNotificationId:Bool = false

    public fileprivate(set) var topicName:String! = nil
    public fileprivate(set) var hasTopicName:Bool = false

    public fileprivate(set) var status:String! = nil
    public fileprivate(set) var hasStatus:Bool = false

    public fileprivate(set) var university:University!
    public fileprivate(set) var hasUniversity:Bool = false
    required public init() {
        super.init()
    }
    override public func isInitialized() -> Bool {
        return true
    }
    override public func writeTo(codedOutputStream: CodedOutputStream) throws {
        if hasNotificationId {
            try codedOutputStream.writeInt64(fieldNumber: 1, value:notificationId)
        }
        if hasTopicName {
            try codedOutputStream.writeString(fieldNumber: 2, value:topicName)
        }
        if hasStatus {
            try codedOutputStream.writeString(fieldNumber: 3, value:status)
        }
        if hasUniversity {
            try codedOutputStream.writeMessage(fieldNumber: 4, value:university)
        }
        try unknownFields.writeTo(codedOutputStream: codedOutputStream)
    }
    override public func serializedSize() -> Int32 {
        var serialize_size:Int32 = memoizedSerializedSize
        if serialize_size != -1 {
         return serialize_size
        }

        serialize_size = 0
        if hasNotificationId {
            serialize_size += notificationId.computeInt64Size(fieldNumber: 1)
        }
        if hasTopicName {
            serialize_size += topicName.computeStringSize(fieldNumber: 2)
        }
        if hasStatus {
            serialize_size += status.computeStringSize(fieldNumber: 3)
        }
        if hasUniversity {
            if let varSizeuniversity = university?.computeMessageSize(fieldNumber: 4) {
                serialize_size += varSizeuniversity
            }
        }
        serialize_size += unknownFields.serializedSize()
        memoizedSerializedSize = serialize_size
        return serialize_size
    }
    public class func getBuilder() -> Uctnotification.Builder {
        return Uctnotification.classBuilder() as! Uctnotification.Builder
    }
    public func getBuilder() -> Uctnotification.Builder {
        return classBuilder() as! Uctnotification.Builder
    }
    override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
        return Uctnotification.Builder()
    }
    override public func classBuilder() -> ProtocolBuffersMessageBuilder {
        return Uctnotification.Builder()
    }
    public func toBuilder() throws -> Uctnotification.Builder {
        return try Uctnotification.builderWithPrototype(prototype:self)
    }
    public class func builderWithPrototype(prototype:Uctnotification) throws -> Uctnotification.Builder {
        return try Uctnotification.Builder().mergeFrom(other:prototype)
    }
    override public func encode() throws -> Dictionary<String,Any> {
        guard isInitialized() else {
            throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
        }

        var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
        if hasNotificationId {
            jsonMap["notificationId"] = "\(notificationId!)"
        }
        if hasTopicName {
            jsonMap["topicName"] = topicName
        }
        if hasStatus {
            jsonMap["status"] = status
        }
        if hasUniversity {
            jsonMap["university"] = try university.encode()
        }
        return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Uctnotification {
        return try Uctnotification.Builder.decodeToBuilder(jsonMap:jsonMap).build()
    }
    override class public func fromJSON(data:Data) throws -> Uctnotification {
        return try Uctnotification.Builder.fromJSONToBuilder(data:data).build()
    }
    override public func getDescription(indent:String) throws -> String {
        var output = ""
        if hasNotificationId {
            output += "\(indent) notificationId: \(notificationId) \n"
        }
        if hasTopicName {
            output += "\(indent) topicName: \(topicName) \n"
        }
        if hasStatus {
            output += "\(indent) status: \(status) \n"
        }
        if hasUniversity {
            output += "\(indent) university {\n"
            if let outDescUniversity = university {
                output += try outDescUniversity.getDescription(indent: "\(indent)  ")
            }
            output += "\(indent) }\n"
        }
        output += unknownFields.getDescription(indent: indent)
        return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasNotificationId {
                hashCode = (hashCode &* 31) &+ notificationId.hashValue
            }
            if hasTopicName {
                hashCode = (hashCode &* 31) &+ topicName.hashValue
            }
            if hasStatus {
                hashCode = (hashCode &* 31) &+ status.hashValue
            }
            if hasUniversity {
                if let hashValueuniversity = university?.hashValue {
                    hashCode = (hashCode &* 31) &+ hashValueuniversity
                }
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Uctnotification"
    }
    override public func className() -> String {
        return "Uctnotification"
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
        fileprivate var builderResult:Uctnotification = Uctnotification()
        public func getMessage() -> Uctnotification {
            return builderResult
        }

        required override public init () {
            super.init()
        }
        public var notificationId:Int64 {
            get {
                return builderResult.notificationId
            }
            set (value) {
                builderResult.hasNotificationId = true
                builderResult.notificationId = value
            }
        }
        public var hasNotificationId:Bool {
            get {
                return builderResult.hasNotificationId
            }
        }
        @discardableResult
        public func setNotificationId(_ value:Int64) -> Uctnotification.Builder {
            self.notificationId = value
            return self
        }
        @discardableResult
        public func clearNotificationId() -> Uctnotification.Builder{
            builderResult.hasNotificationId = false
            builderResult.notificationId = nil
            return self
        }
        public var topicName:String {
            get {
                return builderResult.topicName
            }
            set (value) {
                builderResult.hasTopicName = true
                builderResult.topicName = value
            }
        }
        public var hasTopicName:Bool {
            get {
                return builderResult.hasTopicName
            }
        }
        @discardableResult
        public func setTopicName(_ value:String) -> Uctnotification.Builder {
            self.topicName = value
            return self
        }
        @discardableResult
        public func clearTopicName() -> Uctnotification.Builder{
            builderResult.hasTopicName = false
            builderResult.topicName = nil
            return self
        }
        public var status:String {
            get {
                return builderResult.status
            }
            set (value) {
                builderResult.hasStatus = true
                builderResult.status = value
            }
        }
        public var hasStatus:Bool {
            get {
                return builderResult.hasStatus
            }
        }
        @discardableResult
        public func setStatus(_ value:String) -> Uctnotification.Builder {
            self.status = value
            return self
        }
        @discardableResult
        public func clearStatus() -> Uctnotification.Builder{
            builderResult.hasStatus = false
            builderResult.status = nil
            return self
        }
        public var university:University! {
            get {
                if universityBuilder_ != nil {
                    builderResult.university = universityBuilder_.getMessage()
                }
                return builderResult.university
            }
            set (value) {
                builderResult.hasUniversity = value != nil
                builderResult.university = value
            }
        }
        public var hasUniversity:Bool {
            get {
                return builderResult.hasUniversity
            }
        }
        fileprivate var universityBuilder_:University.Builder! {
            didSet {
                builderResult.hasUniversity = true
            }
        }
        public func getUniversityBuilder() -> University.Builder {
            if universityBuilder_ == nil {
                universityBuilder_ = University.Builder()
                builderResult.university = universityBuilder_.getMessage()
                if university != nil {
                    try! universityBuilder_.mergeFrom(other: university)
                }
            }
            return universityBuilder_
        }
        @discardableResult
        public func setUniversity(_ value:University!) -> Uctnotification.Builder {
            self.university = value
            return self
        }
        @discardableResult
        public func mergeUniversity(value:University) throws -> Uctnotification.Builder {
            if builderResult.hasUniversity {
                builderResult.university = try University.builderWithPrototype(prototype:builderResult.university).mergeFrom(other: value).buildPartial()
            } else {
                builderResult.university = value
            }
            builderResult.hasUniversity = true
            return self
        }
        @discardableResult
        public func clearUniversity() -> Uctnotification.Builder {
            universityBuilder_ = nil
            builderResult.hasUniversity = false
            builderResult.university = nil
            return self
        }
        override public var internalGetResult:GeneratedMessage {
            get {
                return builderResult
            }
        }
        @discardableResult
        override public func clear() -> Uctnotification.Builder {
            builderResult = Uctnotification()
            return self
        }
        override public func clone() throws -> Uctnotification.Builder {
            return try Uctnotification.builderWithPrototype(prototype:builderResult)
        }
        override public func build() throws -> Uctnotification {
            try checkInitialized()
            return buildPartial()
        }
        public func buildPartial() -> Uctnotification {
            let returnMe:Uctnotification = builderResult
            return returnMe
        }
        @discardableResult
        public func mergeFrom(other:Uctnotification) throws -> Uctnotification.Builder {
            if other == Uctnotification() {
                return self
            }
            if other.hasNotificationId {
                notificationId = other.notificationId
            }
            if other.hasTopicName {
                topicName = other.topicName
            }
            if other.hasStatus {
                status = other.status
            }
            if (other.hasUniversity) {
                try mergeUniversity(value: other.university)
            }
            try merge(unknownField: other.unknownFields)
            return self
        }
        @discardableResult
        override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Uctnotification.Builder {
            return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
        }
        @discardableResult
        override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Uctnotification.Builder {
            let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
            while (true) {
                let protobufTag = try codedInputStream.readTag()
                switch protobufTag {
                case 0: 
                    self.unknownFields = try unknownFieldsBuilder.build()
                    return self

                case 8:
                    notificationId = try codedInputStream.readInt64()

                case 18:
                    topicName = try codedInputStream.readString()

                case 26:
                    status = try codedInputStream.readString()

                case 34:
                    let subBuilder:University.Builder = University.Builder()
                    if hasUniversity {
                        try subBuilder.mergeFrom(other: university)
                    }
                    try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                    university = subBuilder.buildPartial()

                default:
                    if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                        unknownFields = try unknownFieldsBuilder.build()
                        return self
                    }
                }
            }
        }
        class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Uctnotification.Builder {
            let resultDecodedBuilder = Uctnotification.Builder()
            if let jsonValueNotificationId = jsonMap["notificationId"] as? String {
                resultDecodedBuilder.notificationId = Int64(jsonValueNotificationId)!
            } else if let jsonValueNotificationId = jsonMap["notificationId"] as? Int {
                resultDecodedBuilder.notificationId = Int64(jsonValueNotificationId)
            }
            if let jsonValueTopicName = jsonMap["topicName"] as? String {
                resultDecodedBuilder.topicName = jsonValueTopicName
            }
            if let jsonValueStatus = jsonMap["status"] as? String {
                resultDecodedBuilder.status = jsonValueStatus
            }
            if let jsonValueUniversity = jsonMap["university"] as? Dictionary<String,Any> {
                resultDecodedBuilder.university = try University.Builder.decodeToBuilder(jsonMap:jsonValueUniversity).build()

            }
            return resultDecodedBuilder
        }
        override class public func fromJSONToBuilder(data:Data) throws -> Uctnotification.Builder {
            let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
            guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
              throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
            }
            return try Uctnotification.Builder.decodeToBuilder(jsonMap:jsDataCast)
        }
    }

}

final public class Response : GeneratedMessage {
    public typealias BuilderType = Response.Builder

    public static func == (lhs: Response, rhs: Response) -> Bool {
        if lhs === rhs {
            return true
        }
        var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
        fieldCheck = fieldCheck && (lhs.hasMeta == rhs.hasMeta) && (!lhs.hasMeta || lhs.meta == rhs.meta)
        fieldCheck = fieldCheck && (lhs.hasData == rhs.hasData) && (!lhs.hasData || lhs.data == rhs.data)
        fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
        return fieldCheck
    }

    public fileprivate(set) var meta:Meta!
    public fileprivate(set) var hasMeta:Bool = false
    public fileprivate(set) var data:ResponseData!
    public fileprivate(set) var hasData:Bool = false
    required public init() {
        super.init()
    }
    override public func isInitialized() -> Bool {
        return true
    }
    override public func writeTo(codedOutputStream: CodedOutputStream) throws {
        if hasMeta {
            try codedOutputStream.writeMessage(fieldNumber: 1, value:meta)
        }
        if hasData {
            try codedOutputStream.writeMessage(fieldNumber: 2, value:data)
        }
        try unknownFields.writeTo(codedOutputStream: codedOutputStream)
    }
    override public func serializedSize() -> Int32 {
        var serialize_size:Int32 = memoizedSerializedSize
        if serialize_size != -1 {
         return serialize_size
        }

        serialize_size = 0
        if hasMeta {
            if let varSizemeta = meta?.computeMessageSize(fieldNumber: 1) {
                serialize_size += varSizemeta
            }
        }
        if hasData {
            if let varSizedata = data?.computeMessageSize(fieldNumber: 2) {
                serialize_size += varSizedata
            }
        }
        serialize_size += unknownFields.serializedSize()
        memoizedSerializedSize = serialize_size
        return serialize_size
    }
    public class func getBuilder() -> Response.Builder {
        return Response.classBuilder() as! Response.Builder
    }
    public func getBuilder() -> Response.Builder {
        return classBuilder() as! Response.Builder
    }
    override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
        return Response.Builder()
    }
    override public func classBuilder() -> ProtocolBuffersMessageBuilder {
        return Response.Builder()
    }
    public func toBuilder() throws -> Response.Builder {
        return try Response.builderWithPrototype(prototype:self)
    }
    public class func builderWithPrototype(prototype:Response) throws -> Response.Builder {
        return try Response.Builder().mergeFrom(other:prototype)
    }
    override public func encode() throws -> Dictionary<String,Any> {
        guard isInitialized() else {
            throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
        }

        var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
        if hasMeta {
            jsonMap["meta"] = try meta.encode()
        }
        if hasData {
            jsonMap["data"] = try data.encode()
        }
        return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Response {
        return try Response.Builder.decodeToBuilder(jsonMap:jsonMap).build()
    }
    override class public func fromJSON(data:Data) throws -> Response {
        return try Response.Builder.fromJSONToBuilder(data:data).build()
    }
    override public func getDescription(indent:String) throws -> String {
        var output = ""
        if hasMeta {
            output += "\(indent) meta {\n"
            if let outDescMeta = meta {
                output += try outDescMeta.getDescription(indent: "\(indent)  ")
            }
            output += "\(indent) }\n"
        }
        if hasData {
            output += "\(indent) data {\n"
            if let outDescData = data {
                output += try outDescData.getDescription(indent: "\(indent)  ")
            }
            output += "\(indent) }\n"
        }
        output += unknownFields.getDescription(indent: indent)
        return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasMeta {
                if let hashValuemeta = meta?.hashValue {
                    hashCode = (hashCode &* 31) &+ hashValuemeta
                }
            }
            if hasData {
                if let hashValuedata = data?.hashValue {
                    hashCode = (hashCode &* 31) &+ hashValuedata
                }
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Response"
    }
    override public func className() -> String {
        return "Response"
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
        fileprivate var builderResult:Response = Response()
        public func getMessage() -> Response {
            return builderResult
        }

        required override public init () {
            super.init()
        }
        public var meta:Meta! {
            get {
                if metaBuilder_ != nil {
                    builderResult.meta = metaBuilder_.getMessage()
                }
                return builderResult.meta
            }
            set (value) {
                builderResult.hasMeta = value != nil
                builderResult.meta = value
            }
        }
        public var hasMeta:Bool {
            get {
                return builderResult.hasMeta
            }
        }
        fileprivate var metaBuilder_:Meta.Builder! {
            didSet {
                builderResult.hasMeta = true
            }
        }
        public func getMetaBuilder() -> Meta.Builder {
            if metaBuilder_ == nil {
                metaBuilder_ = Meta.Builder()
                builderResult.meta = metaBuilder_.getMessage()
                if meta != nil {
                    try! metaBuilder_.mergeFrom(other: meta)
                }
            }
            return metaBuilder_
        }
        @discardableResult
        public func setMeta(_ value:Meta!) -> Response.Builder {
            self.meta = value
            return self
        }
        @discardableResult
        public func mergeMeta(value:Meta) throws -> Response.Builder {
            if builderResult.hasMeta {
                builderResult.meta = try Meta.builderWithPrototype(prototype:builderResult.meta).mergeFrom(other: value).buildPartial()
            } else {
                builderResult.meta = value
            }
            builderResult.hasMeta = true
            return self
        }
        @discardableResult
        public func clearMeta() -> Response.Builder {
            metaBuilder_ = nil
            builderResult.hasMeta = false
            builderResult.meta = nil
            return self
        }
        public var data:ResponseData! {
            get {
                if dataBuilder_ != nil {
                    builderResult.data = dataBuilder_.getMessage()
                }
                return builderResult.data
            }
            set (value) {
                builderResult.hasData = value != nil
                builderResult.data = value
            }
        }
        public var hasData:Bool {
            get {
                return builderResult.hasData
            }
        }
        fileprivate var dataBuilder_:ResponseData.Builder! {
            didSet {
                builderResult.hasData = true
            }
        }
        public func getDataBuilder() -> ResponseData.Builder {
            if dataBuilder_ == nil {
                dataBuilder_ = ResponseData.Builder()
                builderResult.data = dataBuilder_.getMessage()
                if data != nil {
                    try! dataBuilder_.mergeFrom(other: data)
                }
            }
            return dataBuilder_
        }
        @discardableResult
        public func setData(_ value:ResponseData!) -> Response.Builder {
            self.data = value
            return self
        }
        @discardableResult
        public func mergeData(value:ResponseData) throws -> Response.Builder {
            if builderResult.hasData {
                builderResult.data = try ResponseData.builderWithPrototype(prototype:builderResult.data).mergeFrom(other: value).buildPartial()
            } else {
                builderResult.data = value
            }
            builderResult.hasData = true
            return self
        }
        @discardableResult
        public func clearData() -> Response.Builder {
            dataBuilder_ = nil
            builderResult.hasData = false
            builderResult.data = nil
            return self
        }
        override public var internalGetResult:GeneratedMessage {
            get {
                return builderResult
            }
        }
        @discardableResult
        override public func clear() -> Response.Builder {
            builderResult = Response()
            return self
        }
        override public func clone() throws -> Response.Builder {
            return try Response.builderWithPrototype(prototype:builderResult)
        }
        override public func build() throws -> Response {
            try checkInitialized()
            return buildPartial()
        }
        public func buildPartial() -> Response {
            let returnMe:Response = builderResult
            return returnMe
        }
        @discardableResult
        public func mergeFrom(other:Response) throws -> Response.Builder {
            if other == Response() {
                return self
            }
            if (other.hasMeta) {
                try mergeMeta(value: other.meta)
            }
            if (other.hasData) {
                try mergeData(value: other.data)
            }
            try merge(unknownField: other.unknownFields)
            return self
        }
        @discardableResult
        override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Response.Builder {
            return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
        }
        @discardableResult
        override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Response.Builder {
            let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
            while (true) {
                let protobufTag = try codedInputStream.readTag()
                switch protobufTag {
                case 0: 
                    self.unknownFields = try unknownFieldsBuilder.build()
                    return self

                case 10:
                    let subBuilder:Meta.Builder = Meta.Builder()
                    if hasMeta {
                        try subBuilder.mergeFrom(other: meta)
                    }
                    try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                    meta = subBuilder.buildPartial()

                case 18:
                    let subBuilder:ResponseData.Builder = ResponseData.Builder()
                    if hasData {
                        try subBuilder.mergeFrom(other: data)
                    }
                    try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                    data = subBuilder.buildPartial()

                default:
                    if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                        unknownFields = try unknownFieldsBuilder.build()
                        return self
                    }
                }
            }
        }
        class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Response.Builder {
            let resultDecodedBuilder = Response.Builder()
            if let jsonValueMeta = jsonMap["meta"] as? Dictionary<String,Any> {
                resultDecodedBuilder.meta = try Meta.Builder.decodeToBuilder(jsonMap:jsonValueMeta).build()

            }
            if let jsonValueData = jsonMap["data"] as? Dictionary<String,Any> {
                resultDecodedBuilder.data = try ResponseData.Builder.decodeToBuilder(jsonMap:jsonValueData).build()

            }
            return resultDecodedBuilder
        }
        override class public func fromJSONToBuilder(data:Data) throws -> Response.Builder {
            let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
            guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
              throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
            }
            return try Response.Builder.decodeToBuilder(jsonMap:jsDataCast)
        }
    }

}

final public class Meta : GeneratedMessage {
    public typealias BuilderType = Meta.Builder

    public static func == (lhs: Meta, rhs: Meta) -> Bool {
        if lhs === rhs {
            return true
        }
        var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
        fieldCheck = fieldCheck && (lhs.hasCode == rhs.hasCode) && (!lhs.hasCode || lhs.code == rhs.code)
        fieldCheck = fieldCheck && (lhs.hasMessage == rhs.hasMessage) && (!lhs.hasMessage || lhs.message == rhs.message)
        fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
        return fieldCheck
    }

    public fileprivate(set) var code:Int32! = nil
    public fileprivate(set) var hasCode:Bool = false

    public fileprivate(set) var message:String! = nil
    public fileprivate(set) var hasMessage:Bool = false

    required public init() {
        super.init()
    }
    override public func isInitialized() -> Bool {
        return true
    }
    override public func writeTo(codedOutputStream: CodedOutputStream) throws {
        if hasCode {
            try codedOutputStream.writeInt32(fieldNumber: 1, value:code)
        }
        if hasMessage {
            try codedOutputStream.writeString(fieldNumber: 2, value:message)
        }
        try unknownFields.writeTo(codedOutputStream: codedOutputStream)
    }
    override public func serializedSize() -> Int32 {
        var serialize_size:Int32 = memoizedSerializedSize
        if serialize_size != -1 {
         return serialize_size
        }

        serialize_size = 0
        if hasCode {
            serialize_size += code.computeInt32Size(fieldNumber: 1)
        }
        if hasMessage {
            serialize_size += message.computeStringSize(fieldNumber: 2)
        }
        serialize_size += unknownFields.serializedSize()
        memoizedSerializedSize = serialize_size
        return serialize_size
    }
    public class func getBuilder() -> Meta.Builder {
        return Meta.classBuilder() as! Meta.Builder
    }
    public func getBuilder() -> Meta.Builder {
        return classBuilder() as! Meta.Builder
    }
    override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
        return Meta.Builder()
    }
    override public func classBuilder() -> ProtocolBuffersMessageBuilder {
        return Meta.Builder()
    }
    public func toBuilder() throws -> Meta.Builder {
        return try Meta.builderWithPrototype(prototype:self)
    }
    public class func builderWithPrototype(prototype:Meta) throws -> Meta.Builder {
        return try Meta.Builder().mergeFrom(other:prototype)
    }
    override public func encode() throws -> Dictionary<String,Any> {
        guard isInitialized() else {
            throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
        }

        var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
        if hasCode {
            jsonMap["code"] = Int(code)
        }
        if hasMessage {
            jsonMap["message"] = message
        }
        return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Meta {
        return try Meta.Builder.decodeToBuilder(jsonMap:jsonMap).build()
    }
    override class public func fromJSON(data:Data) throws -> Meta {
        return try Meta.Builder.fromJSONToBuilder(data:data).build()
    }
    override public func getDescription(indent:String) throws -> String {
        var output = ""
        if hasCode {
            output += "\(indent) code: \(code) \n"
        }
        if hasMessage {
            output += "\(indent) message: \(message) \n"
        }
        output += unknownFields.getDescription(indent: indent)
        return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasCode {
                hashCode = (hashCode &* 31) &+ code.hashValue
            }
            if hasMessage {
                hashCode = (hashCode &* 31) &+ message.hashValue
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Meta"
    }
    override public func className() -> String {
        return "Meta"
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
        fileprivate var builderResult:Meta = Meta()
        public func getMessage() -> Meta {
            return builderResult
        }

        required override public init () {
            super.init()
        }
        public var code:Int32 {
            get {
                return builderResult.code
            }
            set (value) {
                builderResult.hasCode = true
                builderResult.code = value
            }
        }
        public var hasCode:Bool {
            get {
                return builderResult.hasCode
            }
        }
        @discardableResult
        public func setCode(_ value:Int32) -> Meta.Builder {
            self.code = value
            return self
        }
        @discardableResult
        public func clearCode() -> Meta.Builder{
            builderResult.hasCode = false
            builderResult.code = nil
            return self
        }
        public var message:String {
            get {
                return builderResult.message
            }
            set (value) {
                builderResult.hasMessage = true
                builderResult.message = value
            }
        }
        public var hasMessage:Bool {
            get {
                return builderResult.hasMessage
            }
        }
        @discardableResult
        public func setMessage(_ value:String) -> Meta.Builder {
            self.message = value
            return self
        }
        @discardableResult
        public func clearMessage() -> Meta.Builder{
            builderResult.hasMessage = false
            builderResult.message = nil
            return self
        }
        override public var internalGetResult:GeneratedMessage {
            get {
                return builderResult
            }
        }
        @discardableResult
        override public func clear() -> Meta.Builder {
            builderResult = Meta()
            return self
        }
        override public func clone() throws -> Meta.Builder {
            return try Meta.builderWithPrototype(prototype:builderResult)
        }
        override public func build() throws -> Meta {
            try checkInitialized()
            return buildPartial()
        }
        public func buildPartial() -> Meta {
            let returnMe:Meta = builderResult
            return returnMe
        }
        @discardableResult
        public func mergeFrom(other:Meta) throws -> Meta.Builder {
            if other == Meta() {
                return self
            }
            if other.hasCode {
                code = other.code
            }
            if other.hasMessage {
                message = other.message
            }
            try merge(unknownField: other.unknownFields)
            return self
        }
        @discardableResult
        override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Meta.Builder {
            return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
        }
        @discardableResult
        override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Meta.Builder {
            let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
            while (true) {
                let protobufTag = try codedInputStream.readTag()
                switch protobufTag {
                case 0: 
                    self.unknownFields = try unknownFieldsBuilder.build()
                    return self

                case 8:
                    code = try codedInputStream.readInt32()

                case 18:
                    message = try codedInputStream.readString()

                default:
                    if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                        unknownFields = try unknownFieldsBuilder.build()
                        return self
                    }
                }
            }
        }
        class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Meta.Builder {
            let resultDecodedBuilder = Meta.Builder()
            if let jsonValueCode = jsonMap["code"] as? Int {
                resultDecodedBuilder.code = Int32(jsonValueCode)
            } else if let jsonValueCode = jsonMap["code"] as? String {
                resultDecodedBuilder.code = Int32(jsonValueCode)!
            }
            if let jsonValueMessage = jsonMap["message"] as? String {
                resultDecodedBuilder.message = jsonValueMessage
            }
            return resultDecodedBuilder
        }
        override class public func fromJSONToBuilder(data:Data) throws -> Meta.Builder {
            let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
            guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
              throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
            }
            return try Meta.Builder.decodeToBuilder(jsonMap:jsDataCast)
        }
    }

}

final public class ResponseData : GeneratedMessage {
    public typealias BuilderType = ResponseData.Builder

    public static func == (lhs: ResponseData, rhs: ResponseData) -> Bool {
        if lhs === rhs {
            return true
        }
        var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
        fieldCheck = fieldCheck && (lhs.universities == rhs.universities)
        fieldCheck = fieldCheck && (lhs.subjects == rhs.subjects)
        fieldCheck = fieldCheck && (lhs.courses == rhs.courses)
        fieldCheck = fieldCheck && (lhs.sections == rhs.sections)
        fieldCheck = fieldCheck && (lhs.hasUniversity == rhs.hasUniversity) && (!lhs.hasUniversity || lhs.university == rhs.university)
        fieldCheck = fieldCheck && (lhs.hasSubject == rhs.hasSubject) && (!lhs.hasSubject || lhs.subject == rhs.subject)
        fieldCheck = fieldCheck && (lhs.hasCourse == rhs.hasCourse) && (!lhs.hasCourse || lhs.course == rhs.course)
        fieldCheck = fieldCheck && (lhs.hasSection == rhs.hasSection) && (!lhs.hasSection || lhs.section == rhs.section)
        fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
        return fieldCheck
    }

    public fileprivate(set) var universities:Array<University>  = Array<University>()
    public fileprivate(set) var subjects:Array<Subject>  = Array<Subject>()
    public fileprivate(set) var courses:Array<Course>  = Array<Course>()
    public fileprivate(set) var sections:Array<Section>  = Array<Section>()
    public fileprivate(set) var university:University!
    public fileprivate(set) var hasUniversity:Bool = false
    public fileprivate(set) var subject:Subject!
    public fileprivate(set) var hasSubject:Bool = false
    public fileprivate(set) var course:Course!
    public fileprivate(set) var hasCourse:Bool = false
    public fileprivate(set) var section:Section!
    public fileprivate(set) var hasSection:Bool = false
    required public init() {
        super.init()
    }
    override public func isInitialized() -> Bool {
        return true
    }
    override public func writeTo(codedOutputStream: CodedOutputStream) throws {
        for oneElementUniversities in universities {
              try codedOutputStream.writeMessage(fieldNumber: 1, value:oneElementUniversities)
        }
        for oneElementSubjects in subjects {
              try codedOutputStream.writeMessage(fieldNumber: 2, value:oneElementSubjects)
        }
        for oneElementCourses in courses {
              try codedOutputStream.writeMessage(fieldNumber: 3, value:oneElementCourses)
        }
        for oneElementSections in sections {
              try codedOutputStream.writeMessage(fieldNumber: 4, value:oneElementSections)
        }
        if hasUniversity {
            try codedOutputStream.writeMessage(fieldNumber: 5, value:university)
        }
        if hasSubject {
            try codedOutputStream.writeMessage(fieldNumber: 6, value:subject)
        }
        if hasCourse {
            try codedOutputStream.writeMessage(fieldNumber: 7, value:course)
        }
        if hasSection {
            try codedOutputStream.writeMessage(fieldNumber: 8, value:section)
        }
        try unknownFields.writeTo(codedOutputStream: codedOutputStream)
    }
    override public func serializedSize() -> Int32 {
        var serialize_size:Int32 = memoizedSerializedSize
        if serialize_size != -1 {
         return serialize_size
        }

        serialize_size = 0
        for oneElementUniversities in universities {
            serialize_size += oneElementUniversities.computeMessageSize(fieldNumber: 1)
        }
        for oneElementSubjects in subjects {
            serialize_size += oneElementSubjects.computeMessageSize(fieldNumber: 2)
        }
        for oneElementCourses in courses {
            serialize_size += oneElementCourses.computeMessageSize(fieldNumber: 3)
        }
        for oneElementSections in sections {
            serialize_size += oneElementSections.computeMessageSize(fieldNumber: 4)
        }
        if hasUniversity {
            if let varSizeuniversity = university?.computeMessageSize(fieldNumber: 5) {
                serialize_size += varSizeuniversity
            }
        }
        if hasSubject {
            if let varSizesubject = subject?.computeMessageSize(fieldNumber: 6) {
                serialize_size += varSizesubject
            }
        }
        if hasCourse {
            if let varSizecourse = course?.computeMessageSize(fieldNumber: 7) {
                serialize_size += varSizecourse
            }
        }
        if hasSection {
            if let varSizesection = section?.computeMessageSize(fieldNumber: 8) {
                serialize_size += varSizesection
            }
        }
        serialize_size += unknownFields.serializedSize()
        memoizedSerializedSize = serialize_size
        return serialize_size
    }
    public class func getBuilder() -> ResponseData.Builder {
        return ResponseData.classBuilder() as! ResponseData.Builder
    }
    public func getBuilder() -> ResponseData.Builder {
        return classBuilder() as! ResponseData.Builder
    }
    override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
        return ResponseData.Builder()
    }
    override public func classBuilder() -> ProtocolBuffersMessageBuilder {
        return ResponseData.Builder()
    }
    public func toBuilder() throws -> ResponseData.Builder {
        return try ResponseData.builderWithPrototype(prototype:self)
    }
    public class func builderWithPrototype(prototype:ResponseData) throws -> ResponseData.Builder {
        return try ResponseData.Builder().mergeFrom(other:prototype)
    }
    override public func encode() throws -> Dictionary<String,Any> {
        guard isInitialized() else {
            throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
        }

        var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
        if !universities.isEmpty {
            var jsonArrayUniversities:Array<Dictionary<String,Any>> = []
            for oneValueUniversities in universities {
                let ecodedMessageUniversities = try oneValueUniversities.encode()
                jsonArrayUniversities.append(ecodedMessageUniversities)
            }
            jsonMap["universities"] = jsonArrayUniversities
        }
        if !subjects.isEmpty {
            var jsonArraySubjects:Array<Dictionary<String,Any>> = []
            for oneValueSubjects in subjects {
                let ecodedMessageSubjects = try oneValueSubjects.encode()
                jsonArraySubjects.append(ecodedMessageSubjects)
            }
            jsonMap["subjects"] = jsonArraySubjects
        }
        if !courses.isEmpty {
            var jsonArrayCourses:Array<Dictionary<String,Any>> = []
            for oneValueCourses in courses {
                let ecodedMessageCourses = try oneValueCourses.encode()
                jsonArrayCourses.append(ecodedMessageCourses)
            }
            jsonMap["courses"] = jsonArrayCourses
        }
        if !sections.isEmpty {
            var jsonArraySections:Array<Dictionary<String,Any>> = []
            for oneValueSections in sections {
                let ecodedMessageSections = try oneValueSections.encode()
                jsonArraySections.append(ecodedMessageSections)
            }
            jsonMap["sections"] = jsonArraySections
        }
        if hasUniversity {
            jsonMap["university"] = try university.encode()
        }
        if hasSubject {
            jsonMap["subject"] = try subject.encode()
        }
        if hasCourse {
            jsonMap["course"] = try course.encode()
        }
        if hasSection {
            jsonMap["section"] = try section.encode()
        }
        return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,Any>) throws -> ResponseData {
        return try ResponseData.Builder.decodeToBuilder(jsonMap:jsonMap).build()
    }
    override class public func fromJSON(data:Data) throws -> ResponseData {
        return try ResponseData.Builder.fromJSONToBuilder(data:data).build()
    }
    override public func getDescription(indent:String) throws -> String {
        var output = ""
        var universitiesElementIndex:Int = 0
        for oneElementUniversities in universities {
            output += "\(indent) universities[\(universitiesElementIndex)] {\n"
            output += try oneElementUniversities.getDescription(indent: "\(indent)  ")
            output += "\(indent)}\n"
            universitiesElementIndex += 1
        }
        var subjectsElementIndex:Int = 0
        for oneElementSubjects in subjects {
            output += "\(indent) subjects[\(subjectsElementIndex)] {\n"
            output += try oneElementSubjects.getDescription(indent: "\(indent)  ")
            output += "\(indent)}\n"
            subjectsElementIndex += 1
        }
        var coursesElementIndex:Int = 0
        for oneElementCourses in courses {
            output += "\(indent) courses[\(coursesElementIndex)] {\n"
            output += try oneElementCourses.getDescription(indent: "\(indent)  ")
            output += "\(indent)}\n"
            coursesElementIndex += 1
        }
        var sectionsElementIndex:Int = 0
        for oneElementSections in sections {
            output += "\(indent) sections[\(sectionsElementIndex)] {\n"
            output += try oneElementSections.getDescription(indent: "\(indent)  ")
            output += "\(indent)}\n"
            sectionsElementIndex += 1
        }
        if hasUniversity {
            output += "\(indent) university {\n"
            if let outDescUniversity = university {
                output += try outDescUniversity.getDescription(indent: "\(indent)  ")
            }
            output += "\(indent) }\n"
        }
        if hasSubject {
            output += "\(indent) subject {\n"
            if let outDescSubject = subject {
                output += try outDescSubject.getDescription(indent: "\(indent)  ")
            }
            output += "\(indent) }\n"
        }
        if hasCourse {
            output += "\(indent) course {\n"
            if let outDescCourse = course {
                output += try outDescCourse.getDescription(indent: "\(indent)  ")
            }
            output += "\(indent) }\n"
        }
        if hasSection {
            output += "\(indent) section {\n"
            if let outDescSection = section {
                output += try outDescSection.getDescription(indent: "\(indent)  ")
            }
            output += "\(indent) }\n"
        }
        output += unknownFields.getDescription(indent: indent)
        return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            for oneElementUniversities in universities {
                hashCode = (hashCode &* 31) &+ oneElementUniversities.hashValue
            }
            for oneElementSubjects in subjects {
                hashCode = (hashCode &* 31) &+ oneElementSubjects.hashValue
            }
            for oneElementCourses in courses {
                hashCode = (hashCode &* 31) &+ oneElementCourses.hashValue
            }
            for oneElementSections in sections {
                hashCode = (hashCode &* 31) &+ oneElementSections.hashValue
            }
            if hasUniversity {
                if let hashValueuniversity = university?.hashValue {
                    hashCode = (hashCode &* 31) &+ hashValueuniversity
                }
            }
            if hasSubject {
                if let hashValuesubject = subject?.hashValue {
                    hashCode = (hashCode &* 31) &+ hashValuesubject
                }
            }
            if hasCourse {
                if let hashValuecourse = course?.hashValue {
                    hashCode = (hashCode &* 31) &+ hashValuecourse
                }
            }
            if hasSection {
                if let hashValuesection = section?.hashValue {
                    hashCode = (hashCode &* 31) &+ hashValuesection
                }
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "ResponseData"
    }
    override public func className() -> String {
        return "ResponseData"
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
        fileprivate var builderResult:ResponseData = ResponseData()
        public func getMessage() -> ResponseData {
            return builderResult
        }

        required override public init () {
            super.init()
        }
        public var universities:Array<University> {
            get {
                return builderResult.universities
            }
            set (value) {
                builderResult.universities = value
            }
        }
        @discardableResult
        public func setUniversities(_ value:Array<University>) -> ResponseData.Builder {
            self.universities = value
            return self
        }
        @discardableResult
        public func clearUniversities() -> ResponseData.Builder {
            builderResult.universities.removeAll(keepingCapacity: false)
            return self
        }
        public var subjects:Array<Subject> {
            get {
                return builderResult.subjects
            }
            set (value) {
                builderResult.subjects = value
            }
        }
        @discardableResult
        public func setSubjects(_ value:Array<Subject>) -> ResponseData.Builder {
            self.subjects = value
            return self
        }
        @discardableResult
        public func clearSubjects() -> ResponseData.Builder {
            builderResult.subjects.removeAll(keepingCapacity: false)
            return self
        }
        public var courses:Array<Course> {
            get {
                return builderResult.courses
            }
            set (value) {
                builderResult.courses = value
            }
        }
        @discardableResult
        public func setCourses(_ value:Array<Course>) -> ResponseData.Builder {
            self.courses = value
            return self
        }
        @discardableResult
        public func clearCourses() -> ResponseData.Builder {
            builderResult.courses.removeAll(keepingCapacity: false)
            return self
        }
        public var sections:Array<Section> {
            get {
                return builderResult.sections
            }
            set (value) {
                builderResult.sections = value
            }
        }
        @discardableResult
        public func setSections(_ value:Array<Section>) -> ResponseData.Builder {
            self.sections = value
            return self
        }
        @discardableResult
        public func clearSections() -> ResponseData.Builder {
            builderResult.sections.removeAll(keepingCapacity: false)
            return self
        }
        public var university:University! {
            get {
                if universityBuilder_ != nil {
                    builderResult.university = universityBuilder_.getMessage()
                }
                return builderResult.university
            }
            set (value) {
                builderResult.hasUniversity = value != nil
                builderResult.university = value
            }
        }
        public var hasUniversity:Bool {
            get {
                return builderResult.hasUniversity
            }
        }
        fileprivate var universityBuilder_:University.Builder! {
            didSet {
                builderResult.hasUniversity = true
            }
        }
        public func getUniversityBuilder() -> University.Builder {
            if universityBuilder_ == nil {
                universityBuilder_ = University.Builder()
                builderResult.university = universityBuilder_.getMessage()
                if university != nil {
                    try! universityBuilder_.mergeFrom(other: university)
                }
            }
            return universityBuilder_
        }
        @discardableResult
        public func setUniversity(_ value:University!) -> ResponseData.Builder {
            self.university = value
            return self
        }
        @discardableResult
        public func mergeUniversity(value:University) throws -> ResponseData.Builder {
            if builderResult.hasUniversity {
                builderResult.university = try University.builderWithPrototype(prototype:builderResult.university).mergeFrom(other: value).buildPartial()
            } else {
                builderResult.university = value
            }
            builderResult.hasUniversity = true
            return self
        }
        @discardableResult
        public func clearUniversity() -> ResponseData.Builder {
            universityBuilder_ = nil
            builderResult.hasUniversity = false
            builderResult.university = nil
            return self
        }
        public var subject:Subject! {
            get {
                if subjectBuilder_ != nil {
                    builderResult.subject = subjectBuilder_.getMessage()
                }
                return builderResult.subject
            }
            set (value) {
                builderResult.hasSubject = value != nil
                builderResult.subject = value
            }
        }
        public var hasSubject:Bool {
            get {
                return builderResult.hasSubject
            }
        }
        fileprivate var subjectBuilder_:Subject.Builder! {
            didSet {
                builderResult.hasSubject = true
            }
        }
        public func getSubjectBuilder() -> Subject.Builder {
            if subjectBuilder_ == nil {
                subjectBuilder_ = Subject.Builder()
                builderResult.subject = subjectBuilder_.getMessage()
                if subject != nil {
                    try! subjectBuilder_.mergeFrom(other: subject)
                }
            }
            return subjectBuilder_
        }
        @discardableResult
        public func setSubject(_ value:Subject!) -> ResponseData.Builder {
            self.subject = value
            return self
        }
        @discardableResult
        public func mergeSubject(value:Subject) throws -> ResponseData.Builder {
            if builderResult.hasSubject {
                builderResult.subject = try Subject.builderWithPrototype(prototype:builderResult.subject).mergeFrom(other: value).buildPartial()
            } else {
                builderResult.subject = value
            }
            builderResult.hasSubject = true
            return self
        }
        @discardableResult
        public func clearSubject() -> ResponseData.Builder {
            subjectBuilder_ = nil
            builderResult.hasSubject = false
            builderResult.subject = nil
            return self
        }
        public var course:Course! {
            get {
                if courseBuilder_ != nil {
                    builderResult.course = courseBuilder_.getMessage()
                }
                return builderResult.course
            }
            set (value) {
                builderResult.hasCourse = value != nil
                builderResult.course = value
            }
        }
        public var hasCourse:Bool {
            get {
                return builderResult.hasCourse
            }
        }
        fileprivate var courseBuilder_:Course.Builder! {
            didSet {
                builderResult.hasCourse = true
            }
        }
        public func getCourseBuilder() -> Course.Builder {
            if courseBuilder_ == nil {
                courseBuilder_ = Course.Builder()
                builderResult.course = courseBuilder_.getMessage()
                if course != nil {
                    try! courseBuilder_.mergeFrom(other: course)
                }
            }
            return courseBuilder_
        }
        @discardableResult
        public func setCourse(_ value:Course!) -> ResponseData.Builder {
            self.course = value
            return self
        }
        @discardableResult
        public func mergeCourse(value:Course) throws -> ResponseData.Builder {
            if builderResult.hasCourse {
                builderResult.course = try Course.builderWithPrototype(prototype:builderResult.course).mergeFrom(other: value).buildPartial()
            } else {
                builderResult.course = value
            }
            builderResult.hasCourse = true
            return self
        }
        @discardableResult
        public func clearCourse() -> ResponseData.Builder {
            courseBuilder_ = nil
            builderResult.hasCourse = false
            builderResult.course = nil
            return self
        }
        public var section:Section! {
            get {
                if sectionBuilder_ != nil {
                    builderResult.section = sectionBuilder_.getMessage()
                }
                return builderResult.section
            }
            set (value) {
                builderResult.hasSection = value != nil
                builderResult.section = value
            }
        }
        public var hasSection:Bool {
            get {
                return builderResult.hasSection
            }
        }
        fileprivate var sectionBuilder_:Section.Builder! {
            didSet {
                builderResult.hasSection = true
            }
        }
        public func getSectionBuilder() -> Section.Builder {
            if sectionBuilder_ == nil {
                sectionBuilder_ = Section.Builder()
                builderResult.section = sectionBuilder_.getMessage()
                if section != nil {
                    try! sectionBuilder_.mergeFrom(other: section)
                }
            }
            return sectionBuilder_
        }
        @discardableResult
        public func setSection(_ value:Section!) -> ResponseData.Builder {
            self.section = value
            return self
        }
        @discardableResult
        public func mergeSection(value:Section) throws -> ResponseData.Builder {
            if builderResult.hasSection {
                builderResult.section = try Section.builderWithPrototype(prototype:builderResult.section).mergeFrom(other: value).buildPartial()
            } else {
                builderResult.section = value
            }
            builderResult.hasSection = true
            return self
        }
        @discardableResult
        public func clearSection() -> ResponseData.Builder {
            sectionBuilder_ = nil
            builderResult.hasSection = false
            builderResult.section = nil
            return self
        }
        override public var internalGetResult:GeneratedMessage {
            get {
                return builderResult
            }
        }
        @discardableResult
        override public func clear() -> ResponseData.Builder {
            builderResult = ResponseData()
            return self
        }
        override public func clone() throws -> ResponseData.Builder {
            return try ResponseData.builderWithPrototype(prototype:builderResult)
        }
        override public func build() throws -> ResponseData {
            try checkInitialized()
            return buildPartial()
        }
        public func buildPartial() -> ResponseData {
            let returnMe:ResponseData = builderResult
            return returnMe
        }
        @discardableResult
        public func mergeFrom(other:ResponseData) throws -> ResponseData.Builder {
            if other == ResponseData() {
                return self
            }
            if !other.universities.isEmpty  {
                 builderResult.universities += other.universities
            }
            if !other.subjects.isEmpty  {
                 builderResult.subjects += other.subjects
            }
            if !other.courses.isEmpty  {
                 builderResult.courses += other.courses
            }
            if !other.sections.isEmpty  {
                 builderResult.sections += other.sections
            }
            if (other.hasUniversity) {
                try mergeUniversity(value: other.university)
            }
            if (other.hasSubject) {
                try mergeSubject(value: other.subject)
            }
            if (other.hasCourse) {
                try mergeCourse(value: other.course)
            }
            if (other.hasSection) {
                try mergeSection(value: other.section)
            }
            try merge(unknownField: other.unknownFields)
            return self
        }
        @discardableResult
        override public func mergeFrom(codedInputStream: CodedInputStream) throws -> ResponseData.Builder {
            return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
        }
        @discardableResult
        override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> ResponseData.Builder {
            let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
            while (true) {
                let protobufTag = try codedInputStream.readTag()
                switch protobufTag {
                case 0: 
                    self.unknownFields = try unknownFieldsBuilder.build()
                    return self

                case 10:
                    let subBuilder = University.Builder()
                    try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
                    universities.append(subBuilder.buildPartial())

                case 18:
                    let subBuilder = Subject.Builder()
                    try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
                    subjects.append(subBuilder.buildPartial())

                case 26:
                    let subBuilder = Course.Builder()
                    try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
                    courses.append(subBuilder.buildPartial())

                case 34:
                    let subBuilder = Section.Builder()
                    try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
                    sections.append(subBuilder.buildPartial())

                case 42:
                    let subBuilder:University.Builder = University.Builder()
                    if hasUniversity {
                        try subBuilder.mergeFrom(other: university)
                    }
                    try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                    university = subBuilder.buildPartial()

                case 50:
                    let subBuilder:Subject.Builder = Subject.Builder()
                    if hasSubject {
                        try subBuilder.mergeFrom(other: subject)
                    }
                    try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                    subject = subBuilder.buildPartial()

                case 58:
                    let subBuilder:Course.Builder = Course.Builder()
                    if hasCourse {
                        try subBuilder.mergeFrom(other: course)
                    }
                    try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                    course = subBuilder.buildPartial()

                case 66:
                    let subBuilder:Section.Builder = Section.Builder()
                    if hasSection {
                        try subBuilder.mergeFrom(other: section)
                    }
                    try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                    section = subBuilder.buildPartial()

                default:
                    if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                        unknownFields = try unknownFieldsBuilder.build()
                        return self
                    }
                }
            }
        }
        class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> ResponseData.Builder {
            let resultDecodedBuilder = ResponseData.Builder()
            if let jsonValueUniversities = jsonMap["universities"] as? Array<Dictionary<String,Any>> {
                var jsonArrayUniversities:Array<University> = []
                for oneValueUniversities in jsonValueUniversities {
                    let messageFromStringUniversities = try University.Builder.decodeToBuilder(jsonMap:oneValueUniversities).build()

                    jsonArrayUniversities.append(messageFromStringUniversities)
                }
                resultDecodedBuilder.universities = jsonArrayUniversities
            }
            if let jsonValueSubjects = jsonMap["subjects"] as? Array<Dictionary<String,Any>> {
                var jsonArraySubjects:Array<Subject> = []
                for oneValueSubjects in jsonValueSubjects {
                    let messageFromStringSubjects = try Subject.Builder.decodeToBuilder(jsonMap:oneValueSubjects).build()

                    jsonArraySubjects.append(messageFromStringSubjects)
                }
                resultDecodedBuilder.subjects = jsonArraySubjects
            }
            if let jsonValueCourses = jsonMap["courses"] as? Array<Dictionary<String,Any>> {
                var jsonArrayCourses:Array<Course> = []
                for oneValueCourses in jsonValueCourses {
                    let messageFromStringCourses = try Course.Builder.decodeToBuilder(jsonMap:oneValueCourses).build()

                    jsonArrayCourses.append(messageFromStringCourses)
                }
                resultDecodedBuilder.courses = jsonArrayCourses
            }
            if let jsonValueSections = jsonMap["sections"] as? Array<Dictionary<String,Any>> {
                var jsonArraySections:Array<Section> = []
                for oneValueSections in jsonValueSections {
                    let messageFromStringSections = try Section.Builder.decodeToBuilder(jsonMap:oneValueSections).build()

                    jsonArraySections.append(messageFromStringSections)
                }
                resultDecodedBuilder.sections = jsonArraySections
            }
            if let jsonValueUniversity = jsonMap["university"] as? Dictionary<String,Any> {
                resultDecodedBuilder.university = try University.Builder.decodeToBuilder(jsonMap:jsonValueUniversity).build()

            }
            if let jsonValueSubject = jsonMap["subject"] as? Dictionary<String,Any> {
                resultDecodedBuilder.subject = try Subject.Builder.decodeToBuilder(jsonMap:jsonValueSubject).build()

            }
            if let jsonValueCourse = jsonMap["course"] as? Dictionary<String,Any> {
                resultDecodedBuilder.course = try Course.Builder.decodeToBuilder(jsonMap:jsonValueCourse).build()

            }
            if let jsonValueSection = jsonMap["section"] as? Dictionary<String,Any> {
                resultDecodedBuilder.section = try Section.Builder.decodeToBuilder(jsonMap:jsonValueSection).build()

            }
            return resultDecodedBuilder
        }
        override class public func fromJSONToBuilder(data:Data) throws -> ResponseData.Builder {
            let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
            guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
              throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
            }
            return try ResponseData.Builder.decodeToBuilder(jsonMap:jsDataCast)
        }
    }

}

extension University: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<University> {
        var mergedArray = Array<University>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> University? {
        return try University.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> University {
        return try University.Builder().mergeFrom(data: data, extensionRegistry:ModelRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> University {
        return try University.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> University {
        return try University.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> University {
        return try University.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> University {
        return try University.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> University {
        return try University.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "id": return self.id
        case "name": return self.name
        case "abbr": return self.abbr
        case "homePage": return self.homePage
        case "registrationPage": return self.registrationPage
        case "mainColor": return self.mainColor
        case "accentColor": return self.accentColor
        case "topicName": return self.topicName
        case "topicId": return self.topicId
        case "resolvedSemesters": return self.resolvedSemesters
        case "subjects": return self.subjects
        case "availableSemesters": return self.availableSemesters
        case "registrations": return self.registrations
        case "metadata": return self.metadata
        default: return nil
        }
    }
}
extension University.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = University
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "id": return self.id
            case "name": return self.name
            case "abbr": return self.abbr
            case "homePage": return self.homePage
            case "registrationPage": return self.registrationPage
            case "mainColor": return self.mainColor
            case "accentColor": return self.accentColor
            case "topicName": return self.topicName
            case "topicId": return self.topicId
            case "resolvedSemesters": return self.resolvedSemesters
            case "subjects": return self.subjects
            case "availableSemesters": return self.availableSemesters
            case "registrations": return self.registrations
            case "metadata": return self.metadata
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "id":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.id = newSubscriptValue
            case "name":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.name = newSubscriptValue
            case "abbr":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.abbr = newSubscriptValue
            case "homePage":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.homePage = newSubscriptValue
            case "registrationPage":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.registrationPage = newSubscriptValue
            case "mainColor":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.mainColor = newSubscriptValue
            case "accentColor":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.accentColor = newSubscriptValue
            case "topicName":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.topicName = newSubscriptValue
            case "topicId":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.topicId = newSubscriptValue
            case "resolvedSemesters":
                guard let newSubscriptValue = newSubscriptValue as? ResolvedSemester else {
                    return
                }
                self.resolvedSemesters = newSubscriptValue
            case "subjects":
                guard let newSubscriptValue = newSubscriptValue as? Array<Subject> else {
                    return
                }
                self.subjects = newSubscriptValue
            case "availableSemesters":
                guard let newSubscriptValue = newSubscriptValue as? Array<Semester> else {
                    return
                }
                self.availableSemesters = newSubscriptValue
            case "registrations":
                guard let newSubscriptValue = newSubscriptValue as? Array<Registration> else {
                    return
                }
                self.registrations = newSubscriptValue
            case "metadata":
                guard let newSubscriptValue = newSubscriptValue as? Array<Metadata> else {
                    return
                }
                self.metadata = newSubscriptValue
            default: return
            }
        }
    }
}
extension Subject: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Subject> {
        var mergedArray = Array<Subject>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Subject? {
        return try Subject.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Subject {
        return try Subject.Builder().mergeFrom(data: data, extensionRegistry:ModelRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Subject {
        return try Subject.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Subject {
        return try Subject.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Subject {
        return try Subject.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Subject {
        return try Subject.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Subject {
        return try Subject.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "id": return self.id
        case "universityId": return self.universityId
        case "name": return self.name
        case "number": return self.number
        case "season": return self.season
        case "year": return self.year
        case "topicName": return self.topicName
        case "topicId": return self.topicId
        case "courses": return self.courses
        case "metadata": return self.metadata
        default: return nil
        }
    }
}
extension Subject.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Subject
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "id": return self.id
            case "universityId": return self.universityId
            case "name": return self.name
            case "number": return self.number
            case "season": return self.season
            case "year": return self.year
            case "topicName": return self.topicName
            case "topicId": return self.topicId
            case "courses": return self.courses
            case "metadata": return self.metadata
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "id":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.id = newSubscriptValue
            case "universityId":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.universityId = newSubscriptValue
            case "name":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.name = newSubscriptValue
            case "number":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.number = newSubscriptValue
            case "season":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.season = newSubscriptValue
            case "year":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.year = newSubscriptValue
            case "topicName":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.topicName = newSubscriptValue
            case "topicId":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.topicId = newSubscriptValue
            case "courses":
                guard let newSubscriptValue = newSubscriptValue as? Array<Course> else {
                    return
                }
                self.courses = newSubscriptValue
            case "metadata":
                guard let newSubscriptValue = newSubscriptValue as? Array<Metadata> else {
                    return
                }
                self.metadata = newSubscriptValue
            default: return
            }
        }
    }
}
extension Course: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Course> {
        var mergedArray = Array<Course>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Course? {
        return try Course.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Course {
        return try Course.Builder().mergeFrom(data: data, extensionRegistry:ModelRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Course {
        return try Course.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Course {
        return try Course.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Course {
        return try Course.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Course {
        return try Course.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Course {
        return try Course.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "id": return self.id
        case "subjectId": return self.subjectId
        case "name": return self.name
        case "number": return self.number
        case "synopsis": return self.synopsis
        case "topicName": return self.topicName
        case "topicId": return self.topicId
        case "sections": return self.sections
        case "metadata": return self.metadata
        default: return nil
        }
    }
}
extension Course.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Course
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "id": return self.id
            case "subjectId": return self.subjectId
            case "name": return self.name
            case "number": return self.number
            case "synopsis": return self.synopsis
            case "topicName": return self.topicName
            case "topicId": return self.topicId
            case "sections": return self.sections
            case "metadata": return self.metadata
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "id":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.id = newSubscriptValue
            case "subjectId":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.subjectId = newSubscriptValue
            case "name":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.name = newSubscriptValue
            case "number":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.number = newSubscriptValue
            case "synopsis":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.synopsis = newSubscriptValue
            case "topicName":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.topicName = newSubscriptValue
            case "topicId":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.topicId = newSubscriptValue
            case "sections":
                guard let newSubscriptValue = newSubscriptValue as? Array<Section> else {
                    return
                }
                self.sections = newSubscriptValue
            case "metadata":
                guard let newSubscriptValue = newSubscriptValue as? Array<Metadata> else {
                    return
                }
                self.metadata = newSubscriptValue
            default: return
            }
        }
    }
}
extension Section: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Section> {
        var mergedArray = Array<Section>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Section? {
        return try Section.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Section {
        return try Section.Builder().mergeFrom(data: data, extensionRegistry:ModelRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Section {
        return try Section.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Section {
        return try Section.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Section {
        return try Section.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Section {
        return try Section.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Section {
        return try Section.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "id": return self.id
        case "courseId": return self.courseId
        case "number": return self.number
        case "callNumber": return self.callNumber
        case "max": return self.max
        case "now": return self.now
        case "status": return self.status
        case "credits": return self.credits
        case "topicName": return self.topicName
        case "topicId": return self.topicId
        case "meetings": return self.meetings
        case "instructors": return self.instructors
        case "books": return self.books
        case "metadata": return self.metadata
        default: return nil
        }
    }
}
extension Section.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Section
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "id": return self.id
            case "courseId": return self.courseId
            case "number": return self.number
            case "callNumber": return self.callNumber
            case "max": return self.max
            case "now": return self.now
            case "status": return self.status
            case "credits": return self.credits
            case "topicName": return self.topicName
            case "topicId": return self.topicId
            case "meetings": return self.meetings
            case "instructors": return self.instructors
            case "books": return self.books
            case "metadata": return self.metadata
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "id":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.id = newSubscriptValue
            case "courseId":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.courseId = newSubscriptValue
            case "number":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.number = newSubscriptValue
            case "callNumber":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.callNumber = newSubscriptValue
            case "max":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.max = newSubscriptValue
            case "now":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.now = newSubscriptValue
            case "status":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.status = newSubscriptValue
            case "credits":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.credits = newSubscriptValue
            case "topicName":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.topicName = newSubscriptValue
            case "topicId":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.topicId = newSubscriptValue
            case "meetings":
                guard let newSubscriptValue = newSubscriptValue as? Array<Meeting> else {
                    return
                }
                self.meetings = newSubscriptValue
            case "instructors":
                guard let newSubscriptValue = newSubscriptValue as? Array<Instructor> else {
                    return
                }
                self.instructors = newSubscriptValue
            case "books":
                guard let newSubscriptValue = newSubscriptValue as? Array<Book> else {
                    return
                }
                self.books = newSubscriptValue
            case "metadata":
                guard let newSubscriptValue = newSubscriptValue as? Array<Metadata> else {
                    return
                }
                self.metadata = newSubscriptValue
            default: return
            }
        }
    }
}
extension Meeting: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Meeting> {
        var mergedArray = Array<Meeting>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Meeting? {
        return try Meeting.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Meeting {
        return try Meeting.Builder().mergeFrom(data: data, extensionRegistry:ModelRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Meeting {
        return try Meeting.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Meeting {
        return try Meeting.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Meeting {
        return try Meeting.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Meeting {
        return try Meeting.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Meeting {
        return try Meeting.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "id": return self.id
        case "sectionId": return self.sectionId
        case "room": return self.room
        case "day": return self.day
        case "startTime": return self.startTime
        case "endTime": return self.endTime
        case "classType": return self.classType
        case "index": return self.index
        case "metadata": return self.metadata
        default: return nil
        }
    }
}
extension Meeting.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Meeting
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "id": return self.id
            case "sectionId": return self.sectionId
            case "room": return self.room
            case "day": return self.day
            case "startTime": return self.startTime
            case "endTime": return self.endTime
            case "classType": return self.classType
            case "index": return self.index
            case "metadata": return self.metadata
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "id":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.id = newSubscriptValue
            case "sectionId":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.sectionId = newSubscriptValue
            case "room":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.room = newSubscriptValue
            case "day":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.day = newSubscriptValue
            case "startTime":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.startTime = newSubscriptValue
            case "endTime":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.endTime = newSubscriptValue
            case "classType":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.classType = newSubscriptValue
            case "index":
                guard let newSubscriptValue = newSubscriptValue as? Int32 else {
                    return
                }
                self.index = newSubscriptValue
            case "metadata":
                guard let newSubscriptValue = newSubscriptValue as? Array<Metadata> else {
                    return
                }
                self.metadata = newSubscriptValue
            default: return
            }
        }
    }
}
extension Instructor: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Instructor> {
        var mergedArray = Array<Instructor>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Instructor? {
        return try Instructor.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Instructor {
        return try Instructor.Builder().mergeFrom(data: data, extensionRegistry:ModelRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Instructor {
        return try Instructor.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Instructor {
        return try Instructor.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Instructor {
        return try Instructor.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Instructor {
        return try Instructor.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Instructor {
        return try Instructor.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "id": return self.id
        case "sectionId": return self.sectionId
        case "name": return self.name
        case "index": return self.index
        default: return nil
        }
    }
}
extension Instructor.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Instructor
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "id": return self.id
            case "sectionId": return self.sectionId
            case "name": return self.name
            case "index": return self.index
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "id":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.id = newSubscriptValue
            case "sectionId":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.sectionId = newSubscriptValue
            case "name":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.name = newSubscriptValue
            case "index":
                guard let newSubscriptValue = newSubscriptValue as? Int32 else {
                    return
                }
                self.index = newSubscriptValue
            default: return
            }
        }
    }
}
extension Book: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Book> {
        var mergedArray = Array<Book>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Book? {
        return try Book.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Book {
        return try Book.Builder().mergeFrom(data: data, extensionRegistry:ModelRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Book {
        return try Book.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Book {
        return try Book.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Book {
        return try Book.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Book {
        return try Book.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Book {
        return try Book.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "id": return self.id
        case "sectionId": return self.sectionId
        case "title": return self.title
        case "url": return self.url
        default: return nil
        }
    }
}
extension Book.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Book
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "id": return self.id
            case "sectionId": return self.sectionId
            case "title": return self.title
            case "url": return self.url
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "id":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.id = newSubscriptValue
            case "sectionId":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.sectionId = newSubscriptValue
            case "title":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.title = newSubscriptValue
            case "url":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.url = newSubscriptValue
            default: return
            }
        }
    }
}
extension Metadata: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Metadata> {
        var mergedArray = Array<Metadata>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Metadata? {
        return try Metadata.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Metadata {
        return try Metadata.Builder().mergeFrom(data: data, extensionRegistry:ModelRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Metadata {
        return try Metadata.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Metadata {
        return try Metadata.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Metadata {
        return try Metadata.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Metadata {
        return try Metadata.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Metadata {
        return try Metadata.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "id": return self.id
        case "universityId": return self.universityId
        case "subjectId": return self.subjectId
        case "courseId": return self.courseId
        case "sectionId": return self.sectionId
        case "meetingId": return self.meetingId
        case "title": return self.title
        case "content": return self.content
        default: return nil
        }
    }
}
extension Metadata.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Metadata
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "id": return self.id
            case "universityId": return self.universityId
            case "subjectId": return self.subjectId
            case "courseId": return self.courseId
            case "sectionId": return self.sectionId
            case "meetingId": return self.meetingId
            case "title": return self.title
            case "content": return self.content
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "id":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.id = newSubscriptValue
            case "universityId":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.universityId = newSubscriptValue
            case "subjectId":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.subjectId = newSubscriptValue
            case "courseId":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.courseId = newSubscriptValue
            case "sectionId":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.sectionId = newSubscriptValue
            case "meetingId":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.meetingId = newSubscriptValue
            case "title":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.title = newSubscriptValue
            case "content":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.content = newSubscriptValue
            default: return
            }
        }
    }
}
extension Registration: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Registration> {
        var mergedArray = Array<Registration>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Registration? {
        return try Registration.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Registration {
        return try Registration.Builder().mergeFrom(data: data, extensionRegistry:ModelRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Registration {
        return try Registration.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Registration {
        return try Registration.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Registration {
        return try Registration.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Registration {
        return try Registration.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Registration {
        return try Registration.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "id": return self.id
        case "universityId": return self.universityId
        case "period": return self.period
        case "periodDate": return self.periodDate
        default: return nil
        }
    }
}
extension Registration.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Registration
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "id": return self.id
            case "universityId": return self.universityId
            case "period": return self.period
            case "periodDate": return self.periodDate
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "id":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.id = newSubscriptValue
            case "universityId":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.universityId = newSubscriptValue
            case "period":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.period = newSubscriptValue
            case "periodDate":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.periodDate = newSubscriptValue
            default: return
            }
        }
    }
}
extension ResolvedSemester: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<ResolvedSemester> {
        var mergedArray = Array<ResolvedSemester>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> ResolvedSemester? {
        return try ResolvedSemester.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> ResolvedSemester {
        return try ResolvedSemester.Builder().mergeFrom(data: data, extensionRegistry:ModelRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> ResolvedSemester {
        return try ResolvedSemester.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> ResolvedSemester {
        return try ResolvedSemester.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> ResolvedSemester {
        return try ResolvedSemester.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> ResolvedSemester {
        return try ResolvedSemester.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> ResolvedSemester {
        return try ResolvedSemester.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "current": return self.current
        case "last": return self.last
        case "next": return self.next
        default: return nil
        }
    }
}
extension ResolvedSemester.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = ResolvedSemester
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "current": return self.current
            case "last": return self.last
            case "next": return self.next
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "current":
                guard let newSubscriptValue = newSubscriptValue as? Semester else {
                    return
                }
                self.current = newSubscriptValue
            case "last":
                guard let newSubscriptValue = newSubscriptValue as? Semester else {
                    return
                }
                self.last = newSubscriptValue
            case "next":
                guard let newSubscriptValue = newSubscriptValue as? Semester else {
                    return
                }
                self.next = newSubscriptValue
            default: return
            }
        }
    }
}
extension Semester: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Semester> {
        var mergedArray = Array<Semester>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Semester? {
        return try Semester.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Semester {
        return try Semester.Builder().mergeFrom(data: data, extensionRegistry:ModelRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Semester {
        return try Semester.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Semester {
        return try Semester.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Semester {
        return try Semester.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Semester {
        return try Semester.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Semester {
        return try Semester.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "year": return self.year
        case "season": return self.season
        default: return nil
        }
    }
}
extension Semester.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Semester
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "year": return self.year
            case "season": return self.season
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "year":
                guard let newSubscriptValue = newSubscriptValue as? Int32 else {
                    return
                }
                self.year = newSubscriptValue
            case "season":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.season = newSubscriptValue
            default: return
            }
        }
    }
}
extension Uctnotification: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Uctnotification> {
        var mergedArray = Array<Uctnotification>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Uctnotification? {
        return try Uctnotification.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Uctnotification {
        return try Uctnotification.Builder().mergeFrom(data: data, extensionRegistry:ModelRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Uctnotification {
        return try Uctnotification.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Uctnotification {
        return try Uctnotification.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Uctnotification {
        return try Uctnotification.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Uctnotification {
        return try Uctnotification.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Uctnotification {
        return try Uctnotification.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "notificationId": return self.notificationId
        case "topicName": return self.topicName
        case "status": return self.status
        case "university": return self.university
        default: return nil
        }
    }
}
extension Uctnotification.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Uctnotification
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "notificationId": return self.notificationId
            case "topicName": return self.topicName
            case "status": return self.status
            case "university": return self.university
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "notificationId":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.notificationId = newSubscriptValue
            case "topicName":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.topicName = newSubscriptValue
            case "status":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.status = newSubscriptValue
            case "university":
                guard let newSubscriptValue = newSubscriptValue as? University else {
                    return
                }
                self.university = newSubscriptValue
            default: return
            }
        }
    }
}
extension Response: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Response> {
        var mergedArray = Array<Response>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Response? {
        return try Response.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Response {
        return try Response.Builder().mergeFrom(data: data, extensionRegistry:ModelRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Response {
        return try Response.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Response {
        return try Response.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Response {
        return try Response.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Response {
        return try Response.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Response {
        return try Response.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "meta": return self.meta
        case "data": return self.data
        default: return nil
        }
    }
}
extension Response.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Response
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "meta": return self.meta
            case "data": return self.data
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "meta":
                guard let newSubscriptValue = newSubscriptValue as? Meta else {
                    return
                }
                self.meta = newSubscriptValue
            case "data":
                guard let newSubscriptValue = newSubscriptValue as? ResponseData else {
                    return
                }
                self.data = newSubscriptValue
            default: return
            }
        }
    }
}
extension Meta: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Meta> {
        var mergedArray = Array<Meta>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Meta? {
        return try Meta.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Meta {
        return try Meta.Builder().mergeFrom(data: data, extensionRegistry:ModelRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Meta {
        return try Meta.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Meta {
        return try Meta.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Meta {
        return try Meta.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Meta {
        return try Meta.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Meta {
        return try Meta.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "code": return self.code
        case "message": return self.message
        default: return nil
        }
    }
}
extension Meta.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = Meta
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "code": return self.code
            case "message": return self.message
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "code":
                guard let newSubscriptValue = newSubscriptValue as? Int32 else {
                    return
                }
                self.code = newSubscriptValue
            case "message":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.message = newSubscriptValue
            default: return
            }
        }
    }
}
extension ResponseData: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<ResponseData> {
        var mergedArray = Array<ResponseData>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> ResponseData? {
        return try ResponseData.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> ResponseData {
        return try ResponseData.Builder().mergeFrom(data: data, extensionRegistry:ModelRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> ResponseData {
        return try ResponseData.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> ResponseData {
        return try ResponseData.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> ResponseData {
        return try ResponseData.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> ResponseData {
        return try ResponseData.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> ResponseData {
        return try ResponseData.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "universities": return self.universities
        case "subjects": return self.subjects
        case "courses": return self.courses
        case "sections": return self.sections
        case "university": return self.university
        case "subject": return self.subject
        case "course": return self.course
        case "section": return self.section
        default: return nil
        }
    }
}
extension ResponseData.Builder: GeneratedMessageBuilderProtocol {
    public typealias GeneratedMessageType = ResponseData
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "universities": return self.universities
            case "subjects": return self.subjects
            case "courses": return self.courses
            case "sections": return self.sections
            case "university": return self.university
            case "subject": return self.subject
            case "course": return self.course
            case "section": return self.section
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "universities":
                guard let newSubscriptValue = newSubscriptValue as? Array<University> else {
                    return
                }
                self.universities = newSubscriptValue
            case "subjects":
                guard let newSubscriptValue = newSubscriptValue as? Array<Subject> else {
                    return
                }
                self.subjects = newSubscriptValue
            case "courses":
                guard let newSubscriptValue = newSubscriptValue as? Array<Course> else {
                    return
                }
                self.courses = newSubscriptValue
            case "sections":
                guard let newSubscriptValue = newSubscriptValue as? Array<Section> else {
                    return
                }
                self.sections = newSubscriptValue
            case "university":
                guard let newSubscriptValue = newSubscriptValue as? University else {
                    return
                }
                self.university = newSubscriptValue
            case "subject":
                guard let newSubscriptValue = newSubscriptValue as? Subject else {
                    return
                }
                self.subject = newSubscriptValue
            case "course":
                guard let newSubscriptValue = newSubscriptValue as? Course else {
                    return
                }
                self.course = newSubscriptValue
            case "section":
                guard let newSubscriptValue = newSubscriptValue as? Section else {
                    return
                }
                self.section = newSubscriptValue
            default: return
            }
        }
    }
}

// @@protoc_insertion_point(global_scope)
